+++
title = "Rust æ—¥å¿—å¤„ç†å®æˆ˜ï¼šä» tracing åˆ°æ–‡ä»¶è¾“å‡ºä¸€æ­¥æ­¥ä¼˜åŒ–"
description = "Rust æ—¥å¿—å¤„ç†å®æˆ˜ï¼šä» tracing åˆ°æ–‡ä»¶è¾“å‡ºä¸€æ­¥æ­¥ä¼˜åŒ–"
date = 2025-03-17 15:03:26+08:00
[taxonomies]
categories = ["Rust"]
tags = ["Rust"]

+++

<!-- more -->
# Rust æ—¥å¿—å¤„ç†å®æˆ˜ï¼šä» tracing åˆ°æ–‡ä»¶è¾“å‡ºä¸€æ­¥æ­¥ä¼˜åŒ–

åœ¨ Rust å¼€å‘ä¸­ï¼Œæ—¥å¿—æ˜¯è°ƒè¯•å’Œç›‘æ§çš„é‡è¦å·¥å…·ã€‚tracing å’Œ tracing-subscriber æä¾›äº†çµæ´»è€Œå¼ºå¤§çš„æ—¥å¿—å¤„ç†èƒ½åŠ›ï¼Œé€‚ç”¨äºä»ç®€å•æ§åˆ¶å°è¾“å‡ºåˆ°å¤æ‚åˆ†å¸ƒå¼ç³»ç»Ÿçš„éœ€æ±‚ã€‚æœ¬æ–‡å°†é€šè¿‡ä¸€ä¸ª Axum é¡¹ç›®ç¤ºä¾‹ï¼Œå¸¦ä½ é€æ­¥æŒæ¡æ—¥å¿—çš„é…ç½®ã€ä¼˜åŒ–ä»¥åŠæ–‡ä»¶è¾“å‡ºï¼Œå¸®åŠ©ä½ åœ¨å®è·µä¸­å…»æˆè‰¯å¥½çš„æ—¥å¿—ä¹ æƒ¯ã€‚

æœ¬æ–‡ä»¥ä¸€ä¸ªåŸºäº Axum çš„ Rust é¡¹ç›®ä¸ºä¾‹ï¼Œä»‹ç»äº†å¦‚ä½•ä½¿ç”¨ tracing å’Œ tracing-subscriber å®ç°æ—¥å¿—è®°å½•ã€‚ä»åŸºç¡€çš„æ§åˆ¶å°è¾“å‡ºå¼€å§‹ï¼Œé€æ­¥ä¼˜åŒ–ä»£ç ä»¥æ”¯æŒæ›´è¯¦ç»†çš„æ—¥å¿—ä¿¡æ¯ã€å¼‚æ­¥ä»»åŠ¡è€—æ—¶ç»Ÿè®¡ï¼Œæœ€ç»ˆå®ç°æ—¥å¿—æ–‡ä»¶æ»šåŠ¨ä¿å­˜ã€‚é€šè¿‡å››æ¬¡è¿­ä»£ï¼Œæˆ‘ä»¬å±•ç¤ºäº†å¦‚ä½•åœ¨å®é™…å¼€å‘ä¸­é…ç½®æ—¥å¿—çº§åˆ«ã€æ·»åŠ æ–‡ä»¶è¾“å‡ºå¹¶å®æ—¶æŸ¥çœ‹æ—¥å¿—ï¼Œé€‚åˆ Rust å¼€å‘è€…å‚è€ƒã€‚

## Rust æ—¥å¿—å¤„ç†

### æ—¥å¿—å¤„ç†ï¼š`tracing`ã€`tracing-subscriber`

- `tracing`ï¼šè®°å½•å„ç§æ—¥å¿—
- `tracing-subscriber`ï¼šè¾“å‡ºæ—¥å¿—
- `open-telemetry*`ï¼šå’Œ open-telemetry ç”Ÿæ€äº’åŠ¨
- å…»æˆè‰¯å¥½çš„ `tracing/metrics` ä¹ æƒ¯

## å®æ“

### é¡¹ç›®ç›®å½•ç»“æ„

```bash
rust-ecosystem-learning on î‚  main is ğŸ“¦ 0.1.0 via ğŸ¦€ 1.85.0 via ğŸ…’ base 
âœ tree . -L 6 -I 'target|coverage|coverage_report|docs'        


.
â”œâ”€â”€ CHANGELOG.md
â”œâ”€â”€ CONTRIBUTING.md
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ _typos.toml
â”œâ”€â”€ cliff.toml
â”œâ”€â”€ deny.toml
â”œâ”€â”€ examples
â”‚   â”œâ”€â”€ axum_tracing.rs
â”‚   â””â”€â”€ err.rs
â”œâ”€â”€ rust-toolchain.toml
â”œâ”€â”€ src
â”‚   â””â”€â”€ lib.rs
â””â”€â”€ test.http

3 directories, 14 files

```

### å®‰è£…ä¾èµ–

```bash
âœ cargo add axum --features http2 --features query --features tracing --dev       
âœ cargo add tokio --features rt --features rt-multi-thread --features macros --dev   
âœ cargo add tracing               
âœ cargo add tracing-subscriber --features env-filter 
âœ cargo add tracing-appender            
```

### `axum_tracing.rs` æ–‡ä»¶

```rust
use axum::{routing::get, Router};
use tokio::net::TcpListener;
use tracing::{info, instrument, level_filters::LevelFilter};
use tracing_subscriber::{
    fmt::{self, format::FmtSpan},
    layer::SubscriberExt,
    util::SubscriberInitExt,
    Layer,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let console = fmt::Layer::new()
        .with_span_events(FmtSpan::NEW | FmtSpan::CLOSE)
        .pretty()
        .with_filter(LevelFilter::INFO);
    tracing_subscriber::registry().with(console).init();

    let addr = "0.0.0.0:8080";
    let app = Router::new().route("/", get(index_handler));

    let listener = TcpListener::bind(addr).await?;
    info!("listening on {}", addr);
    axum::serve(listener, app.into_make_service()).await?;
    Ok(())
}

#[instrument]
async fn index_handler() -> &'static str {
    "Hello, world!"
}

```

### ç¬¬ä¸€æ¬¡è¿è¡Œ

```bash
cargo run --example axum_tracing

Finished `dev` profile [unoptimized + debuginfo] target(s) in 13.11s
    Running `target/debug/examples/axum_tracing`
2025-03-17T09:01:17.202968Z  INFO axum_tracing: listening on 0.0.0.0:8080
at examples/axum_tracing.rs:23

2025-03-17T09:13:39.480085Z  INFO axum_tracing: new
at examples/axum_tracing.rs:28
in axum_tracing::index_handler

2025-03-17T09:13:39.480445Z  INFO axum_tracing: close, time.busy: 5.67Âµs, time.idle: 368Âµs
at examples/axum_tracing.rs:28
in axum_tracing::index_handler

```

### Request å‘é€è¯·æ±‚

```http
### index handler
GET http://localhost:8080/ HTTP/1.1

```

### Response å“åº”

```bash
HTTP/1.1 200 OK
content-type: text/plain; charset=utf-8
content-length: 13
connection: close
date: Mon, 17 Mar 2025 09:13:39 GMT

Hello, world!
```

![axum_tracing](/images/axum_tracing_first_run.png)

### ä¼˜åŒ–ä¸€ `axum_tracing.rs` æ–‡ä»¶

```rust
use std::time::Duration;

use axum::{routing::get, Router};
use tokio::{net::TcpListener, time::sleep};
use tracing::{info, instrument, level_filters::LevelFilter, warn};
use tracing_subscriber::{
    fmt::{self, format::FmtSpan},
    layer::SubscriberExt,
    util::SubscriberInitExt,
    Layer,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let console = fmt::Layer::new()
        .with_span_events(FmtSpan::CLOSE)
        .pretty()
        .with_filter(LevelFilter::INFO);
    tracing_subscriber::registry().with(console).init();

    let addr = "0.0.0.0:8080";
    let app = Router::new().route("/", get(index_handler));

    let listener = TcpListener::bind(addr).await?;
    info!("listening on {}", addr);
    axum::serve(listener, app.into_make_service()).await?;
    Ok(())
}

#[instrument]
async fn index_handler() -> &'static str {
    sleep(Duration::from_millis(10)).await;
    let ret = long_task().await;
    info!(http.status = 200, "index handler completed");
    ret
}

#[instrument]
async fn long_task() -> &'static str {
    let dur = 112;
    sleep(Duration::from_millis(dur)).await;
    warn!(app.task_duration = dur, "long task done");
    "long task done"
}

```

### ç¬¬äºŒæ¬¡è¿è¡Œ

![axum_tracing](/images/axum_tracing_second_run.png)

### ä¼˜åŒ–äºŒ `axum_tracing.rs` æ–‡ä»¶

```rust
use std::time::Duration;

use axum::{routing::get, Router};
use tokio::{
    net::TcpListener,
    time::{sleep, Instant},
};
use tracing::{info, instrument, level_filters::LevelFilter, warn};
use tracing_subscriber::{
    fmt::{self, format::FmtSpan},
    layer::SubscriberExt,
    util::SubscriberInitExt,
    Layer,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let console = fmt::Layer::new()
        .with_span_events(FmtSpan::CLOSE)
        .pretty()
        .with_filter(LevelFilter::INFO);
    tracing_subscriber::registry().with(console).init();

    let addr = "0.0.0.0:8080";
    let app = Router::new().route("/", get(index_handler));

    let listener = TcpListener::bind(addr).await?;
    info!("listening on {}", addr);
    axum::serve(listener, app.into_make_service()).await?;
    Ok(())
}

#[instrument]
async fn index_handler() -> &'static str {
    sleep(Duration::from_millis(10)).await;
    let ret = long_task().await;
    info!(http.status = 200, "index handler completed");
    ret
}

#[instrument]
async fn long_task() -> &'static str {
    let start = Instant::now();
    sleep(Duration::from_millis(112)).await;
    let elapsed = start.elapsed().as_millis() as u64;
    warn!(app.task_duration = elapsed, "long task done");
    "long task done"
}

```

### ç¬¬ä¸‰æ¬¡è¿è¡Œ

![axum_tracing](/images/axum_tracing_third_run.png)

### åˆ›å»ºç›®å½•

```bash
âœ mkdir /tmp/logs        
```

### ä¼˜åŒ–ä¸‰ `axum_tracing.rs` æ–‡ä»¶

```rust
use std::time::Duration;

use axum::{routing::get, Router};
use tokio::{
    net::TcpListener,
    time::{sleep, Instant},
};
use tracing::{debug, info, instrument, level_filters::LevelFilter, warn};
use tracing_subscriber::{
    fmt::{self, format::FmtSpan},
    layer::SubscriberExt,
    util::SubscriberInitExt,
    Layer,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let file_appender = tracing_appender::rolling::daily("/tmp/logs", "ecosystem.log");
    let (non_blocking, _guard) = tracing_appender::non_blocking(file_appender);

    let console = fmt::Layer::new()
        .with_span_events(FmtSpan::CLOSE)
        .pretty()
        .with_filter(LevelFilter::DEBUG);

    let file = fmt::Layer::new()
        .with_span_events(FmtSpan::CLOSE)
        .with_writer(non_blocking)
        .with_filter(LevelFilter::INFO);

    tracing_subscriber::registry()
        .with(console)
        .with(file)
        .init();

    let addr = "0.0.0.0:8080";
    let app = Router::new().route("/", get(index_handler));

    let listener = TcpListener::bind(addr).await?;
    info!("listening on {}", addr);
    axum::serve(listener, app.into_make_service()).await?;
    Ok(())
}

#[instrument]
async fn index_handler() -> &'static str {
    debug!("index handler started");
    sleep(Duration::from_millis(10)).await;
    let ret = long_task().await;
    info!(http.status = 200, "index handler completed");
    ret
}

#[instrument]
async fn long_task() -> &'static str {
    let start = Instant::now();
    sleep(Duration::from_millis(112)).await;
    let elapsed = start.elapsed().as_millis() as u64;
    warn!(app.task_duration = elapsed, "long task done");
    "long task done"
}

```

### ç¬¬å››æ¬¡è¿è¡Œ

![axum_tracing](/images/axum_tracing_fourth_run.png)

### æŸ¥çœ‹æ—¥å¿—

![axum_tracing](/images/axum_tracing_fifth_run.png)

#### å®æ—¶æŸ¥çœ‹æ—¥å¿—

tail -f æ˜¯ä¸€ä¸ªåœ¨ Linux/Unix ç³»ç»Ÿä¸­å¸¸ç”¨çš„å‘½ä»¤ï¼Œç”¨äºå®æ—¶æŸ¥çœ‹æ–‡ä»¶çš„æœ«å°¾å†…å®¹ã€‚å®ƒå¯ä»¥åœ¨æ–‡ä»¶è¢«è¿½åŠ å†…å®¹æ—¶ï¼Œå®æ—¶æ˜¾ç¤ºè¿™äº›å†…å®¹ï¼Œè€Œä¸éœ€è¦é‡æ–°åŠ è½½æ•´ä¸ªæ–‡ä»¶ã€‚
![axum_tracing_sixth](/images/axum_tracing_sixth_run.png)

## æ€»ç»“

é€šè¿‡æœ¬æ–‡çš„å®æˆ˜æ¼”ç»ƒï¼Œæˆ‘ä»¬ä»ç®€å•çš„æ—¥å¿—è¾“å‡ºå¼€å§‹ï¼Œé€æ­¥ä¼˜åŒ–åˆ°æ”¯æŒè€—æ—¶ç»Ÿè®¡å’Œæ–‡ä»¶è®°å½•ï¼Œå±•ç¤ºäº† tracing ç”Ÿæ€çš„å¼ºå¤§åŠŸèƒ½ã€‚æ— è®ºæ˜¯è°ƒè¯•è¿˜æ˜¯ç”Ÿäº§ç¯å¢ƒï¼Œåˆç†é…ç½®æ—¥å¿—éƒ½èƒ½æå‡å¼€å‘æ•ˆç‡å’Œç³»ç»Ÿå¯è§‚æµ‹æ€§ã€‚å¸Œæœ›è¿™ç¯‡æ–‡ç« èƒ½ä¸ºä½ çš„ Rust é¡¹ç›®æä¾›å®ç”¨å‚è€ƒï¼ŒåŠ©ä½ åœ¨æ—¥å¿—å¤„ç†ä¸Šæ›´è¿›ä¸€æ­¥ï¼

## å‚è€ƒ

- <https://github.com/tokio-rs/tracing>
- <https://course.rs/logs/tracing.html>
- <https://crates.io/crates/tracing-subscriber>
- <https://docs.rs/tracing-subscriber/latest/tracing_subscriber/index.html>
- <https://docs.rs/tracing-subscriber/latest/tracing_subscriber/layer/index.html>
- <https://github.com/tokio-rs/tracing/tree/master/tracing-appender>

+++
title = "Solana å¼€å‘è¿›é˜¶ï¼šé“¾ä¸Šäº‹ä»¶åˆ°é“¾ä¸‹è§£æå…¨æ”»ç•¥"
description = "Solana å¼€å‘è¿›é˜¶ï¼šé“¾ä¸Šäº‹ä»¶åˆ°é“¾ä¸‹è§£æå…¨æ”»ç•¥"
date = 2025-06-16T01:03:33Z
[taxonomies]
categories = ["Web3", "Solana"]
tags = ["Web3", "Solana"]
+++

<!-- more -->

# Solana å¼€å‘è¿›é˜¶ï¼šé“¾ä¸Šäº‹ä»¶åˆ°é“¾ä¸‹è§£æå…¨æ”»ç•¥

åœ¨ä¹‹å‰æˆ‘ä»¬å·²ç»å†™äº†ä¸‰ç¯‡æ–‡ç« ã€Šæ¢ç´¢ Solana SDK å®æˆ˜ï¼šWeb3 å¼€å‘çš„åŒè·¯å¾„ä¸è½»é‡æ¨¡å—åŒ–ã€‹ã€ã€ŠSolana å¼€å‘å®æˆ˜ï¼šRust å®¢æˆ·ç«¯è°ƒç”¨é“¾ä¸Šç¨‹åºå…¨æµç¨‹ã€‹å’Œã€ŠSolana å¼€å‘è¿›é˜¶ï¼šåœ¨ Devnet ä¸Šå®ç°é“¾ä¸Šç¨‹åºéƒ¨ç½²ã€è°ƒç”¨ä¸æ›´æ–°ã€‹å®Œç¾å®ç°å¼€å‘ã€æµ‹è¯•ã€éƒ¨ç½²ã€å®¢æˆ·ç«¯è°ƒç”¨ã€æ›´æ–°å…¨æµç¨‹ã€‚Solana çš„é«˜æ€§èƒ½åŒºå—é“¾ä¸º Web3 å¼€å‘æ‰“å¼€äº†æ–°è§†é‡ï¼Œè€Œé“¾ä¸Šäº‹ä»¶æ˜¯å®ç°æ™ºèƒ½åˆçº¦ä¸é“¾ä¸‹äº¤äº’çš„å…³é”®æ¢çº½ã€‚æœ¬æ–‡å°†é€šè¿‡ Rust å®æˆ˜æ¡ˆä¾‹ï¼Œå¸¦ä½ æ·±å…¥æŒæ¡é“¾ä¸Šäº‹ä»¶å®šä¹‰ã€è§¦å‘åˆ°é“¾ä¸‹è§£æçš„å…¨æµç¨‹ï¼Œè§£é” Solana å¼€å‘è¿›é˜¶æŠ€èƒ½ï¼ŒåŠ©ä½ æ„å»ºæ›´é«˜æ•ˆçš„ Web3 åº”ç”¨ï¼

æœ¬æ–‡å»¶ç»­ Solana å¼€å‘ç³»åˆ—çš„å®æˆ˜é£æ ¼ï¼Œèšç„¦æ™ºèƒ½åˆçº¦äº‹ä»¶çš„å¼€å‘ä¸è§£æå…¨æµç¨‹ã€‚æˆ‘ä»¬é€šè¿‡ Rust å®ç°ä¸€ä¸ª Solana ç¨‹åºï¼Œå®šä¹‰å¹¶è§¦å‘ GreetingEvent äº‹ä»¶ï¼Œåˆ©ç”¨ JSON-RPC æ¥å£ä»åŒºå—æ•°æ®ä¸­æå–æ—¥å¿—å¹¶ååºåˆ—åŒ–äº‹ä»¶å†…å®¹ï¼Œå®Œæˆé“¾ä¸Šåˆ°é“¾ä¸‹çš„æ— ç¼è¡”æ¥ã€‚æ–‡ç« æ¶µç›– Borsh åºåˆ—åŒ–ã€æ—¥å¿—æå–ã€RPC é…ç½®ç­‰æ ¸å¿ƒæŠ€æœ¯ï¼Œé…ä»¥è¯¦ç»†ä»£ç è§£æå’Œè¿è¡Œç¤ºä¾‹ï¼Œä¸ºå¸Œæœ›æŒæ¡ Solana äº‹ä»¶æœºåˆ¶çš„å¼€å‘è€…æä¾›è¿›é˜¶æŒ‡å—ã€‚

## å®æˆ˜

### æŸ¥çœ‹é¡¹ç›®ç›®å½•

```bash
solana-sandbox/sol-program on î‚  main [!?] is ğŸ“¦ 0.1.0 via ğŸ¦€ 1.87.0 on ğŸ³ v28.2.2 (orbstack) took 4.0s 
âœ tree . -L 6 -I "coverage_report|lib|.vscode|out|test-ledger|target|node_modules"
.
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ examples
â”‚   â”œâ”€â”€ client.rs
â”‚   â””â”€â”€ event.rs
â”œâ”€â”€ keys
â”‚   â””â”€â”€ SSoyAkBN9E3CjbWpr2SdgLa6Ejbqqdvasuxd8j1YsmN.json
â””â”€â”€ src
    â”œâ”€â”€ lib.rs
    â””â”€â”€ lib2.rs

4 directories, 7 files
```

### åˆçº¦ç¨‹åº src/lib.rs æ–‡ä»¶

```rust
#![allow(unexpected_cfgs)]

use borsh_derive::{BorshDeserialize, BorshSerialize};
use solana_account_info::AccountInfo;
use solana_msg::msg;
use solana_program_entrypoint::entrypoint;
use solana_program_error::{ProgramError, ProgramResult};
use solana_pubkey::Pubkey;

// å®šä¹‰äº‹ä»¶ç»“æ„ä½“
#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub struct GreetingEvent {
    pub message: String, // Greeting message contained in the event
}

// è‡ªå®šä¹‰äº‹ä»¶è§¦å‘å‡½æ•°
fn emit_event(event: &GreetingEvent) -> ProgramResult {
    let event_data = borsh::to_vec(event).map_err(|_| ProgramError::Custom(1))?; // Serialize to byte array
    msg!("EVENT:GREETING:{:?}", event_data); // Output event log
    Ok(())
}

entrypoint!(process_instruction);

pub fn process_instruction(
    _program_id: &Pubkey,
    _accounts: &[AccountInfo],
    _instruction_data: &[u8],
) -> ProgramResult {
    msg!("Hello, Solana!");

    let event = GreetingEvent {
        message: "Hello from Solana program!".to_string(),
    };
    emit_event(&event)?;

    msg!("Program executed successfully with greeting event!");

    Ok(())
}

#[cfg(test)]
mod test {
    use solana_program_test::*;
    use solana_sdk::{
        instruction::Instruction, pubkey::Pubkey, signature::Signer, transaction::Transaction,
    };

    #[tokio::test]
    async fn test_sol_program() {
        // let program_id = Pubkey::from_str("GGBjDqYdicSE6Qmtu6SAsueX1biM5LjbJ8R8vZvFfofA").unwrap();
        let program_id = Pubkey::new_unique();
        let mut program_test = ProgramTest::default();
        program_test.add_program("sol_program", program_id, None);
        let mut context = program_test.start_with_context().await;
        let (banks_client, payer, recent_blockhash) = (
            &mut context.banks_client,
            &context.payer,
            context.last_blockhash,
        );
        // Create instruction
        let instruction = Instruction {
            program_id,
            accounts: vec![],
            data: vec![],
        };
        // Create transaction with instruction
        let mut transaction = Transaction::new_with_payer(&[instruction], Some(&payer.pubkey()));

        // Sign transaction
        transaction.sign(&[&payer], recent_blockhash);

        let transaction_result = banks_client
            .process_transaction_with_metadata(transaction)
            .await
            .expect("Failed to process transaction");

        assert!(transaction_result.result.is_ok());

        let logs = transaction_result.metadata.unwrap().log_messages;
        assert!(logs.iter().any(|log| log.contains("Hello, Solana!")));
        assert!(logs.iter().any(|log| log.contains("EVENT:GREETING:")));
    }
}

```

### è§£æåˆçº¦ç¨‹åºäº‹ä»¶ examples/event.rs æ–‡ä»¶

```rust
use anyhow::Result;
use anyhow::anyhow;
use borsh::{BorshDeserialize, BorshSerialize};
use serde_json::Value;
use std::error::Error;

// å®šä¹‰ä¸ç¨‹åºç›¸åŒçš„ GreetingEvent ç»“æ„ä½“
#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub struct GreetingEvent {
    pub message: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let client = reqwest::Client::builder().build()?;

    let mut headers = reqwest::header::HeaderMap::new();
    headers.insert("Content-Type", "application/json".parse()?);

    let data = r#"
    {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "getBlock",
        "params": [
            387787294,
            {
                "encoding": "jsonParsed",
                "maxSupportedTransactionVersion": 0,
                "transactionDetails": "full",
                "rewards": false
            }
        ]
    }
    "#;

    let json: Value = serde_json::from_str(&data)?;
    let request = client
        .request(
            reqwest::Method::POST,
            "https://docs-demo.solana-devnet.quiknode.pro/",
        )
        .headers(headers)
        .json(&json);

    let response = request.send().await?;
    let status = response.status();
    let response_text = response.text().await?;
    println!("Status: {}", status);
    let body: Value = serde_json::from_str(&response_text)?;

    let target_program_id = "GGBjDqYdicSE6Qmtu6SAsueX1biM5LjbJ8R8vZvFfofA";
    // æå– logMessages
    let log_messages = extract_log_messages(&body, target_program_id)?;

    // æ‰“å° logMessages
    println!("logMessages: {:#?}", log_messages);

    // è§£æ EVENT:GREETING æ—¥å¿—
    for log in &log_messages {
        if log.contains("EVENT:GREETING") {
            let event = parse_greeting_event(log)?;
            println!("Parsed GreetingEvent: {:?}", event);
        }
    }

    Ok(())
}

fn extract_log_messages(body: &Value, target_program_id: &str) -> Result<Vec<String>> {
    // è·å– transactions æ•°ç»„
    let transactions = body["result"]["transactions"]
        .as_array()
        .ok_or_else(|| anyhow!("ç»“æœä¸­æœªæ‰¾åˆ° transactions"))?;

    // éå†äº¤æ˜“ï¼Œæ‰¾åˆ°è°ƒç”¨ç›®æ ‡ç¨‹åºçš„äº¤æ˜“
    for tx in transactions {
        // æ£€æŸ¥æŒ‡ä»¤ä¸­æ˜¯å¦åŒ…å«ç›®æ ‡ programId
        let instructions = tx["transaction"]["message"]["instructions"]
            .as_array()
            .ok_or_else(|| anyhow!("äº¤æ˜“ä¸­æœªæ‰¾åˆ°æŒ‡ä»¤"))?;

        let has_target_program = instructions.iter().any(|instruction| {
            instruction["programId"]
                .as_str()
                .map_or(false, |pid| pid == target_program_id)
        });

        if has_target_program {
            // æå– logMessages
            let log_messages = tx["meta"]["logMessages"]
                .as_array()
                .ok_or_else(|| anyhow!("meta ä¸­æœªæ‰¾åˆ° logMessages"))?;
            // è¿‡æ»¤ä¸ç›®æ ‡ç¨‹åºç›¸å…³çš„æ—¥å¿—
            let filtered_logs: Vec<String> = log_messages
                .iter()
                .filter_map(|log| {
                    log.as_str()
                        .filter(|s| s.contains(target_program_id) || s.contains("Program log"))
                        .map(String::from)
                })
                .collect();

            if !filtered_logs.is_empty() {
                return Ok(filtered_logs);
            }
        }
    }

    Err(anyhow!("æœªæ‰¾åˆ°è°ƒç”¨ç¨‹åº {} çš„æ—¥å¿—", target_program_id))
}

fn parse_greeting_event(log: &str) -> Result<GreetingEvent> {
    // æå– [26, 0, 0, 4, ...] éƒ¨åˆ†
    let start = log
        .find('[')
        .ok_or_else(|| anyhow!("æ— æ•ˆçš„äº‹ä»¶æ—¥å¿—æ ¼å¼ï¼šæœªæ‰¾åˆ° '['"))?;
    let end = log
        .find(']')
        .ok_or_else(|| anyhow!("æ— æ•ˆçš„äº‹ä»¶æ—¥å¿—æ ¼å¼ï¼šæœªæ‰¾åˆ° ']'"))?;
    let bytes_str = &log[start + 1..end];

    // å°†å­—ç¬¦ä¸²ä¸­çš„æ•°å­—è½¬æ¢ä¸º Vec<u8>
    let bytes: Vec<u8> = bytes_str
        .split(',')
        .map(|s| s.trim())
        .filter(|s| !s.is_empty())
        .map(|s| s.parse::<u8>().map_err(|e| anyhow!("æ— æ³•è§£æå­—èŠ‚ï¼š{}", e)))
        .collect::<Result<Vec<u8>>>()?;

    // ä½¿ç”¨ Borsh è§£åºåˆ—åŒ–
    let event =
        GreetingEvent::try_from_slice(&bytes).map_err(|e| anyhow!("Borsh è§£åºåˆ—åŒ–å¤±è´¥ï¼š{}", e))?;

    Ok(event)
}

```

åœ¨ Solana å¼€å‘ä¸­ï¼Œç¨‹åºï¼ˆæ™ºèƒ½åˆçº¦ï¼‰å¯ä»¥é€šè¿‡æ—¥å¿—ï¼ˆlogï¼‰æ¥å‘å‡ºäº‹ä»¶ï¼ˆeventï¼‰ï¼Œè¿™äº›äº‹ä»¶ä¼šè¢«è®°å½•åœ¨äº¤æ˜“çš„å…ƒæ•°æ®ä¸­ã€‚æœ¬ç¤ºä¾‹æ¼”ç¤ºäº†å¦‚ä½•é€šè¿‡ RPC æ¥å£è·å–åŒºå—æ•°æ®ï¼Œå¹¶ä»ä¸­è§£æå‡ºç‰¹å®šç¨‹åºå‘å‡ºçš„äº‹ä»¶ã€‚

#### ä»£ç è§£æ

è¿™æ®µä»£ç ä¸»è¦å®Œæˆä»¥ä¸‹åŠŸèƒ½ï¼š

1. **ä¾èµ–å¼•å…¥**ï¼š

   - `anyhow` ç”¨äºç®€åŒ–é”™è¯¯å¤„ç†
   - `borsh` ç”¨äºåºåˆ—åŒ–å’Œååºåˆ—åŒ–äº‹ä»¶æ•°æ®
   - `serde_json` ç”¨äºå¤„ç† JSON æ•°æ®
   - `reqwest` ç”¨äºå‘é€ HTTP è¯·æ±‚

2. **äº‹ä»¶ç»“æ„ä½“å®šä¹‰**ï¼š

   ```
   #[derive(BorshDeserialize, BorshSerialize, Debug)]
   pub struct GreetingEvent {
       pub message: String,
   }
   ```

   å¿…é¡»ä¸åˆçº¦ç¨‹åºä¸­å®šä¹‰çš„äº‹ä»¶ç»“æ„ä½“å®Œå…¨ä¸€è‡´ï¼Œæ‰èƒ½æ­£ç¡®ååºåˆ—åŒ–ã€‚

3. **ä¸»æµç¨‹**ï¼š

   - æ„å»º HTTP å®¢æˆ·ç«¯å¹¶è®¾ç½®è¯·æ±‚å¤´
   - å‡†å¤‡ JSON-RPC è¯·æ±‚ä½“ï¼ŒæŸ¥è¯¢ç‰¹å®šåŒºå—çš„äº¤æ˜“æ•°æ®
   - å‘é€è¯·æ±‚å¹¶å¤„ç†å“åº”
   - ä»å“åº”ä¸­æå–ç›®æ ‡ç¨‹åºçš„æ—¥å¿—æ¶ˆæ¯
   - è§£æåŒ…å« `EVENT:GREETING` æ ‡è®°çš„æ—¥å¿—

4. **å…³é”®å‡½æ•°**ï¼š

   - `extract_log_messages`: ä»åŒºå—æ•°æ®ä¸­ç­›é€‰å‡ºç›®æ ‡ç¨‹åºçš„æ—¥å¿—
   - `parse_greeting_event`: è§£ææ—¥å¿—ä¸­çš„äº‹ä»¶æ•°æ®

#### å·¥ä½œåŸç†

1. åˆçº¦ç¨‹åºé€šè¿‡ `msg!` å®è¾“å‡ºç‰¹å®šæ ¼å¼çš„æ—¥å¿—ï¼ˆå¦‚ `EVENT:GREETING:[...]`ï¼‰
2. è¿™äº›æ—¥å¿—ä¼šè¢«è®°å½•åœ¨äº¤æ˜“çš„ `logMessages` å­—æ®µä¸­
3. å®¢æˆ·ç«¯é€šè¿‡ JSON-RPC æ¥å£è·å–åŒºå—æ•°æ®
4. ä»äº¤æ˜“å…ƒæ•°æ®ä¸­æå–æ—¥å¿—æ¶ˆæ¯
5. è§£ææ—¥å¿—ä¸­çš„å­—èŠ‚æ•°ç»„ï¼Œè¿˜åŸå‡ºåŸå§‹äº‹ä»¶å¯¹è±¡

#### æ³¨æ„äº‹é¡¹

1. äº‹ä»¶ç»“æ„ä½“å¿…é¡»ä½¿ç”¨ `Borsh` åºåˆ—åŒ–/ååºåˆ—åŒ–
2. æ—¥å¿—æ ¼å¼éœ€è¦çº¦å®šæ˜ç¡®çš„å‰ç¼€ï¼ˆå¦‚ `EVENT:GREETING:`ï¼‰
3. åŒºå—æŸ¥è¯¢éœ€è¦æ­£ç¡®çš„ RPC èŠ‚ç‚¹å’Œå‚æ•°é…ç½®
4. ç¨‹åº ID éœ€è¦æ›¿æ¢ä¸ºå®é™…éƒ¨ç½²çš„åˆçº¦åœ°å€

### è¿è¡Œ

```bash
solana-sandbox/sol-program on î‚  main [!?] is ğŸ“¦ 0.1.0 via ğŸ¦€ 1.87.0 on ğŸ³ v28.2.2 (orbstack) took 3.7s 
âœ cargo run --example event
warning: the cargo feature `edition2024` has been stabilized in the 1.85 release and is no longer necessary to be listed in the manifest
  See https://doc.rust-lang.org/cargo/reference/manifest.html#the-edition-field for more information about using this feature.
   Compiling sol-program v0.1.0 (/Users/qiaopengjun/Code/Solana/solana-sandbox/sol-program)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.88s
     Running `target/debug/examples/event`
Status: 200 OK
logMessages: [
    "Program GGBjDqYdicSE6Qmtu6SAsueX1biM5LjbJ8R8vZvFfofA invoke [1]",
    "Program log: Hello, Solana!",
    "Program log: EVENT:GREETING:[26, 0, 0, 0, 72, 101, 108, 108, 111, 32, 102, 114, 111, 109, 32, 83, 111, 108, 97, 110, 97, 32, 112, 114, 111, 103, 114, 97, 109, 33]",
    "Program log: Program executed successfully with greeting event!",
    "Program GGBjDqYdicSE6Qmtu6SAsueX1biM5LjbJ8R8vZvFfofA consumed 7280 of 200000 compute units",
    "Program GGBjDqYdicSE6Qmtu6SAsueX1biM5LjbJ8R8vZvFfofA success",
]
Parsed GreetingEvent: GreetingEvent { message: "Hello from Solana program!" }

solana-sandbox/sol-program on î‚  main [!?] is ğŸ“¦ 0.1.0 via ğŸ¦€ 1.87.0 on ğŸ³ v28.2.2 (orbstack) took 4.3s 
âœ cargo run --example event
warning: the cargo feature `edition2024` has been stabilized in the 1.85 release and is no longer necessary to be listed in the manifest
  See https://doc.rust-lang.org/cargo/reference/manifest.html#the-edition-field for more information about using this feature.
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.01s
     Running `target/debug/examples/event`
Status: 200 OK
logMessages: [
    "Program GGBjDqYdicSE6Qmtu6SAsueX1biM5LjbJ8R8vZvFfofA invoke [1]",
    "Program log: Hello, Solana!",
    "Program log: EVENT:GREETING:[26, 0, 0, 0, 72, 101, 108, 108, 111, 32, 102, 114, 111, 109, 32, 83, 111, 108, 97, 110, 97, 32, 112, 114, 111, 103, 114, 97, 109, 33]",
    "Program log: Program executed successfully with greeting event!",
    "Program GGBjDqYdicSE6Qmtu6SAsueX1biM5LjbJ8R8vZvFfofA consumed 7280 of 200000 compute units",
    "Program GGBjDqYdicSE6Qmtu6SAsueX1biM5LjbJ8R8vZvFfofA success",
]
Parsed GreetingEvent: GreetingEvent { message: "Hello from Solana program!" }
```

æˆåŠŸè§£æé“¾ä¸Šäº‹ä»¶ï¼Œè¾“å‡ºâ€œHello from Solana program!â€ï¼

## æ€»ç»“

æœ¬æ¬¡å®æˆ˜å®Œæ•´å‘ˆç°äº† Solana æ™ºèƒ½åˆçº¦äº‹ä»¶ä»é“¾ä¸Šå®šä¹‰åˆ°é“¾ä¸‹è§£æçš„å…¨æ”»ç•¥ã€‚æˆ‘ä»¬é€šè¿‡ Rust å®šä¹‰ GreetingEventã€åˆ©ç”¨ msg! è§¦å‘æ—¥å¿—ï¼Œå†é€šè¿‡ JSON-RPC æ¥å£æå–å’Œååºåˆ—åŒ–äº‹ä»¶æ•°æ®ï¼Œå±•ç¤ºäº†é“¾ä¸Šé“¾ä¸‹äº¤äº’çš„è¿›é˜¶æŠ€æœ¯ã€‚å¼€å‘è€…éœ€æ³¨æ„äº‹ä»¶ç»“æ„ä½“ä¸€è‡´æ€§ã€æ—¥å¿—æ ¼å¼è§„èŒƒå’Œ RPC é…ç½®çš„å‡†ç¡®æ€§ã€‚ç»“åˆç³»åˆ—å‰æ–‡çš„å¼€å‘ã€éƒ¨ç½²ä¸è°ƒç”¨ç»éªŒï¼Œæœ¬æ–‡è¿›ä¸€æ­¥ä¸°å¯Œäº†ä½ çš„ Solana å¼€å‘æŠ€èƒ½ï¼ç»§ç»­å…³æ³¨æˆ‘ä»¬çš„ Solana å¼€å‘ç³»åˆ—ï¼Œæ¢ç´¢æ›´å¤š Web3 å®æˆ˜æŠ€å·§ï¼

## å‚è€ƒ

- <https://explorer.solana.com/tx/4DFyj2xgVddy4inaaSbCJ6UeVMSM3u65LavC6tjVSsaw3A8PWLMz6jnuJ39o3A6WHhJV36UF5rYcVhnbgrkwEcqv?cluster=devnet&customUrl=http%3A%2F%2F127.0.0.1%3A8899>

- <https://solscan.io/tx/4DFyj2xgVddy4inaaSbCJ6UeVMSM3u65LavC6tjVSsaw3A8PWLMz6jnuJ39o3A6WHhJV36UF5rYcVhnbgrkwEcqv?cluster=devnet>
- <https://solana.com/zh/docs/programs/rust#%E6%9B%B4%E6%96%B0%E7%A8%8B%E5%BA%8F>
- <https://github.com/solana-program/token/blob/main/program/src/state.rs>

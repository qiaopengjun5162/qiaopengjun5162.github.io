+++
title = "Starknet 深度解析：Cairo 编程与区块链技术"
description = "Starknet 深度解析：Cairo 编程与区块链技术"
date = 2025-01-14 13:02:04+08:00
[taxonomies]
categories = ["Web3", "Starknet", "Cairo"]
tags = ["Web3", "Starknet", "Cairo"]
+++

<!-- more -->

# Starknet 深度解析：Cairo 编程与区块链技术

随着区块链技术的不断发展，Starknet 作为一个基于零知识证明的二层扩展方案，正在逐渐受到开发者和区块链爱好者的关注。本文将系统地介绍 Starknet 的基础知识、其架构优势以及为何开发者应当选择 Cairo 作为智能合约的编程语言，并对比它与以太坊等其他区块链技术的差异。通过深入了解 Starknet 的运作机制和性能特点，帮助读者更好地掌握这一前沿技术。

本文深入探讨了 Starknet 这一新兴区块链技术的核心概念，包括其背后的技术基础 Cairo 语言的设计理念与应用场景。Starknet 利用零知识证明（ZK）技术提供高效的二层扩展解决方案，并与传统的以太坊进行对比，展示了其在性能和成本上的优势。文章还介绍了 Starknet 在智能合约编程、事务执行和验证方面的独特优势，并探讨了其相较于 EVM 兼容链的优越性。通过详细分析，本文为想要深入了解 Starknet 的开发者提供了宝贵的技术洞察。

## 了解 `Starknet` 基础知识

### 主题

1. 为什么选择 `Cairo`
2. 为什么选择 `Starknet`
3. 智能钱包
4. `Starknet` 架构 101
5. `Transactions`

### `Starknet` 相关名称的了解与区分

`STARKWARE`   ：是位于以色列的公司，开发了 `Starknet`，包括 `Starknet` 相关的技术，目前负责构建和发展， `Starknet` 的核心团队是 `Starkware` 的员工。 `Starkware`  的创始人及现任的CEO 发明了 `Starks ZK`

的证明，这种证明推动了所有这些创新。 `STARKWARE` 做的第一个 `ZKSTARKS` 的实现被称为 `STARKEx`，`STARKEx` 是一个需要授权的系统，所以你不能直接使用`STARKEx`，你需要与 `STARKWARE` 签订合同协议才能使用它。`STARKEx` 有一些固定的功能，比如说你可以交易代币，做期货合约、资产交易等待。例如：`DYDXVERSION3` 实际就是运行在 `STARKEx` 上的。许多应用程序幕后都是使用的是`STARKEx`。 这是 `STARKWARE` 开发的第一个产品。

实际上`Cairo` 就是为 `STARKEx` 开发的。最初是作为一种内部工具，以便更容易提高系统的能力，一段时间以后，它们希望创建一种系统，使用相同的技术、相同类型的零知识证明，使得人们可以自己使用 `Cairo` 创建智能合约，并随时部署它们，无须任何许可。这就是 `STARKNET`。因此 `STARKNET`是一个无需许可的系统。是一个二层汇总。使用以太坊作为安全层，你可以通过智能合约部署你的代码逻辑，无需得到 `STARKWARE` 的任何许可。

`STARKNET Foundation` ：  `STARKNET` 基金会是成立大约一年的一个非营利组织。目标是帮助发展 `STARKNET` 生态系统，或者与一些开发者达成协议来创建一些应用，或者帮助分散系统的治理。

### 为什么选择 `Cairo`

为什么要开发另一个编程语言而不是直接使用以太坊，首先`Cairo` 是一种通用的编程语言，我们可以通过一个例子来解释 为什么选择 `Cairo`：

这个例子是一个太空探索问题。

如何节省燃料

最佳发射窗口

最佳发射轨迹

工程师写算法

假设你是一个国家的航空航天探索机构的负责人，你的目标是将航天器送到火星，所以你需要尽可能的节省燃料，使火箭尽可能小，尽可能便宜找到这个火箭发射的最佳轨道。那你需要计算这些变量，这些变量的计算是非常复杂的，你的工程团队可能要选择一些高性能的语言，比如Rust来创建一个程序并找到这个变量的值，这个程序太复杂，你需要一台超级计算机来运行这个程序，在合理的时间内得到结果，否则在普通的电脑上可能需要很长时间。而问题是你的机构甚至你的国家都没有超级计算机，唯一的办法是让一个竞争的国家同意让你使用他们的超级计算机来运行你的程序。因为这是一个竞争国家，但是你又没有其它选择，所以你也只能选择合作。你把代码给他们，让他们运行，得到结果以后再给你，当你拿到结果以后，你会遇到一个问题，你怎么知道这个竞争国家的超级计算机，在运行你的程序时没有出现故障，你怎么知道竞争国家或机构没有篡改结果。即使是一个小的改变，都可能让整个航天探索技术脱轨。你不能信任这些结果，不知道它们是否被正确执行，唯一知道结果是否正确的方法是，请求另一拥有超级计算机的国家来运行这个程序，并比较结果，多次这样做以后，来避免串通。如果足够多的超级计算机给出相同的结果。你才能够信任它，但是这样非常低效，而且也非常昂贵。

与竞争国家合作

执行算法程序需要超级计算机

但是只有竞争国家有

如果你的工程是不是使用其他编程语言，而是是`Cairo`。当你把你的程序交给竞争国家执行时，他们将不得不在`Cairo` 的虚拟机上运行代码。并且会像之前一样给到你执行的结果。现在他们还会给你一个执行后的加密证明。你可以在自己的电脑上去验证这个加密证明。如果证明有效，你几乎可以百分百确定没有人篡改过执行结果。系统也没有故障，因为如果有故障的话，证明将无效。竞争的国家无法伪造一个假的证明来欺骗你，接受错误的结果。换句话说，现在你又拥有了一种超能力，即你可以用普通电脑、笔记本甚至智能手机来验证超级计算机的同时性，如果它们作弊，你会立刻知道。只有像`Cairo`这样的语言才能实现。这也是目前唯一具备这种特性的高级语言。

执行   竞争国家   结果 + 证明

#### `Cairo` 特征

- 创建可证明的程序   计算的完整性
- 在 `CairoVM` 上运行
- 类似 `Rust` 的语法
- 相似的所有权模型
- 强类型 `traits macros`
- 不专为智能合约设计
- 不需要了解 `ZK`
- 强类型的语言
- 通用语言
- 目前的主要用例是为 `STARKNET` 创建智能合约
- 利用了零知识证明

#### 如何利用机构体创建自己自定义的数据类型

```rust
// 这个 trait 只定义了两个方法， 方法只定义了签名 没有定义实现
// rust 当中不需要定义 self 的类型 这里使用 T 通用类型
// cairo 借用了很多 Rust 的东西，但它并不是完全一样的，所以有一些不同的点需要注意
pub trait ShapeGeometry<T> {
  fn boundary(self: T) -> u64;
  fn area(self: T) -> u64;
}

mod rectangle {
  use super::ShapeGeometry;
  
  #[derive(Copy, Drop)]
  pub struct Rectangle {
    pub heigth: u64,
    pub width: u64,
  }
  
  // Rust 使用的是 for 而 cairo 使用的 of
  impl RectangleGeometry of ShapeGeometry<Rectangle> {
    fn boundary(self: Rectangle) -> u64 {
      2 * (self.height + self.width)
    }
    
    fn area(self: Rectangle) -> u64 {
      self.height * self.width
    }
  }
}
```

Cairo  就是一种高级语言、强类型、非常灵活、非常类似于 Rust，但是并不完全相同

#### Cairo  在 `Starknet` 智能合约中怎么写？

- 需要定义一个模块 mod
- 需要使用属性 `#[starknet::contract]`
- 这种编程类型被称为元编程
- 属性是宏
- 宏的作用是消耗你在宏下定义的代码，并转换为其它代码
- 在这种情况下，转化是将模块转换为智能合约，所以这就是所谓的元编程
- 元编程在Rust当中流行起来、同样也在 cairo 中使用，只是使用了不同的宏或属性
- 当我们想要定义合约的存储时，实际上是定义了一个结构体，这个结构体必须叫 `Storage`
- 这个存储必须使用属性   `#[storage]` 来注解
- 在 trait 中必须为 self 定义类型

```rust
#[starknet::interface]
trait ISimpleStorage<TContractState> {
  // 当你有一个方法实际上想修改智能合约内部状态时，你需要传递智能合约的状态，self 参数作为引用 ref
  fn set(ref self: TContractState, x: u128);
  // 如果从状态中只读而不修改 可以请求状态作为快照作为传递  快照使用 @ 符号
  fn get(self: @TContractState) -> u128;
}

#[starknet::contract]
mod SimpleStorage {
  #[storage]
  struct Storage {
    stored_data: u128
  }
  
  // 以下实现将成为智能合约的 ABI ，所以这是任何人都可以调用的智能合约的公共接口
  #[abi(embed_v0)]
  impl SimpleStorage of super::ISimpleStorage<ContractState> {
    fn set(ref self: ContractState, x: u128) {
      self.stored_data.write(x);
    }
    
    fn get(self: @ContractState) -> u128 {
      self.stored_data.read()
    }
  }
}
```

这是一个非常简单的示例，说明了如何从智能合约中读取和写入，并定义了智能合约的公共接口。

#### 总结 - 为什么选择 `Cairo`

- 创建可证明的程序
- 计算完成性证明
- 可验证
- 强大且灵活的语言
- 拒绝欺骗

使用 `Cairo` 可以在不重新执行的情况下，验证结果是否正确

`Cairo` 是一种强大且灵活的语言，部分原因是它是一种高级语言，抽象了所有ZK 的复杂性，并借用了许多Rust的语法，它防止了作弊，它通过ZK 证明保证超级计算机的结果不被篡改。这就是我们在 `Starknet` 上实现扩展的方式。

### 为什么选择 `Starknet`

L1 的扩展问题  当前以太坊的工作方式

在以太坊中有一台机器被随机选中，生成一个新块

生成块的所有者也被称为见证者

块生成者会收集交易创建这个块并告诉全世界，如果执行这个块中的所有交易，最终会得到以太坊网络新的全局状态。为了简单，假设这个新的块的状态的值是 42，块的生成者会告诉全世界这个新状态，当然在以太坊情况下，其他验证者是不会轻易相信块生成者的结果，其它验证者拿到块生成者创建的块，他们会执行其中的所有交易，并验证是否得到相同的最终状态。这是验证者保证生成者诚实的一种方式，也是系统保证状态的安全的一部分。因为所有机器都会独立的进行相同的工作，以验证结果是否一致。这是非常健壮的共识过程，确保只要至少一半的网络是诚实的，就能防止任何人作弊，缺点是效率非常低下。因为即使是一个包含少量交易的简单的块，也需要全球成千上万太机器独立重新执行，来比较结果。因此可以看到这种方式虽然健壮，但效率低下。

在 `Starknet` 中当提一个新块时，这个块不是为 L1 准备的，而是为 L2 准备的。它会创建块并执行交易，同时宣布新的状态为 42 ，但它会同时提供这个执行的加密证明。因为它的底层使用了 `Cairo`。因此以太坊上的验证者不需要重新执行块中的所有交易，来验证这个 42 是最终状态。他们只需要验证 ZK 证明即可。如果证明有效，他们就能够确定新状态是 42 号。因此以太坊上的所有验证者只需要验证证明，这种验证只需要花费重新执行所有交易的一小部分算力。

可以看到，当你从整体系统来看，性能得到了很大的提升。当然这里有一个小小的代价，因为 `Starknet` 不仅要执行交易，而且还要创建相关的加密证明，这需要额外的算力。但是你只需要执行一次就可以在任何地方验证。而不是在每个地方都需要重新执行。

这就是我们能够依赖以太坊在相同的级别下处理更多交易的方式。

成本更低，因为大部分工作在 `Starknet` 上一台计算机就可以完成，而以太坊网络的成本只是其中的很小的一部分。

执行和验证

验证和执行我们进行比较一下，验证比执行更便宜。但到底有多便宜呢？

假设 x 是 Sequencer，也就是 `Starknet` 中的排序器。

`Sequencer` 执行一个交易或所有区块中的交易

x 是这些所有这些交易所需要的步骤的数量级

以太坊验证者确认这个新状态的步骤需要 `log²(x)`

`x` 是 `Sequencer` 的工作量

在以太坊上工作量只是一个对数级别

`Sstarknet` 上区块越大、执行的交易越多，`log²(x)` 的增长速度是远低于实际这个基数计算的。

所以差距会越来越大，性能收益会越来越多，同时保持相同的安全级别。

有效性证明对计算来说，类似于 zip 算法对文件大小的作用是一样的，同样都属于一种压缩类型。

有效性证明创建了计算的压缩

Zip 创建了文件大小的压缩

![image-20240719210833799](/images/image-20240719210833799.png)

#### 有效性证明

什么是 `Starknet` 使用的有效性证明

它是零知识证明的一个用例

你可以使用 ZK 证明来实现隐私保护或者用它来作为扩展

我只需要发送有效性证明，不需要发送在 L2 上发生的所有交易的细节和详细信息，来进行在 L1 上的验证。

因此我们发送到 L1 上的数据量要比乐观汇总小很多。

乐观汇总实际上需要发送所有 L2 上发生的交易细节，这就是为什么乐观汇总在性能上很难与 `Starknet` 这样的 ZK 汇总竞争。

因为从定义上讲，它们必须发送所有这些交易细节给外部实体以确保没有人作弊，并且允许大家提交其它证明，我们不需要分享 L2 上的交易细节，或者说它们不是验证加密证明所必须的。

这并不意味着`STARKNET` 上的交易是私密的

`STARKNET` 上现在并不是为了隐私而构建的，它只是为了扩展

所以一些细节实际上是会泄露，但并不需要介意，因为`STARKNET` 上不是为了隐私而是为了性能，并且这样做会使验证非常高效、非常简洁

因为我们在系统中使用有效性证明，我们更倾向于把它称为有效性汇总（ZK 汇总）

基于 `STARKs` 非 `SNARKs`

|                | STARK     | SNARK     |
| -------------- | --------- | --------- |
| Verification   | `log²(n)` | constant  |
| Proof Size     | ~ 400 KB  | 288 bytes |
| Proving Time   | 1x        | 10x       |
| Trusted Setup  | No        | Yes       |
| Quantum Secure | Yes       | No        |

基于 `SNARKs` 的系统是需要可信设置的（安全秘钥）

`STARKs`  是量子安全的

#### 为什么不使用 EVM

Compatibility    Performance

`Cairo` 虚拟机

牺牲兼容性

获得最大的性能

你不能在 `Starknet` 上部署一个 `solidity` 智能合约

你必须重写代码逻辑

然后转换为 `Cairo` 并使用它

`ZKEVM` 为了实现兼容性，中间有很多转换和摩擦，最终会成为性能的瓶颈

#### V 神的 zk-EVM 分类

[![zk-EVM ](/images/chart.png "Shiprock")](https://markdown.com.cn)

<https://vitalik.eth.limo/general/2022/08/29/zkevm_zhTW.html>

|        | EVM Changes                | Compatibility | Performance | Projects                                |
| ------ | -------------------------- | ------------- | ----------- | --------------------------------------- |
| Type 1 | Nothing                    | Full          | Very Slow   | -                                       |
| Type 2 | Storage data structure     | High          | Slow        | -                                       |
| Type 3 | Storage hashes precompiles | Partial       | Fast        | Kakarot, zkSync, Scroll, Polygon, zkEVM |
| Type 4 | Completely different VM    | None          | Very Fast   | Starknet, Aztec*, Polygon Miden         |

#### L1 最终确认

以太坊的最终确认大约是每6分钟实现一次

在乐观汇总中，从 L2 提取资金到 L1，大约需要一周的时间

在 `Starknet` 的情况下，这个等待时间只有2个小时

每2个小时就从 `Starknet` 发送有效性证明到 L1

一旦证明被验证，你就可以讲资金转移到 L1

L2 的最终确认也就是 `Starknet` 的最终确认非常短

目前大约三秒钟，因此确认交易的速度非常快

只有在你想要将资产取回到 L1 时，才需要等待两个小时

与乐观汇总相比，在这方面是一个很大的优势

关于 `Starknet` 的性能的统计

`Starkscan.co`

![image-20240719223240346](/images/image-20240719223240346.png)

`Starknet` 的TPS 峰值是每秒大约52笔交易

看起来不算多，但在`Starknet` 上每笔交易实际上是多个交易捆绑在一起的

所以更好的比较是使用 PS，也就是每秒用户操作数

![image-20240719224223390](/images/image-20240719224223390.png)

#### 总结 - 为什么选择 `Starknet`

- 低 gas fee
- 以太坊作为安全保障
- 强大的编程语言
- 在以太坊上确认时间更短
- 不需要信任设置
- 更多的计算能力，零知识证明技术

### 智能钱包

<https://docs.starknet.io/quick-start/deploy-interact-with-a-smart-contract-remix/>

#### 什么是智能钱包

![image-20240720104748476](/images/image-20240720104748476.png)

- 可以使用 TouchID 或 FaceID 签名
- 在一个 tx 中执行多个操作
- SN 中所有钱包都是智能钱包
- 没有 EOAs
- 使用账户抽象构建
- 提供商：`Argent` 和 `Braavos`

![image-20240720104648008](/images/image-20240720104648008.png)

- 智能钱包与普通的区块链钱包不同，它允许你使用更多功能
- 例如你可以使用 TouchID 或 FaceID 签署交易，这提供了更改的安全性
- 你可以在单笔交易中执行多个操作
- 比如如果你使用`Starknet` 上的一个DeFi项目，你可以在一次点击 Swap，而无需逐步进行批准和交易，它在单笔交易中就完成了所有操作，你只需要签署一次交易就可以了。
- 还可以支持paymaster，这一切都归功于账户抽象，账号抽象使得智能钱包成为可能
- 在`Starknet` 上每个钱包都是智能钱包，这个是与以太坊完全不同的
- 在以太坊上你有外部账户EOA以及智能合约钱包
- 在`Starknet` 上所有的钱包都是基于账户抽象，都是智能钱包，是没有EOA钱包的概念的
- 这使得在生态系统中所有的应用程序可以实现更好的用户体验
- 因为在以太坊中，有些应用程序它是不支持智能钱包直接调用的

#### 复杂的交互

DeFi 的 Swap

一次 Swap 要分别进行批准和交易，这是在以太坊上常见的交易方式

这两笔交易实际上只是一个单个过程的两个步骤

在以太坊上由于你签署了两笔交易，你可能会认为他们会安装你定义的顺序，会被包含在同一个区块中。但实际上并非如此，你无法控制这些交易被包含在区块中的顺序，可能会发生以下情况：

- 第一步的交易和第二步的交易在同一个区块中
- 但中间可能会插入其他的交易
- 或者它们实际上被包含在不同的区块中
- 有人可能会在你和交易中间插入一笔交易，可能对你有害，例如闪电机器人这种协议，因为交易顺序的不确定，所以为这种攻击打开了大门
- 但是在 `Starknet` 上你可以在单笔交易中包含多个用户操作，我们称之为捆绑。这样就可以确保这些交易，首先会被包含在同一个区块中，并且按照你定义的顺序执行，不会有其他交易插入其中，因此你可以防止某些类型的攻击，例如三明治攻击。
- 尽管目前我们还无法防止抢先交易，但是这种情况目前不会发生，因为我们目前只有一个 `STARKWARE` 控制的序列器。也就是排序器 `Sequencer` 。
- 一旦未来我们完成去中心化，抢先交易将会成为可能，但是不会有交易可以插入中间，也就是不会受到三明治攻击
- 你可以确保这些操作按顺序执行，并且只需要签署一次交易，这在可用性上是一个巨大的胜利

#### 账户抽象

签名者

- 对交易签名的设备

账户

- SN 上的智能合约
- 持有资产
- 验证签名
- 执行 txs

账户抽象是智能钱包的基础

账户抽象实际上是将签署者与账户分离

签署者是签署交易的设备，可以是你的手机或者笔记本电脑

在 `Starknet` 上私钥通常可以存储在系统的安全区

账户是在`Starknet` 上的一个智能合约，它持有资产’、验证签名、负责执行多重调用

每个  `Starknet` 账户都有一个与之关联的智能合约，只是响应你的签署者

因此只有你的签署者可以发起交易，因为账户具有验证交易签名的逻辑，只允许你的设备发送交易

如果你在手机上安装了钱包，例如`Argent` 或 `Braavos`，你的手机就是签署者

当你想在 `Starknet` 上执行交易时， 你的签署者会将交易发送到你的智能合约，账户合约将验证签名，如果有效，就会执行交易，调用目标合约，实际上是你的账户合约在调用目标合约，只是响应签署者的请求，签名验证是可以编程的，所以你可以进行更高级的操作。

#### 签名验证

允许多种签名逻辑

- 单签
- 多签
- 硬件签名
- 恢复
- Session Keys

支持的 Elliptic Curves

- `STARK-friendly(native)`
- `Secp256k1(Ethereum)`
- `Secp256r1(standard)`

例如你可以有一个单一的签署者，默认情况下是`Argent` 和 `Braavos`钱包使用这种方式。

你也可以有多个签署者，类似于多重签名，但更像原生的多重签名，由所有应用程序支持。

相比之下，在以太坊上当你使用多重签名时，一些应用程序不支持通过多重签名钱包进行交易

账户合约或基于智能合约的钱包，在以太坊生态系统中是二等公民

而在 `Starknet` 上它们都是同类型的钱包，只是配置不同，所以它们都是一等公民

你可以做一些更高级的事情，比兔硬件签署，使用你的 Face ID 或者 Touch ID，利用手机或笔记本电脑的安全系统，你还可以进行一些恢复。

如果你丢失了钱包的访问权限，可以定义朋友或家人来帮助你恢复秘钥，通过某种离线的验证，你还可以有会话秘钥。

“会话密钥”是一个常见的术语，在加密和安全领域中广泛使用。它指的是在通信会话期间使用的临时密钥，用于加密和解密信息，以确保数据的保密性和完整性。会话密钥通常是在通信双方建立连接时生成的，并在会话结束后被丢弃。

在离线验证的上下文中，会话密钥可以用于对数据进行加密或签名，然后在不需要实时在线的情况下验证数据的真实性或完整性。这种方法可以提高安全性，因为即使攻击者获取了加密的数据，由于会话密钥是临时的，他们也无法解密数据或伪造消息。

会话秘钥就是`session keys`，它对游戏是非常有用的。这样你就不必每次操作都需要去签署交易。只需要为游戏客户端提供一个具有有限权限的秘钥为你自动签署交易。

所谓有限权限指的是包括时间和资产都是有限的。

你还可以支持多种类型的椭圆曲线，可以让你在签名是有更多的灵活性

#### AA + Secure Enclave

当你将账户抽象与手机安全结合使用时，它会将你的智能手机变成几乎像硬件钱包一样的东西。

如果你查看任何智能手机实际上是有两个系统，一个是所有应用程序共享的系统，我们称为 `Shared System`，共享内存以及CPU；另一个是更小的系统称为安全区（`Secure Enclave`），不同的供应商有不同的名称。

主要用于随机数生成、加密秘钥管理、硬件签名，这是Touch ID 或 Face ID 使用的系统。因此它有一个专门的处理器和内存，只用于这些高安全性的加密操作。

通过账户抽象，你实际上可以访问这个系统来进行交易签名。

在以太坊上，钱包只能使用共享系统。这主要是由于以太坊支持的椭圆曲线、签名的类型与硬件行业支持的标准不一致。

`Secure Enclave` 中 这种特定的曲线被称为 `Secp256r1`

对安全区的名称：

- 苹果称为 `Secure Enclave`

- 谷歌称为 `Titan M`
- 三星称为 `Knox`
- Arm  称为 `TrustZone`

#### 总结 - 智能钱包

- 更好的 UX
- 签名者和账户解耦
- 多种签名方式

智能钱包的好处在于你获得了比普通钱包更好的用户体验，可以进行多次调用硬件签署来恢复会话秘钥。所有这些都是由账户抽象实现的。即将签署者与账户分离。

账户是一个具有特定接口的智能合约。

因此每次创建账户时，你都有签署者和 `Starknet` 上的账户合约。

它支持使用不同的椭圆曲线进行签名

在 `Starknet` 上每个钱包都是智能钱包，没有外部账户（EOA）

### `Starknet` 架构 101

#### Cairo ->  有效性证明

![image-20240720121510685](/images/image-20240720121510685.png)

`Cairo` 是一种可证明的编程语言，它的语法类似于Rust。`Cairo` 不直接编译为 `Cairo AM` 字节码

这个编译过程是由排序器 `Sequencer` 完成的

`Sierra` 确保即使交易失败，它也会以一种与可证明系统兼容的方式失败，如果不这样做会有一个拒绝服务的漏洞。

`Sierra`  允许 `Cairo VM` 和 字节码独立于 `Cairo` 语言本身的演变

因此我们可以对两端进行修改、而不必修改整个系统

证明者会输出有效性证明和计算结果

排序器作为 `Starknet` 中的一个节点

- `Cairo Program`
- Compile  `Sierra`
- Send `Sequencer`
- `Sequencer` compile `CASM` (`Sierra`)
- Run `Cairo VM`
- `Prover` (`SHARP`)  RUN  `trace`
- `validity proof` 作为一个交易发送到 以太坊 `Ethereum` 进行 `Verifier`
- `result`

#### 使用智能合约

在执行前必须：

- 声明
- 部署

用户用 txs 和 SN 交互

`txs` 必须签名

![image-20240720124404416](/images/image-20240720124404416.png)

怎么知道排序器编译的版本真的就是你的程序编译后的版本呢？

也就是说，`Sequencer` 排序器可能会作弊

如何在没有证明的情况下检测到这种情况？

因为目前 `Cairo` 的编译器不是用 `Cairo` 编写的，是用 Rust写的。

编译不能被证明这个问题？解决方案：

长期方案是用 `Cairo` 编写一个 `Cairo` 编译器，这样编译就可以被证明

现在是当你声明一个智能合约时，你必须提供`Cairo` 汇编后的哈希值

![image-20240720125456950](/images/image-20240720125456950.png)

#### 声明 VS 部署

声明和部署是`Starknet` 上两个不同的操作

声明智能合约只是在 `Starknet` 上注册代码

新的代码只需要声明一次

如果代码已经声明过，你不需要重新声明

声明的智能合约称为合约类

合约类是用来派生智能合约实例的蓝图

合约类由类哈希值标识，合约类是纯代码，没有内部存储，仅仅是蓝图，不用于直接调用或交易

要部署合约类的实例，你需要从合约类派生它并执行构造函数，然后得到一个智能合约实例，这就是我们通常指的智能合约。

智能合约有内部存储、这个合约实例由其地址标识，从同一个合约类或代码，可以通过调用构造函数部署多个实例。它们将拥有不同的地址。即使它们源自同一个合约类，但存储是不同的。

#### 统一部署合约

部署其他合约的智能合约

只有一个 selector

（智能合约中某个特定函数的唯一标识符）：deployContract

内部使用 syscall ： depoly

<https://eips.ethereum.org/EIPS/eip-4337>

通用部署者

#### 合约类和实例

![image-20240720131528545](/images/image-20240720131528545.png)

智能合约部署

![image-20240720131641418](/images/image-20240720131641418.png)

智能合约调用

![image-20240720131746006](/images/image-20240720131746006.png)

#### 总结 - 架构

- 编译`Cairo` 到 `Sierra`
- 编译`Sierra` 到 `SafeCASM`
- 声明合约类
- 生成合约实例
- 合约类可以作为 Library 使用
- CASM 哈希用于证明编译
- 需要统一部署合约来部署
- Tx类型：声明和调用

### `Transactions`

![image-20240720132207643](/images/image-20240720132207643.png)

- transaction 是由你的钱包发起的，可以是智能手机或笔记本电脑中的钱包
- 你签署一笔交易，并将其发送到`Starknet` 上
- 接受该交易的 `Starknet` 节点称为 `Sequencer` 排序器
- 目前 `Starknet` 只有一个排序器，它具有类似内存池的功能
- 接收你的交易，并在实际执行交易前进行一些基本的交易验证
- 由于`Starknet` 智能合约实际上时 `Cairo` 程序，因此必须在`Cairo` 虚拟机上执行
- 交易从内存池发送到`Cairo`虚拟机，一旦执行完成，该执行的 trace 会发送到证明器，我们称其为 `SHARP`
- 被称为 `SHARP`的原因是它不只是给 `Starknet` 使用，也给`STARKEx` 使用
- `SHARP· 中的证明模块创建了有效性证明，确保其计算的完整性
- 交易执行的结果，有效性证明会发送到以太坊上一个名为验证器的智能合约，如果验证器认为此证明正确，则该执行结果就是正确的。

#### Tx 生命周期

![image-20240720143358793](/images/image-20240720143358793.png)

- 你发送一笔交易，需要对其进行签署，然后该交易被发送到内存池，内存池会检查该交易结构是否正确、字段是否正确以及格式是否正确
- 当交易被确认时，`Starknet` 就会接收它， 这时候它的状态就会变成 `RECEIVED`
- 如果发生某些事情，比如智能手机和排序器直接的连接中断了，你的交易将被忽略，故它的状态会变成 `IGNORED`
- 这个状态并不是一个标准状态，它意味着`Starknet`不会知道你的交易
- 有可能发生交易已经到了内存池，但因为格式不正确，比如使用了错误的客户端或SDK。在这种情况下，`Sequencer` 排序器会忽略该交易，不会解析其中的数据。
- 如果交易格式正确，被排序器和内存池接收，下一步就到签名验证阶段了，每笔交易都必须签名，如果签名不正确，意味着它的公私钥不对应，交易会被拒绝。如果签名有效，它就继续在`CairoVM` 虚拟机中运行。
- 如果排序器能成功使用 `CairoVM` 执行该交易，它的状态会变为`ACCEPTEN_ON_L2`。也就是在L2 上被接受。这就是在L2 上最终被确认的状态。是在`Starknet` 上执行你的交易后网络的新状态。
- 如果在执行过程中发生某些事情，例如、燃气耗尽或者断言错误，交易将停止并执行回滚。但你仍然会被收取执行交易从发生到回滚哪一刻产生的费用，最终的状态会变为 `REVERTED`。
- 无论交易成功或失败，最终都会生成 trace，并发送给证明者，证明者会生成有效证明，如果被以太坊接受，交易状态将变为`ACCEPTED_ON_L1`，也就是说在 L1 上被接受。

**总结：你的交易首先被内存池接收并确认，如果结构正确，通过签名验证，它将进入`CairoVM` 虚拟机执行，如果执行失败，交易将被拒绝。如果执行成功，交易将获得在L2 上被接受的状态，即 `ACCEPTED_ON_L2`。并在L2 上达到最终确认。有效性证明生成后发送给以太坊的验证器，如果被接受，交易状态将变为在L1上被接受，即 `ACCEPTED_ON_L1`。这就是整个生命周期**

#### Tx 类型

声明 Declare

- 在 SN  注册新的类

调用 Invoke

- 执行 write 函数

部署账户 deploy_account

- 部署账户合约

#### 假设性部署 - 部署账户合约

没有账户合约的前提下如何部署账户合约

1. 预先计算合约地址
2. 给这个地址发送资金
3. 发送 `deploy_account tx`
4. 序列器扣减 gas 后部署

部署账户合约与常规的智能合约是不同的

要部署智能合约你需要先有智能钱包

#### 总结 - Transactions

Tx 类型

- declare
- invoke
- Deploy_account

Tx 生命周期

- Received
- Accepted on  L2
- Accepted on L1
- Rejected / Reverted

## 总结

Starknet 提供了一种创新的区块链扩展方案，它通过结合零知识证明和强大的编程语言 Cairo，不仅解决了以太坊等主链的扩展性问题，还为开发者提供了强大的智能合约编程工具。与传统的 EVM 兼容链相比，Starknet 的性能更优越，验证成本更低，同时具有较短的最终确认时间，使其成为未来区块链应用的一个重要平台。通过本文的介绍，读者应能清晰理解 Starknet 的独特价值，并掌握其在区块链生态中的潜力和应用场景。

## 参考

- <https://www.bilibili.com/video/BV17E421P7PV/?spm_id_from=333.788&vd_source=bba3c74b0f6a3741d178163e8828d21b>
- <https://docs.starknet.io/quick-start/deploy-interact-with-a-smart-contract-remix/>
- <https://docs.starknet.io/>
- <https://github.com/starkware-libs/cairo>

+++
title = "UniswapV2 添加流动性 addLiquidity 源码解析"
description = "UniswapV2 添加流动性 addLiquidity 源码解析"
date = 2025-03-23 16:26:48+08:00
[taxonomies]
categories = ["UniswapV2 添加流动性 addLiquidity 源码解析"]
tags = ["UniswapV2 添加流动性 addLiquidity 源码解析"]
+++

<!-- more -->

# Uniswap

## UniswapV2 添加流动性 addLiquidity 源码解析

### 添加流动性 addLiquidity

用户在添加流动性的时候，用户首先调用 UniswapV2Router.sol 合约，提供 Token A 和 Token B 的数量，UniswapV2Router.sol 合约的 addLiquidity 函数接收用户的请求并进行处理。

```solidity
 function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external override ensure(deadline) returns (uint256 amountA, uint256 amountB, uint256 liquidity) {
        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);
        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);
        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);
        liquidity = IUniswapV2Pair(pair).mint(to);
    }
```

### 第一步：调用 `_addLiquidity` 函数来获取最终要添加的代币数量

```solidity

// **** ADD LIQUIDITY ****
// tokenA, tokenB: 要添加流动性的两种代币的地址。
// amountADesired, amountBDesired: 希望添加的两种代币的数量。这是用户输入的参数，并非最终实际添加的数量。
// amountAMin, amountBMin: 两种代币的最小可接受数量。用于防止滑点过大。
// private: 该函数只能在合约内部调用。
// returns (uint256 amountA, uint256 amountB): 返回实际添加的两种代币的数量。
function _addLiquidity(
    address tokenA,
    address tokenB,
    uint256 amountADesired,
    uint256 amountBDesired,
    uint256 amountAMin,
    uint256 amountBMin
) private returns (uint256 amountA, uint256 amountB) {
    // 1. 创建交易对
    // 如果该交易对不存在，则使用工厂合约 IUniswapV2Factory 创建一个新的交易对。
    // create the pair if it doesn't exist yet
    if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {
        IUniswapV2Factory(factory).createPair(tokenA, tokenB);
    }
    // 2. 获取储备量
    // 从UniswapV2Library获取交易对中tokenA和tokenB的当前储备量。
    (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);
    // 3. 处理空储备量情况
    // 如果交易对是新创建的，储备量为0，则直接使用用户期望的添加量。
    if (reserveA == 0 && reserveB == 0) {
        (amountA, amountB) = (amountADesired, amountBDesired);
    } else {
        // 4. 计算最优添加量:
        // 否则，根据现有储备量和用户期望的amountADesired，使用UniswapV2Library.quote函数计算最优的amountB。
        // UniswapV2Library.quote 函数根据常数乘积公式计算，确保添加流动性后保持交易对的恒定乘积不变。
        // 用户希望添加的 amountADesired 和当前的储备量 reserveA 和 reserveB，计算出在保持恒定乘积的情况下，应该添加的 amountB 的最优值。
        // amountB = (amountADesired * reserveB) / reserveA
        uint256 amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);
        // 5. 检查最小添加量:
        if (amountBOptimal <= amountBDesired) {
            // 检查计算出的amountB是否满足最小数量要求。如果不满足，则抛出异常。
            require(amountBOptimal >= amountBMin, "UniswapV2Router: INSUFFICIENT_B_AMOUNT");
            (amountA, amountB) = (amountADesired, amountBOptimal);
        } else {
            // 6. 处理amountBDesired小于最优amountB的情况
            //  amountAOptimal = (amountBDesired * reserveA) / reserveB;
            uint256 amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);
            assert(amountAOptimal <= amountADesired);
            require(amountAOptimal >= amountAMin, "UniswapV2Router: INSUFFICIENT_A_AMOUNT");
            // 通过计算 amountBOptimal 和 amountAOptimal，合约能够根据当前的流动性池状态和用户的输入，智能地决定应该添加多少代币，以保持流动性池的稳定性和有效性。
            // 这对于去中心化交易所（如 Uniswap）来说是非常重要的，因为它们依赖于流动性池的平衡来提供有效的交易价格和减少滑点。
            (amountA, amountB) = (amountAOptimal, amountBDesired);
        }
    }
}
```

在`_addLiquidity` 函数中，首先会根据 TokenA 、TokenB 通过 getPair 来查看交易对是否存在，如果不存在则通过 `createPair` 来创建。

```solidity
mapping(address => mapping(address => address)) public getPair;



function createPair(address tokenA, address tokenB) external returns (address pair) {
    require(tokenA != tokenB, "UniswapV2: IDENTICAL_ADDRESSES");

    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
    require(token0 != address(0), "UniswapV2: ZERO_ADDRESS");
    require(getPair[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"); // single check is sufficient
    //  用于获取 UniswapV2Pair 合约的创建字节码。这是一个智能合约编译器生成的字节码，用于在部署合约时初始化合约的代码。
    bytes memory bytecode = type(UniswapV2Pair).creationCode;
    bytes32 hash = keccak256(abi.encodePacked(bytecode));
    console.logBytes32("hash: ");
    console.logBytes32(hash);
    bytes32 salt = keccak256(abi.encodePacked(token0, token1));
    // CREATE2 是以太坊虚拟机 (EVM) 引入的一个 opcode，用于在智能合约中创建新合约。
    // 与传统的 CREATE opcode 不同，CREATE2 允许合约部署者在合约创建时指定合约地址，这样就可以预先知道新合约的地址。
    // CREATE2 是在以太坊硬分叉 Istanbul (EIP-1014) 中引入的。
    assembly {
        pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
    }
    IUniswapV2Pair(pair).initialize(token0, token1);
    getPair[token0][token1] = pair;
    getPair[token1][token0] = pair; // populate mapping in the reverse direction
    allPairs.push(pair);
    emit PairCreated(token0, token1, pair, allPairs.length);
}
```

然后通过`getReserves`来获取对应的储备量

`sortTokens` 函数用于对两个代币地址进行排序，确保无论输入顺序如何，输出始终按照地址从小到大的顺序排列（即 `token0 < token1`）。

```solidity
// returns sorted token addresses, used to handle return values from pairs sorted in this order
function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
// 检查 tokenA 和 tokenB 是否相同，若相同则抛出错误（避免无效配对）
    require(tokenA != tokenB, "UniswapV2Library: IDENTICAL_ADDRESSES");
    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
    require(token0 != address(0), "UniswapV2Library: ZERO_ADDRESS");
}


// calculates the CREATE2 address for a pair without making any external calls
function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    bytes memory bytecode = type(UniswapV2Pair).creationCode;
    // bytes32 hash = keccak256(abi.encodePacked(bytecode));
    bytes32 hash = keccak256(
        abi.encodePacked(
            hex"ff", factory, keccak256(abi.encodePacked(token0, token1)), keccak256(abi.encodePacked(bytecode))
        )
    );
    // hex"7f88588ebc7bc61b03dfecb4cfa631fec5109b1a2b2ae99ccbf392424d7c5be1" // init code hash
    // 直接从 bytes32 类型转换为 address 类型
    pair = address(uint160(uint256(hash)));
}

// https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol
// fetches and sorts the reserves for a pair
function getReserves(address factory, address tokenA, address tokenB)
    internal
    view
    returns (uint256 reserveA, uint256 reserveB)
{
    (address token0,) = sortTokens(tokenA, tokenB); // 标准化代币地址顺序

    (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();

    (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
}

function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
      _reserve0 = reserve0;
      _reserve1 = reserve1;
      _blockTimestampLast = blockTimestampLast;
  }
```

 如果交易对是新创建的，储备量为0，则直接使用用户期望的添加量。

```solidity
 if (reserveA == 0 && reserveB == 0) {
            (amountA, amountB) = (amountADesired, amountBDesired);
```

否则，计算最优添加量:

根据现有储备量和用户期望的amountADesired，使用UniswapV2Library.quote函数计算最优的amountB

UniswapV2Library.quote 函数根据常数乘积公式计算，确保添加流动性后保持交易对的恒定乘积不变。

用户希望添加的 amountADesired 和当前的储备量 reserveA 和 reserveB，计算出在保持恒定乘积的情况下，应该添加的 amountB 的最优值。
$$
amountB = \frac{(amountADesired * reserveB) }{reserveA}
$$


```solidity
uint256 amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);


// given some amount of an asset and pair reserves, returns an equivalent amount of the other asset
function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) internal pure returns (uint256 amountB) {
    require(amountA > 0, "UniswapV2Library: INSUFFICIENT_AMOUNT");
    require(reserveA > 0 && reserveB > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");
    amountB = (amountA * reserveB) / reserveA;
}
```

#### **恒定乘积公式**

$$
x \cdot y = k = L^2 \\
p = \frac{y}{x} \\


\begin{align}
L &= \sqrt{x \cdot y} \\
  &= \sqrt{x \cdot (p \cdot x)} \\
  &= \sqrt{x \cdot p \cdot x} \\
  &= \sqrt{x^2 \cdot p} \\
  &= x \cdot \sqrt{p}
\end{align}
$$

在代码中
$$
x \cdot y = k = L^2 \\
reserveA \cdot reserveB = k = L^2 \\
(x + \Delta x) \cdot (y + \Delta y) = k_1 \quad \text{其中} \quad k_1 > k \\
(reserveA + amountA) \cdot (reserveB + amountB) = K1 \\
$$


添加流动性时，用户必须 **按当前池中代币比例注入两种代币**，以确保流动性池的价格比例（即 `reserveA / reserveB`）不变。这一约束条件可表示为：
$$
\frac{\text{amountA}}{\text{amountB}} = \frac{\text{reserveA}}{\text{reserveB}} \tag{1}
$$
**推导逻辑**：
1. 原流动性池中代币储备为 `reserveA` 和 `reserveB`，满足 `reserveA * reserveB = k = L²`（`L` 为流动性总量）。
2. 用户注入 `amountA` 和 `amountB` 后，新储备量为 `reserveA + amountA` 和 `reserveB + amountB`。
3. 为确保注入后价格比例不变，需满足：
   $$
   \frac{\text{reserveA}}{\text{reserveB}} = \frac{\text{reserveA} + \text{amountA}}{\text{reserveB} + \text{amountB}} \tag{2}
   $$

---

#### 公式推导
从约束条件式（2）出发：
$$
\text{reserveA} \cdot (\text{reserveB} + \text{amountB}) = \text{reserveB} \cdot (\text{reserveA} + \text{amountA})
$$
展开后：
$$
\text{reserveA} \cdot \text{reserveB} + \text{reserveA} \cdot \text{amountB} = \text{reserveB} \cdot \text{reserveA} + \text{reserveB} \cdot \text{amountA}
$$
消去两边的 `reserveA * reserveB` 项：
$$
\text{reserveA} \cdot \text{amountB} = \text{reserveB} \cdot \text{amountA}
$$
整理得：
$$
\text{amountB} = \frac{\text{amountA} \cdot \text{reserveB}}{\text{reserveA}}
$$





用户按比例注入代币后，流动性池规模扩大（`k₁ > k`），但价格比例保持不变。

在这里 `amountB` 也就是 `amountBOptimal`。

根据上面计算出的 `amountBOptimal` 和 用户期望添加的 `amountBDesired` 进行比较：

如果  `amountBOptimal`  小于等于 `amountBDesired`，则：

并且 `amountBOptimal` 大于等于 `amountBMin`

最终返回的 `amountA` = `amountADesired`，`amountB` = `amountBOptimal`

```solidity
(amountA, amountB) = (amountADesired, amountBOptimal);
```

否则，计算`amountAOptimal`,计算过程与`amountBOptimal`一样，同上即可。
$$
\text{amountAOptimal} = \frac{\text{amountBDesired} \cdot \text{reserveA}}{\text{reserveB}}
$$
 通过计算 amountBOptimal 和 amountAOptimal，合约能够根据当前的流动性池状态和用户的输入，智能地决定应该添加多少代币，以保持流动性池的稳定性和有效性。

最终返回：

```solidity
(amountA, amountB) = (amountAOptimal, amountBDesired);
```

到此为止，通过`_addLiquidity`函数可得到用户最终实际添加的两种代币的数量。即，

```solidity
(amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);
```

### 第二步：获取 `pair` 合约地址

```solidity
address public immutable override factory;
 
address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);

// calculates the CREATE2 address for a pair without making any external calls
function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    bytes memory bytecode = type(UniswapV2Pair).creationCode;
    // bytes32 hash = keccak256(abi.encodePacked(bytecode));
    bytes32 hash = keccak256(
        abi.encodePacked(
            hex"ff", factory, keccak256(abi.encodePacked(token0, token1)), keccak256(abi.encodePacked(bytecode))
        )
    );
    // hex"7f88588ebc7bc61b03dfecb4cfa631fec5109b1a2b2ae99ccbf392424d7c5be1" // init code hash
    // 直接从 bytes32 类型转换为 address 类型
    pair = address(uint160(uint256(hash)));
}
```

根据工厂合约地址、tokenA地址、tokenB地址通过`pairFor` 函数来计算出一个 CREATE2 address 作为交易对的合约地址。

### 第三步：Transfer Token

```solidity
TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);
TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);
```

这段代码调用了`TransferHelper`合约中的`safeTransferFrom`函数，该函数用于从调用者账户（`msg.sender`）向指定的代币交换对（`pair`）转移代币

### 第四步：铸造流动性代币

addLiquidity 函数进一步调用 UniswapV2Pair.sol 合约，在 UniswapV2Pair.sol 合约中，调用 mint 函数执行实际的流动性添加操作，mint 函数根据用户提供的 Token A 和 Token B 的数量，计算应铸造的流动性代币（LP 代币）的数量，并将这些 LP 代币分配给用户，流动性添加操作完成后，mint 函数调用 _update 函数更新储备量。

```solidity
liquidity = IUniswapV2Pair(pair).mint(to);
```

`IUniswapV2Pair(pair)`表示调用Uniswap V2交易对合约的接口。`pair`是一个合约地址，指向一个具体的Uniswap V2交易对合约。

`mint(to)`是Uniswap V2交易对合约中的一个函数，用于铸造新的流动性代币。`to`参数指定了新铸造的流动性代币接收者的地址。

流动性提供者通过提供一定数量的代币（通常是两种不同代币）来铸造流动性代币，这些代币代表了提供者的份额。流动性提供者可以通过这些流动性代币从交易对中赚取交易手续费。

`pair`是一个Uniswap V2交易对的合约地址，`to`是流动性代币接收者的地址，这段代码的作用就是通过调用Uniswap V2交易对合约的`mint`函数，铸造新的流动性代币，并将其发送到`to`地址。

```solidity
// this low-level function should be called from a contract which performs important safety checks
function mint(address to) external lock returns (uint256 liquidity) {
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    uint256 balance0 = IERC20(token0).balanceOf(address(this));
    uint256 balance1 = IERC20(token1).balanceOf(address(this));
    uint256 amount0 = balance0 - _reserve0;
    uint256 amount1 = balance1 - _reserve1;

    bool feeOn = _mintFee(_reserve0, _reserve1);
    uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
    if (_totalSupply == 0) {
        liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;
        _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
    } else {
        liquidity = Math.min((amount0 * _totalSupply) / _reserve0, (amount1 * _totalSupply) / _reserve1);
    }
    require(liquidity > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED");
    _mint(to, liquidity);

    _update(balance0, balance1, _reserve0, _reserve1);
    if (feeOn) kLast = reserve0 * reserve1; // reserve0 and reserve1 are up-to-date
    emit Mint(msg.sender, amount0, amount1);
}
```

这个函数的主要目的是在用户添加流动性时，铸造新的流动性代币并分配给提供流动性的用户。

1. **获取储备量**：首先，函数通过调用`getReserves()`函数获取当前池子中两种代币（token0和token1）的储备量（_reserve0和_reserve1）。
2. **计算余额变化**：接着，函数获取当前合约地址下两种代币的余额（balance0和balance1），并计算自上次更新以来两种代币的余额变化（amount0和amount1）。
3. **计算流动性**：然后，函数根据余额变化和总供应量计算用户应获得的流动性代币数量。如果这是第一次添加流动性（即总供应量为0），则铸造的流动性代币数量减去一个固定的最小流动性值（MINIMUM_LIQUIDITY）。否则，根据余额变化和总储备量计算用户应得的流动性代币数量。

当 `totalSupply` 等于 0 的时候，即首次添加流动性，计算流动性如下：

```solidity
 liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;
 
 uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;
```

$$
x \cdot y = k = L^2 \\
\begin{align*}
    \text{恒定乘积常数} \quad k &= x \cdot y \\
    \text{流动性参数} \quad L &= \sqrt{k} \\
                               &= \sqrt{x \cdot y} \\
                               &= \sqrt{amount0 \cdot amount1}
\end{align*}
$$

代码中实际上首次添加计算出流动性后会扣除`1000 wei`，扣除的 `1000 wei` 会被永久锁定以增强系统安全性。

当 `totalSupply`不 等于 0 的时候，即**非首次添加流动性时计算用户应获得的 LP 代币数量**

计算流动性（liquidity）如下：

```solidity
liquidity = Math.min((amount0 * _totalSupply) / _reserve0, (amount1 * _totalSupply) / _reserve1);

```

1. 输入参数：

- `amount0`：用户在交易对中添加的某种代币的数量。
- `amount1`：用户在交易对中添加的另一种代币的数量。
- `_totalSupply`：当前交易对的流动性代币（通常称为LP代币）的总供应量。
- `_reserve0`：交易对中某种代币的储备量。
- `_reserve1`：交易对中另一种代币的储备量。

2. 计算过程：

- 首先，计算用户添加的代币数量与当前储备量的比例，分别对应两种代币。
- 具体计算公式为：
  - `liquidity0 = (amount0 * _totalSupply) / _reserve0`
  - `liquidity1 = (amount1 * _totalSupply) / _reserve1`
- 然后，取这两个比例中的最小值，作为用户的流动性。

### 公式推导

$$
x \cdot y = k = L^2 \\
reserve0 \cdot reserve1 = totalSupply^2 \\
​添加流动性（k 增大）​ \\
当用户按比例存入代币时，新的储备量为： \\
x' = x + Δx \\
y' = y + Δy \\
池子变为：\\
x' = reserve0 + amount0 \\
y' = reserve1 + amount1 \\
k' = x' * y' \\
\frac{x}{y} = \frac{Δx}{Δy} \\
\frac{reserve0}{reserve1} = \frac{amount0}{amount1} \\
\frac{x + Δx}{y + Δy}
$$

基于上面的前提，我们进行下面的推导：
$$
L0 &= \frac{amount0}{reserve0} \cdot totalSupply \\
	&= \frac{amount0 \cdot totalSupply}{reserve0} \\

L1 &= \frac{amount1}{reserve1} \cdot totalSupply \\
&= \frac{amount1 \cdot totalSupply}{reserve1} \\
$$
L0 是你加的 amount0 占池子原来 reserve0 的比例，能拿多少 LP 代币 

L1 是你加的 amount1 占池子原来 reserve1 的比例，能拿多少 LP 代币

最后 Uniswap 会取小的那个（Math.min(L_0, L_1)），保证你加的钱比例跟池子一致。

取小的是为了让池子保持原来的比例，不让你的“乱加钱”搞乱价格。

计算出需要 Mint 的流动性数量后调用`_mint` 函数进行Mint 铸造 LPT。

```solidity
function _mint(address to, uint256 value) internal {
    totalSupply = totalSupply.add(value);
    balanceOf[to] = balanceOf[to].add(value);
    emit Transfer(address(0), to, value);
}

uint256 public override totalSupply;
mapping(address => uint256) public balanceOf;
```

这个函数主要实现了三步：

- **增加总供应量**
- **增加接收者的余额**
- **触发事件**

最后更新储备数据并记录事件

```solidity
 // update reserves and, on the first call per block, price accumulators
function _update(uint256 balance0, uint256 balance1, uint112 _reserve0, uint112 _reserve1) private {
    require(
        // balance0 <= uint112(-1) && balance1 <= uint112(-1),
        // 使用 uint112 的最大值来替代 -1
        balance0 <= type(uint112).max && balance1 <= type(uint112).max,
        "UniswapV2: OVERFLOW"
    );
    uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);
    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
        // * never overflows, and + overflow is desired
        // _reserve1 * 2 ** 112 / _reserve0 * timeElapsed
        // 在 OraclePrice 使用，在本合约中只记录未使用
        // https://github.com/Uniswap/v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol
        price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
        price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
    }
    reserve0 = uint112(balance0);
    reserve1 = uint112(balance1);
    blockTimestampLast = blockTimestamp;
    emit Sync(reserve0, reserve1);
}
```

记录事件

```
 emit Mint(msg.sender, amount0, amount1);
```

添加流动性完成！











大白话总结

- 交易：换来换去，k 不变，x/y 变。
- 加钱（添加流动性）：扔钱进去，x 和 y 变大，k 也变大。
- 拿钱（移除流动性）：拿走钱，x 和 y 变小，k 变小。



未完待续...

之后会继续分析移除流动性 removeLiquidity、Swap等剩余源码 



## 总结



## 参考

- https://github.com/Uniswap/v2-core
- https://github.com/Uniswap/v2-sdk
- https://github.com/Uniswap/foundry-template
- https://github.com/Uniswap/v2-periphery
- https://github.com/Uniswap/v2-subgraph
- https://thegraph.com/explorer
- https://app.uniswap.org/
- https://docs.uniswap.org/
- https://app.uniswap.org/whitepaper-v4.pdf
- https://docs.uniswap.org/contracts/v2/guides/smart-contract-integration/getting-pair-addresses
- https://www.rareskills.io/post/uniswap-v2-price-impact
- https://github.com/Dapp-Learning-DAO/Dapp-Learning/blob/main/defi/Uniswap-V2/readme.md

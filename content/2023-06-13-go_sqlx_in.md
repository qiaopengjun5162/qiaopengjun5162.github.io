+++
title = "Go è¯­è¨€ä¹‹ SQLX é«˜çº§æ“ä½œ sqlx.In"
date = 2023-06-13T15:08:51+08:00
description = "Go è¯­è¨€ä¹‹ SQLX é«˜çº§æ“ä½œ sqlx.In"
[taxonomies]
tags = ["Go"]
categories = ["Go"]
+++

# Go è¯­è¨€ä¹‹ SQLX é«˜çº§æ“ä½œ sqlx.In

## sqlx.In ä»‹ç»

`sqlx` is a package for Go which provides a set of extensions on top of the excellent built-in `database/sql` package.

Illustrated guide to SQLXï¼š<http://jmoiron.github.io/sqlx/>

sqlxï¼š<https://github.com/jmoiron/sqlx>

### "In" Queries

Because `database/sql` does not inspect your query and it passes your arguments directly to the driver, it makes dealing with queries with IN clauses difficult:

```
SELECT * FROM users WHERE level IN (?);
```

When this gets prepared as a statement on the backend, the bindvar `?` will only correspond to a *single* argument, but what is often desired is for that to be a variable number of arguments depending on the length of some slice, eg:

```
var levels = []int{4, 6, 7}rows, err := db.Query("SELECT * FROM users WHERE level IN (?);", levels)
```

This pattern is possible by first processing the query with `sqlx.In`:

```
var levels = []int{4, 6, 7}query, args, err := sqlx.In("SELECT * FROM users WHERE level IN (?);", levels) // sqlx.In returns queries with the `?` bindvar, we can rebind it for our backendquery = db.Rebind(query)rows, err := db.Query(query, args...)
```

What `sqlx.In` does is expand any bindvars in the query passed to it that correspond to a slice in the arguments to the length of that slice, and then append those slice elements to a new arglist. It does this with the `?` bindvar only; you can use `db.Rebind` to get a query suitable for your backend.

## æ™®é€šæ‰¹é‡æ’å…¥æ•°æ®ï¼Œä¸ä½¿ç”¨ sqlx.In

```go
package main

import (
 "database/sql"
 "fmt"
 "strings"
 "time"

 _ "github.com/go-sql-driver/mysql" // åŒ¿åå¯¼å…¥ è‡ªåŠ¨æ‰§è¡Œ init()
)

var db *sql.DB

func initMySQL() (err error) {
 //DSN (Data Source Name)
 dsn := "root:12345678@tcp(127.0.0.1:3306)/sql_test"
 // æ³¨æ„ï¼šè¦åˆå§‹åŒ–å…¨å±€çš„ db å¯¹è±¡ï¼Œä¸è¦æ–°å£°æ˜ä¸€ä¸ª db å˜é‡
 db, err = sql.Open("mysql", dsn) // åªå¯¹æ ¼å¼è¿›è¡Œæ ¡éªŒï¼Œå¹¶ä¸ä¼šçœŸæ­£è¿æ¥æ•°æ®åº“
 if err != nil {
  return err
 }

 // Ping éªŒè¯ä¸æ•°æ®åº“çš„è¿æ¥æ˜¯å¦ä»å¤„äºæ´»åŠ¨çŠ¶æ€ï¼Œå¹¶åœ¨å¿…è¦æ—¶å»ºç«‹è¿æ¥ã€‚
 err = db.Ping()
 if err != nil {
  fmt.Printf("connect to db failed, err: %v\n", err)
  return err
 }
 // æ•°å€¼éœ€è¦æ ¹æ®ä¸šåŠ¡å…·ä½“æƒ…å†µæ¥ç¡®å®š
 db.SetConnMaxLifetime(time.Second * 10) // è®¾ç½®å¯ä»¥é‡ç”¨è¿æ¥çš„æœ€é•¿æ—¶é—´
 db.SetConnMaxIdleTime(time.Second * 5)  // è®¾ç½®è¿æ¥å¯èƒ½å¤„äºç©ºé—²çŠ¶æ€çš„æœ€é•¿æ—¶é—´
 db.SetMaxOpenConns(200)                 // è®¾ç½®ä¸æ•°æ®åº“çš„æœ€å¤§æ‰“å¼€è¿æ¥æ•°
 db.SetMaxIdleConns(10)                  //  è®¾ç½®ç©ºé—²è¿æ¥æ± ä¸­çš„æœ€å¤§è¿æ¥æ•°
 return nil
}

type User struct {
 Name string `db:"name"`
 Age  int    `db:"age"`
}

// BatchInsertUsers æ‰¹é‡æ’å…¥æ•°æ®
func BatchInsertUsers(users []*User) error {
 valueStrings := make([]string, 0, len(users))     // å ä½ç¬¦ slice
 valueArgs := make([]interface{}, 0, len(users)*2) // æ’å…¥å€¼ slice

 for _, u := range users {
  valueStrings = append(valueStrings, "(?, ?)")
  valueArgs = append(valueArgs, u.Name, u.Age) // å ä½ç¬¦ä¸æ’å…¥å€¼ ä¸€ä¸€å¯¹åº”
 }
 // æ‹¼æ¥å®Œæ•´çš„SQLè¯­å¥
 // Sprintfæ ¹æ®æ ¼å¼è¯´æ˜ç¬¦è¿›è¡Œæ ¼å¼åŒ–ï¼Œå¹¶è¿”å›ç»“æœå­—ç¬¦ä¸²ã€‚
 // Joinå°†å…¶ç¬¬ä¸€ä¸ªå‚æ•°çš„å…ƒç´ è¿æ¥èµ·æ¥ä»¥åˆ›å»ºå•ä¸ªå­—ç¬¦ä¸²ã€‚åˆ†éš”å­—ç¬¦ä¸²sepæ”¾ç½®åœ¨ç»“æœå­—ç¬¦ä¸²çš„å…ƒç´ ä¹‹é—´ã€‚
 stmt := fmt.Sprintf("INSERT INTO user (name, age) VALUES %s", strings.Join(valueStrings, ","))
 // Execæ‰§è¡ŒæŸ¥è¯¢è€Œä¸è¿”å›ä»»ä½•è¡Œã€‚å‚æ•°ç”¨äºæŸ¥è¯¢ä¸­çš„ä»»ä½•å ä½ç¬¦å‚æ•°ã€‚
 result, err := db.Exec(stmt, valueArgs...)
 if err != nil {
  fmt.Printf("Error inserting user into database: %v \n", err)
  return err
 }
 var rows_affected int64
 rows_affected, err = result.RowsAffected() // è¿”å›å—æ›´æ–°ã€æ’å…¥æˆ–åˆ é™¤å½±å“çš„è¡Œæ•°ã€‚å¹¶éæ¯ä¸ªæ•°æ®åº“æˆ–æ•°æ®åº“é©±åŠ¨ç¨‹åºéƒ½æ”¯æŒæ­¤åŠŸèƒ½ã€‚
 if err != nil {
  fmt.Printf("è¿”å›å—æ›´æ–°ã€æ’å…¥æˆ–åˆ é™¤å½±å“çš„è¡Œæ•° failed, err: %v\n", err)
  return err
 }
 fmt.Println("å—æ›´æ–°ã€æ’å…¥æˆ–åˆ é™¤å½±å“çš„è¡Œæ•°: ", rows_affected)
 return nil
}

func main() {
 if err := initMySQL(); err != nil {
  fmt.Printf("connect to db failed, err: %v\n", err)
 }
 // æ£€æŸ¥å®Œé”™è¯¯ä¹‹åæ‰§è¡Œï¼Œç¡®ä¿ db ä¸ä¸º nil
 // Close() ç”¨æ¥é‡Šæ”¾æ•°æ®åº“è¿æ¥ç›¸å…³çš„èµ„æº
 // Close å°†å…³é—­æ•°æ®åº“å¹¶é˜»æ­¢å¯åŠ¨æ–°æŸ¥è¯¢ã€‚å…³é—­ï¼Œç„¶åç­‰å¾…æœåŠ¡å™¨ä¸Šå·²å¼€å§‹å¤„ç†çš„æ‰€æœ‰æŸ¥è¯¢å®Œæˆã€‚
 defer db.Close()

 fmt.Println("connect to database success")
 // db.xx() å»ä½¿ç”¨æ•°æ®åº“æ“ä½œ...

 // æ‰¹é‡æ’å…¥æ•°æ®
 users := []*User{
  {Name: "åˆ˜å¤‡", Age: 25},
  {Name: "å…³ç¾½", Age: 30},
  {Name: "å¼ é£", Age: 28},
 }
 err := BatchInsertUsers(users)
 if err != nil {
  fmt.Printf("Failed to batch insert users: %v", err)
 }
}

```

#### è¿è¡Œ

```bash
Code/go/mysql_demo via ğŸ¹ v1.20.3 via ğŸ…’ base 
âœ go run  main.go
connect to database success
å—æ›´æ–°ã€æ’å…¥æˆ–åˆ é™¤å½±å“çš„è¡Œæ•°:  3

Code/go/mysql_demo via ğŸ¹ v1.20.3 via ğŸ…’ base 
âœ 
```

#### SQL æŸ¥è¯¢ç»“æœ

```sql
mysql> select * from user;  # æ’å…¥ä¹‹å‰
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  1 | å°ä¹”   |   12 |
|  2 | å°ä¹”   |   22 |
|  5 | æ˜­å›   |   18 |
|  6 | é»›ç‰   |   16 |
|  8 | æç…œ   |   26 |
|  9 | Alice  |   25 |
| 10 | Bob    |   30 |
| 11 | Carol  |   28 |
| 12 | Alice1 |   25 |
| 13 | Bob1   |   30 |
| 14 | Carol1 |   28 |
+----+--------+------+
11 rows in set (0.00 sec)

mysql> select * from user;  # æ’å…¥ä¹‹å
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  1 | å°ä¹”   |   12 |
|  2 | å°ä¹”   |   22 |
|  5 | æ˜­å›   |   18 |
|  6 | é»›ç‰   |   16 |
|  8 | æç…œ   |   26 |
|  9 | Alice  |   25 |
| 10 | Bob    |   30 |
| 11 | Carol  |   28 |
| 12 | Alice1 |   25 |
| 13 | Bob1   |   30 |
| 14 | Carol1 |   28 |
| 15 | åˆ˜å¤‡   |   25 |
| 16 | å…³ç¾½   |   30 |
| 17 | å¼ é£   |   28 |
+----+--------+------+
14 rows in set (0.01 sec)

```

## ä½¿ç”¨ sqlx.In æ‰¹é‡æ’å…¥

```go
package main

import (
 "database/sql/driver"
 "fmt"
 _ "github.com/go-sql-driver/mysql"
 "github.com/jmoiron/sqlx"
)

var db *sqlx.DB

func initDB() (err error) {
 dsn := "root:12345678@tcp(127.0.0.1:3306)/sql_test?charset=utf8mb4&parseTime=True"
 // è¿æ¥åˆ°æ•°æ®åº“å¹¶ä½¿ç”¨pingè¿›è¡ŒéªŒè¯ã€‚
 // ä¹Ÿå¯ä»¥ä½¿ç”¨ MustConnect MustConnectè¿æ¥åˆ°æ•°æ®åº“ï¼Œå¹¶åœ¨å‡ºç°é”™è¯¯æ—¶ææ…Œ panicã€‚
 db, err = sqlx.Connect("mysql", dsn)
 if err != nil {
  fmt.Printf("connect DB failed, err:%v\n", err)
  return
 }
 db.SetMaxOpenConns(20) // è®¾ç½®æ•°æ®åº“çš„æœ€å¤§æ‰“å¼€è¿æ¥æ•°ã€‚
 db.SetMaxIdleConns(10) // è®¾ç½®ç©ºé—²è¿æ¥æ± ä¸­çš„æœ€å¤§è¿æ¥æ•°ã€‚
 return
}

type user struct {
 ID   int    `db:"id"`
 Age  int    `db:"age"`
 Name string `db:"name"`
}

func (u user) Value() (driver.Value, error) {
 return []interface{}{u.Name, u.Age}, nil
}

// BatchInsertUsersSqlxIn ä½¿ç”¨sqlx.Inå¸®æˆ‘ä»¬æ‹¼æ¥è¯­å¥å’Œå‚æ•°, æ³¨æ„ä¼ å…¥çš„å‚æ•°æ˜¯[]interface{}
func BatchInsertUsersSqlxIn(users []interface{}) error {
 // Inå±•å¼€argsä¸­çš„åˆ‡ç‰‡å€¼ï¼Œè¿”å›ä¿®æ”¹åçš„æŸ¥è¯¢å­—ç¬¦ä¸²å’Œä¸€ä¸ªå¯ä»¥ç”±æ•°æ®åº“æ‰§è¡Œçš„æ–°çš„argåˆ—è¡¨ã€‚
 // â€œæŸ¥è¯¢â€åº”è¯¥ä½¿ç”¨â€œ?â€â€œbindVarã€‚è¿”å›å€¼ä½¿ç”¨' ?â€œbindVarã€‚
 query, args, _ := sqlx.In(
  "INSERT INTO user (name, age) VALUES (?), (?), (?)",
  users..., // å¦‚æœargå®ç°äº† driver.Valuer, sqlx.In ä¼šé€šè¿‡è°ƒç”¨ Value()æ¥å±•å¼€å®ƒ
 )
 fmt.Println("query sql string: ", query) // æŸ¥çœ‹ç”Ÿæˆçš„querystring
 fmt.Println("args: ", args)              // æŸ¥çœ‹ç”Ÿæˆçš„args
 // Execæ‰§è¡ŒæŸ¥è¯¢è€Œä¸è¿”å›ä»»ä½•è¡Œã€‚å‚æ•°ç”¨äºæŸ¥è¯¢ä¸­çš„ä»»ä½•å ä½ç¬¦å‚æ•°ã€‚
 result, err := db.Exec(query, args...)
 var rows_affected int64
 rows_affected, err = result.RowsAffected() // è¿”å›å—æ›´æ–°ã€æ’å…¥æˆ–åˆ é™¤å½±å“çš„è¡Œæ•°ã€‚å¹¶éæ¯ä¸ªæ•°æ®åº“æˆ–æ•°æ®åº“é©±åŠ¨ç¨‹åºéƒ½æ”¯æŒæ­¤åŠŸèƒ½ã€‚
 if err != nil {
  fmt.Printf("è¿”å›å—æ›´æ–°ã€æ’å…¥æˆ–åˆ é™¤å½±å“çš„è¡Œæ•° failed, err: %v\n", err)
  return err
 }
 fmt.Println("å—æ›´æ–°ã€æ’å…¥æˆ–åˆ é™¤å½±å“çš„è¡Œæ•°: ", rows_affected)
 return nil
}


func main() {
 if err := initDB(); err != nil {
  fmt.Printf("init DB failed, err:%v\n", err)
  return
 }
 fmt.Println("init DB succeeded")
 
 // æ‰¹é‡æ’å…¥
 u1 := user{Name: "æç™½", Age: 16}
 u2 := user{Name: "æœç”«", Age: 42}
 u3 := user{Name: "ç‹ç»´", Age: 29}
 users := []interface{}{u1, u2, u3}
 _ = BatchInsertUsersSqlxIn(users)
}

```

#### è¿è¡Œ

```bash
Code/go/sqlx_demo via ğŸ¹ v1.20.3 via ğŸ…’ base 
âœ go run main.go
init DB succeeded
query sql string:  INSERT INTO user (name, age) VALUES (?, ?), (?, ?), (?, ?)
args:  [æç™½ 16 æœç”« 42 ç‹ç»´ 29]
å—æ›´æ–°ã€æ’å…¥æˆ–åˆ é™¤å½±å“çš„è¡Œæ•°:  3

Code/go/sqlx_demo via ğŸ¹ v1.20.3 via ğŸ…’ base 
```

#### SQL æŸ¥è¯¢ç»“æœ

```sql
mysql> select * from user;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  1 | å°ä¹”   |   12 |
|  2 | å°ä¹”   |   22 |
|  5 | æ˜­å›   |   18 |
|  6 | é»›ç‰   |   16 |
|  8 | æç…œ   |   26 |
|  9 | Alice  |   25 |
| 10 | Bob    |   30 |
| 11 | Carol  |   28 |
| 12 | Alice1 |   25 |
| 13 | Bob1   |   30 |
| 14 | Carol1 |   28 |
| 15 | åˆ˜å¤‡   |   25 |
| 16 | å…³ç¾½   |   30 |
| 17 | å¼ é£   |   28 |
+----+--------+------+
14 rows in set (0.01 sec)

mysql> select * from user;  # æ’å…¥ä¹‹å
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  1 | å°ä¹”   |   12 |
|  2 | å°ä¹”   |   22 |
|  5 | æ˜­å›   |   18 |
|  6 | é»›ç‰   |   16 |
|  8 | æç…œ   |   26 |
|  9 | Alice  |   25 |
| 10 | Bob    |   30 |
| 11 | Carol  |   28 |
| 12 | Alice1 |   25 |
| 13 | Bob1   |   30 |
| 14 | Carol1 |   28 |
| 15 | åˆ˜å¤‡   |   25 |
| 16 | å…³ç¾½   |   30 |
| 17 | å¼ é£   |   28 |
| 18 | æç™½   |   16 |
| 19 | æœç”«   |   42 |
| 20 | ç‹ç»´   |   29 |
+----+--------+------+
17 rows in set (0.00 sec)

mysql>
```

## ä½¿ç”¨  NamedExec æ‰¹é‡æ’å…¥

```go
package main

import (
 "database/sql/driver"
 "fmt"
 _ "github.com/go-sql-driver/mysql"
 "github.com/jmoiron/sqlx"
)

var db *sqlx.DB

func initDB() (err error) {
 dsn := "root:12345678@tcp(127.0.0.1:3306)/sql_test?charset=utf8mb4&parseTime=True"
 // è¿æ¥åˆ°æ•°æ®åº“å¹¶ä½¿ç”¨pingè¿›è¡ŒéªŒè¯ã€‚
 // ä¹Ÿå¯ä»¥ä½¿ç”¨ MustConnect MustConnectè¿æ¥åˆ°æ•°æ®åº“ï¼Œå¹¶åœ¨å‡ºç°é”™è¯¯æ—¶ææ…Œ panicã€‚
 db, err = sqlx.Connect("mysql", dsn)
 if err != nil {
  fmt.Printf("connect DB failed, err:%v\n", err)
  return
 }
 db.SetMaxOpenConns(20) // è®¾ç½®æ•°æ®åº“çš„æœ€å¤§æ‰“å¼€è¿æ¥æ•°ã€‚
 db.SetMaxIdleConns(10) // è®¾ç½®ç©ºé—²è¿æ¥æ± ä¸­çš„æœ€å¤§è¿æ¥æ•°ã€‚
 return
}

type user struct {
 ID   int    `db:"id"`
 Age  int    `db:"age"`
 Name string `db:"name"`
}

func (u user) Value() (driver.Value, error) {
 return []interface{}{u.Name, u.Age}, nil
}


// BatchInsertUsersNamedExec NamedExec æ‰¹é‡æ’å…¥
func BatchInsertUsersNamedExec(users []*user) error {
 // ä»»ä½•å‘½åçš„å ä½ç¬¦å‚æ•°éƒ½å°†è¢«argä¸­çš„å­—æ®µæ›¿æ¢ã€‚
 result, err := db.NamedExec("INSERT INTO user (name, age) VALUES (:name, :age)", users)
 var rows_affected int64
 rows_affected, err = result.RowsAffected() // è¿”å›å—æ›´æ–°ã€æ’å…¥æˆ–åˆ é™¤å½±å“çš„è¡Œæ•°ã€‚å¹¶éæ¯ä¸ªæ•°æ®åº“æˆ–æ•°æ®åº“é©±åŠ¨ç¨‹åºéƒ½æ”¯æŒæ­¤åŠŸèƒ½ã€‚
 if err != nil {
  fmt.Printf("è¿”å›å—æ›´æ–°ã€æ’å…¥æˆ–åˆ é™¤å½±å“çš„è¡Œæ•° failed, err: %v\n", err)
  return err
 }
 fmt.Println("BatchInsertUsersNamedExec å—æ’å…¥å½±å“çš„è¡Œæ•°: ", rows_affected)
 return nil
}

func main() {
 if err := initDB(); err != nil {
  fmt.Printf("init DB failed, err:%v\n", err)
  return
 }
 fmt.Println("init DB succeeded")
 
 // æ‰¹é‡æ’å…¥
 u1 := user{Name: "è¤’å§’", Age: 16}
 u2 := user{Name: "è²‚è‰", Age: 42}
 u3 := user{Name: "é£ç‡•", Age: 29}
 
 // NamedExec
 users := []*user{&u1, &u2, &u3}
 _ = BatchInsertUsersNamedExec(users)
}

```

#### è¿è¡Œ

```bash
Code/go/sqlx_demo via ğŸ¹ v1.20.3 via ğŸ…’ base 
âœ go run main.go
init DB succeeded
BatchInsertUsersNamedExec å—æ’å…¥å½±å“çš„è¡Œæ•°:  3

Code/go/sqlx_demo via ğŸ¹ v1.20.3 via ğŸ…’ base 
âœ 

```

#### SQL æŸ¥è¯¢ç»“æœ

```sql
mysql> select * from user;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  1 | å°ä¹”   |   12 |
|  2 | å°ä¹”   |   22 |
|  5 | æ˜­å›   |   18 |
|  6 | é»›ç‰   |   16 |
|  8 | æç…œ   |   26 |
|  9 | Alice  |   25 |
| 10 | Bob    |   30 |
| 11 | Carol  |   28 |
| 12 | Alice1 |   25 |
| 13 | Bob1   |   30 |
| 14 | Carol1 |   28 |
| 15 | åˆ˜å¤‡   |   25 |
| 16 | å…³ç¾½   |   30 |
| 17 | å¼ é£   |   28 |
| 18 | æç™½   |   16 |
| 19 | æœç”«   |   42 |
| 20 | ç‹ç»´   |   29 |
+----+--------+------+
17 rows in set (0.00 sec)

mysql> select * from user;  # æ’å…¥ä¹‹å
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  1 | å°ä¹”   |   12 |
|  2 | å°ä¹”   |   22 |
|  5 | æ˜­å›   |   18 |
|  6 | é»›ç‰   |   16 |
|  8 | æç…œ   |   26 |
|  9 | Alice  |   25 |
| 10 | Bob    |   30 |
| 11 | Carol  |   28 |
| 12 | Alice1 |   25 |
| 13 | Bob1   |   30 |
| 14 | Carol1 |   28 |
| 15 | åˆ˜å¤‡   |   25 |
| 16 | å…³ç¾½   |   30 |
| 17 | å¼ é£   |   28 |
| 18 | æç™½   |   16 |
| 19 | æœç”«   |   42 |
| 20 | ç‹ç»´   |   29 |
| 21 | è¤’å§’   |   16 |
| 22 | è²‚è‰   |   42 |
| 23 | é£ç‡•   |   29 |
+----+--------+------+
20 rows in set (0.00 sec)

mysql>
```

## sqlx é«˜çº§æ“ä½œä¹‹ IN æŸ¥è¯¢

### æŸ¥è¯¢ ID åœ¨æŒ‡å®šé›†åˆä¸­çš„æ•°æ®

```go
package main

import (
 "database/sql/driver"
 "fmt"
 _ "github.com/go-sql-driver/mysql"
 "github.com/jmoiron/sqlx"
)

var db *sqlx.DB

func initDB() (err error) {
 dsn := "root:12345678@tcp(127.0.0.1:3306)/sql_test?charset=utf8mb4&parseTime=True"
 // è¿æ¥åˆ°æ•°æ®åº“å¹¶ä½¿ç”¨pingè¿›è¡ŒéªŒè¯ã€‚
 // ä¹Ÿå¯ä»¥ä½¿ç”¨ MustConnect MustConnectè¿æ¥åˆ°æ•°æ®åº“ï¼Œå¹¶åœ¨å‡ºç°é”™è¯¯æ—¶ææ…Œ panicã€‚
 db, err = sqlx.Connect("mysql", dsn)
 if err != nil {
  fmt.Printf("connect DB failed, err:%v\n", err)
  return
 }
 db.SetMaxOpenConns(20) // è®¾ç½®æ•°æ®åº“çš„æœ€å¤§æ‰“å¼€è¿æ¥æ•°ã€‚
 db.SetMaxIdleConns(10) // è®¾ç½®ç©ºé—²è¿æ¥æ± ä¸­çš„æœ€å¤§è¿æ¥æ•°ã€‚
 return
}

type user struct {
 ID   int    `db:"id"`
 Age  int    `db:"age"`
 Name string `db:"name"`
}

// QueryByIDs æŸ¥è¯¢ ID åœ¨æŒ‡å®šé›†åˆä¸­çš„æ•°æ®
func QueryByIDs(ids []int) (users []user, err error) {
 // In å±•å¼€argsä¸­çš„åˆ‡ç‰‡å€¼ï¼Œè¿”å›ä¿®æ”¹åçš„æŸ¥è¯¢å­—ç¬¦ä¸²å’Œä¸€ä¸ªå¯ä»¥ç”±æ•°æ®åº“æ‰§è¡Œçš„æ–°çš„argåˆ—è¡¨ã€‚
 // â€œæŸ¥è¯¢â€åº”è¯¥ä½¿ç”¨â€œ?â€â€œbindVarã€‚è¿”å›å€¼ä½¿ç”¨' ?â€œbindVar
 query, args, err := sqlx.In("SELECT name, age FROM user WHERE id IN (?)", ids)
 if err != nil {
  return nil, err
 }
 // Rebind å°†æŸ¥è¯¢ä» QUESTION è½¬æ¢ä¸ºDBé©±åŠ¨ç¨‹åºçš„ bindvar ç±»å‹ã€‚
 query = db.Rebind(query)
 // Select ä½¿ç”¨æ­¤æ•°æ®åº“ã€‚ä»»ä½•å ä½ç¬¦å‚æ•°éƒ½å°†è¢«æä¾›çš„å‚æ•°æ›¿æ¢ã€‚
 err = db.Select(&users, query, args...)
 if err != nil {
  return nil, err
 }
 return users, nil
}

func main() {
 if err := initDB(); err != nil {
  fmt.Printf("init DB failed, err:%v\n", err)
  return
 }
 fmt.Println("init DB succeeded")
 
 // IN æŸ¥è¯¢
 users, err := QueryByIDs([]int{1, 15, 21, 2})  // é»˜è®¤æŒ‰ç…§ä¸»é”®é¡ºåºæ’åˆ—
 if err != nil {
  fmt.Printf("query error: %v\n", err)
  return
 }
 fmt.Printf("query successful result users %v\n", users)
 for _, user := range users {
  fmt.Printf("user: %#v\n", user)
 }
}

```

##### è¿è¡Œ

```bash
Code/go/sqlx_demo via ğŸ¹ v1.20.3 via ğŸ…’ base 
âœ go run main.go
init DB succeeded
query successful result users [{0 12 å°ä¹”} {0 22 å°ä¹”} {0 25 åˆ˜å¤‡} {0 16 è¤’å§’}]
user: main.user{ID:0, Age:12, Name:"å°ä¹”"}
user: main.user{ID:0, Age:22, Name:"å°ä¹”"}
user: main.user{ID:0, Age:25, Name:"åˆ˜å¤‡"}
user: main.user{ID:0, Age:16, Name:"è¤’å§’"}

Code/go/sqlx_demo via ğŸ¹ v1.20.3 via ğŸ…’ base 
âœ 
```

#### SQL æŸ¥è¯¢ç»“æœ

```sql
mysql> select * from user;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  1 | å°ä¹”   |   12 |
|  2 | å°ä¹”   |   22 |
|  5 | æ˜­å›   |   18 |
|  6 | é»›ç‰   |   16 |
|  8 | æç…œ   |   26 |
|  9 | Alice  |   25 |
| 10 | Bob    |   30 |
| 11 | Carol  |   28 |
| 12 | Alice1 |   25 |
| 13 | Bob1   |   30 |
| 14 | Carol1 |   28 |
| 15 | åˆ˜å¤‡   |   25 |
| 16 | å…³ç¾½   |   30 |
| 17 | å¼ é£   |   28 |
| 18 | æç™½   |   16 |
| 19 | æœç”«   |   42 |
| 20 | ç‹ç»´   |   29 |
| 21 | è¤’å§’   |   16 |
| 22 | è²‚è‰   |   42 |
| 23 | é£ç‡•   |   29 |
+----+--------+------+
20 rows in set (0.00 sec)

mysql>
```

- æŸ¥è¯¢ç»“æœé»˜è®¤æŒ‰ç…§ä¸»é”®é¡ºåºæ’åˆ—
- è‡ªå®šä¹‰æŸ¥è¯¢ç»“æœé¡ºåº
  - ä½¿ç”¨ä»£ç æ’åº
  - ä½¿ç”¨ MySQL æ’åº FIND_IN_SET

## sqlx é«˜çº§æ“ä½œä¹‹ FIND_IN_SET

```go
package main

import (
 "database/sql/driver"
 "fmt"
 _ "github.com/go-sql-driver/mysql"
 "github.com/jmoiron/sqlx"
 "strings"
)

var db *sqlx.DB

func initDB() (err error) {
 dsn := "root:12345678@tcp(127.0.0.1:3306)/sql_test?charset=utf8mb4&parseTime=True"
 // è¿æ¥åˆ°æ•°æ®åº“å¹¶ä½¿ç”¨pingè¿›è¡ŒéªŒè¯ã€‚
 // ä¹Ÿå¯ä»¥ä½¿ç”¨ MustConnect MustConnectè¿æ¥åˆ°æ•°æ®åº“ï¼Œå¹¶åœ¨å‡ºç°é”™è¯¯æ—¶ææ…Œ panicã€‚
 db, err = sqlx.Connect("mysql", dsn)
 if err != nil {
  fmt.Printf("connect DB failed, err:%v\n", err)
  return
 }
 db.SetMaxOpenConns(20) // è®¾ç½®æ•°æ®åº“çš„æœ€å¤§æ‰“å¼€è¿æ¥æ•°ã€‚
 db.SetMaxIdleConns(10) // è®¾ç½®ç©ºé—²è¿æ¥æ± ä¸­çš„æœ€å¤§è¿æ¥æ•°ã€‚
 return
}

type user struct {
 ID   int    `db:"id"`
 Age  int    `db:"age"`
 Name string `db:"name"`
}

// QueryByIDs  æŸ¥è¯¢ ID åœ¨æŒ‡å®šé›†åˆä¸­çš„æ•°æ®
func QueryByIDs(ids []int) (users []user, err error) {
 // In å±•å¼€argsä¸­çš„åˆ‡ç‰‡å€¼ï¼Œè¿”å›ä¿®æ”¹åçš„æŸ¥è¯¢å­—ç¬¦ä¸²å’Œä¸€ä¸ªå¯ä»¥ç”±æ•°æ®åº“æ‰§è¡Œçš„æ–°çš„argåˆ—è¡¨ã€‚
 // â€œæŸ¥è¯¢â€åº”è¯¥ä½¿ç”¨â€œ?â€â€œbindVarã€‚è¿”å›å€¼ä½¿ç”¨' ?â€œbindVar
 query, args, err := sqlx.In("SELECT name, age FROM user WHERE id IN (?)", ids)
 if err != nil {
  return nil, err
 }
 // Rebind å°†æŸ¥è¯¢ä» QUESTION è½¬æ¢ä¸ºDBé©±åŠ¨ç¨‹åºçš„ bindvar ç±»å‹ã€‚
 query = db.Rebind(query)
 // Select ä½¿ç”¨æ­¤æ•°æ®åº“ã€‚ä»»ä½•å ä½ç¬¦å‚æ•°éƒ½å°†è¢«æä¾›çš„å‚æ•°æ›¿æ¢ã€‚
 err = db.Select(&users, query, args...)
 if err != nil {
  return nil, err
 }
 return users, nil
}

// QueryAndOrderByIDs æ ¹æ® ID åœ¨æŒ‡å®šé›†åˆä¸­å’ŒæŒ‡å®šé¡ºåºæŸ¥è¯¢
func QueryAndOrderByIDs(ids []int) (users []user, err error) {
 // åˆ›å»ºä¸€ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œå¤§å°ä¸ºidsçš„é•¿åº¦
 strIDs := make([]string, 0, len(ids))
 // å°†idsè½¬æ¢ä¸ºå­—ç¬¦ä¸²ç±»å‹
 for _, id := range ids {
  // Sprintfæ ¹æ®æ ¼å¼è¯´æ˜ç¬¦è¿›è¡Œæ ¼å¼åŒ–ï¼Œå¹¶è¿”å›ç»“æœå­—ç¬¦ä¸²ã€‚
  strIDs = append(strIDs, fmt.Sprintf("%d", id))
 }
 // Inå±•å¼€argsä¸­çš„åˆ‡ç‰‡å€¼ï¼Œè¿”å›ä¿®æ”¹åçš„æŸ¥è¯¢å­—ç¬¦ä¸²å’Œä¸€ä¸ªå¯ä»¥ç”±æ•°æ®åº“æ‰§è¡Œçš„æ–°çš„argåˆ—è¡¨ã€‚â€œæŸ¥è¯¢â€åº”è¯¥ä½¿ç”¨â€œ?â€â€œbindVarã€‚è¿”å›å€¼ä½¿ç”¨' ?â€œbindVarã€‚
 query, args, err := sqlx.In("SELECT name, age FROM user WHERE id IN (?) ORDER BY FIND_IN_SET(id, ?)", ids, strings.Join(strIDs, ","))
 if err != nil {
  return
 }

 // Rebind å°†æŸ¥è¯¢ä»QUESTIONè½¬æ¢ä¸ºDBé©±åŠ¨ç¨‹åºçš„bindvarç±»å‹ã€‚
 query = db.Rebind(query)
 // æ‰§è¡ŒæŸ¥è¯¢ Select ä½¿ç”¨æ­¤æ•°æ®åº“ã€‚ä»»ä½•å ä½ç¬¦å‚æ•°éƒ½å°†è¢«æä¾›çš„å‚æ•°æ›¿æ¢ã€‚
 err = db.Select(&users, query, args...)
 return
}

func main() {
 if err := initDB(); err != nil {
  fmt.Printf("init DB failed, err:%v\n", err)
  return
 }
 fmt.Println("init DB succeeded")
 
 // IN æŸ¥è¯¢
 users, err := QueryByIDs([]int{1, 15, 21, 2})
 if err != nil {
  fmt.Printf("query error: %v\n", err)
  return
 }
 fmt.Printf("query successful result users %v\n", users)
 for _, user := range users {
  fmt.Printf("user: %#v\n", user)
 }

 fmt.Println("**************")
 // FIND_IN_SET
 users, err = QueryAndOrderByIDs([]int{1, 15, 21, 2})
 if err != nil {
  fmt.Printf("query error: %v\n", err)
  return
 }
 fmt.Printf("query successful result users %v\n", users)
 for _, user := range users {
  fmt.Printf("user: %#v\n", user)
 }
}

```

#### è¿è¡Œ

```bash
Code/go/sqlx_demo via ğŸ¹ v1.20.3 via ğŸ…’ base 
âœ go run main.go
init DB succeeded
query successful result users [{0 12 å°ä¹”} {0 22 å°ä¹”} {0 25 åˆ˜å¤‡} {0 16 è¤’å§’}]
user: main.user{ID:0, Age:12, Name:"å°ä¹”"}
user: main.user{ID:0, Age:22, Name:"å°ä¹”"}
user: main.user{ID:0, Age:25, Name:"åˆ˜å¤‡"}
user: main.user{ID:0, Age:16, Name:"è¤’å§’"}
**************
query successful result users [{0 12 å°ä¹”} {0 25 åˆ˜å¤‡} {0 16 è¤’å§’} {0 22 å°ä¹”}]
user: main.user{ID:0, Age:12, Name:"å°ä¹”"}  # FIND_IN_SET æŒ‰ç…§æŒ‡å®šé¡ºåºæŸ¥è¯¢
user: main.user{ID:0, Age:25, Name:"åˆ˜å¤‡"}
user: main.user{ID:0, Age:16, Name:"è¤’å§’"}
user: main.user{ID:0, Age:22, Name:"å°ä¹”"}

Code/go/sqlx_demo via ğŸ¹ v1.20.3 via ğŸ…’ base 
âœ 

```

æ³¨æ„ï¼šå¼€å‘ä¸­ï¼Œä½¿ç”¨ä»£ç æ’åºè¿˜æ˜¯ä½¿ç”¨ SQL FIND_IN_SET æŸ¥è¯¢æ’åºï¼Œéœ€è¦æ ¹æ®å¼€å‘å®é™…æƒ…å†µæ¥ä½¿ç”¨ã€‚

## å®˜æ–¹ç¤ºä¾‹

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    
    _ "github.com/lib/pq"
    "github.com/jmoiron/sqlx"
)

var schema = `
CREATE TABLE person (
    first_name text,
    last_name text,
    email text
);

CREATE TABLE place (
    country text,
    city text NULL,
    telcode integer
)`

type Person struct {
    FirstName string `db:"first_name"`
    LastName  string `db:"last_name"`
    Email     string
}

type Place struct {
    Country string
    City    sql.NullString
    TelCode int
}

func main() {
    // this Pings the database trying to connect
    // use sqlx.Open() for sql.Open() semantics
    db, err := sqlx.Connect("postgres", "user=foo dbname=bar sslmode=disable")
    if err != nil {
        log.Fatalln(err)
    }

    // exec the schema or fail; multi-statement Exec behavior varies between
    // database drivers;  pq will exec them all, sqlite3 won't, ymmv
    db.MustExec(schema)
    
    tx := db.MustBegin()
    tx.MustExec("INSERT INTO person (first_name, last_name, email) VALUES ($1, $2, $3)", "Jason", "Moiron", "jmoiron@jmoiron.net")
    tx.MustExec("INSERT INTO person (first_name, last_name, email) VALUES ($1, $2, $3)", "John", "Doe", "johndoeDNE@gmail.net")
    tx.MustExec("INSERT INTO place (country, city, telcode) VALUES ($1, $2, $3)", "United States", "New York", "1")
    tx.MustExec("INSERT INTO place (country, telcode) VALUES ($1, $2)", "Hong Kong", "852")
    tx.MustExec("INSERT INTO place (country, telcode) VALUES ($1, $2)", "Singapore", "65")
    // Named queries can use structs, so if you have an existing struct (i.e. person := &Person{}) that you have populated, you can pass it in as &person
    tx.NamedExec("INSERT INTO person (first_name, last_name, email) VALUES (:first_name, :last_name, :email)", &Person{"Jane", "Citizen", "jane.citzen@example.com"})
    tx.Commit()

    // Query the database, storing results in a []Person (wrapped in []interface{})
    people := []Person{}
    db.Select(&people, "SELECT * FROM person ORDER BY first_name ASC")
    jason, john := people[0], people[1]

    fmt.Printf("%#v\n%#v", jason, john)
    // Person{FirstName:"Jason", LastName:"Moiron", Email:"jmoiron@jmoiron.net"}
    // Person{FirstName:"John", LastName:"Doe", Email:"johndoeDNE@gmail.net"}

    // You can also get a single result, a la QueryRow
    jason = Person{}
    err = db.Get(&jason, "SELECT * FROM person WHERE first_name=$1", "Jason")
    fmt.Printf("%#v\n", jason)
    // Person{FirstName:"Jason", LastName:"Moiron", Email:"jmoiron@jmoiron.net"}

    // if you have null fields and use SELECT *, you must use sql.Null* in your struct
    places := []Place{}
    err = db.Select(&places, "SELECT * FROM place ORDER BY telcode ASC")
    if err != nil {
        fmt.Println(err)
        return
    }
    usa, singsing, honkers := places[0], places[1], places[2]
    
    fmt.Printf("%#v\n%#v\n%#v\n", usa, singsing, honkers)
    // Place{Country:"United States", City:sql.NullString{String:"New York", Valid:true}, TelCode:1}
    // Place{Country:"Singapore", City:sql.NullString{String:"", Valid:false}, TelCode:65}
    // Place{Country:"Hong Kong", City:sql.NullString{String:"", Valid:false}, TelCode:852}

    // Loop through rows using only one struct
    place := Place{}
    rows, err := db.Queryx("SELECT * FROM place")
    for rows.Next() {
        err := rows.StructScan(&place)
        if err != nil {
            log.Fatalln(err)
        } 
        fmt.Printf("%#v\n", place)
    }
    // Place{Country:"United States", City:sql.NullString{String:"New York", Valid:true}, TelCode:1}
    // Place{Country:"Hong Kong", City:sql.NullString{String:"", Valid:false}, TelCode:852}
    // Place{Country:"Singapore", City:sql.NullString{String:"", Valid:false}, TelCode:65}

    // Named queries, using `:name` as the bindvar.  Automatic bindvar support
    // which takes into account the dbtype based on the driverName on sqlx.Open/Connect
    _, err = db.NamedExec(`INSERT INTO person (first_name,last_name,email) VALUES (:first,:last,:email)`, 
        map[string]interface{}{
            "first": "Bin",
            "last": "Smuth",
            "email": "bensmith@allblacks.nz",
    })

    // Selects Mr. Smith from the database
    rows, err = db.NamedQuery(`SELECT * FROM person WHERE first_name=:fn`, map[string]interface{}{"fn": "Bin"})

    // Named queries can also use structs.  Their bind names follow the same rules
    // as the name -> db mapping, so struct fields are lowercased and the `db` tag
    // is taken into consideration.
    rows, err = db.NamedQuery(`SELECT * FROM person WHERE first_name=:first_name`, jason)
    
    
    // batch insert
    
    // batch insert with structs
    personStructs := []Person{
        {FirstName: "Ardie", LastName: "Savea", Email: "asavea@ab.co.nz"},
        {FirstName: "Sonny Bill", LastName: "Williams", Email: "sbw@ab.co.nz"},
        {FirstName: "Ngani", LastName: "Laumape", Email: "nlaumape@ab.co.nz"},
    }

    _, err = db.NamedExec(`INSERT INTO person (first_name, last_name, email)
        VALUES (:first_name, :last_name, :email)`, personStructs)

    // batch insert with maps
    personMaps := []map[string]interface{}{
        {"first_name": "Ardie", "last_name": "Savea", "email": "asavea@ab.co.nz"},
        {"first_name": "Sonny Bill", "last_name": "Williams", "email": "sbw@ab.co.nz"},
        {"first_name": "Ngani", "last_name": "Laumape", "email": "nlaumape@ab.co.nz"},
    }

    _, err = db.NamedExec(`INSERT INTO person (first_name, last_name, email)
        VALUES (:first_name, :last_name, :email)`, personMaps)
}
```

#### [æ›´å¤šç¤ºä¾‹è¯·å‚è€ƒå®˜æ–¹æ–‡æ¡£](https://github.com/jmoiron/sqlx/blob/master/sqlx_test.go)ï¼š<https://github.com/jmoiron/sqlx/blob/master/sqlx_test.go>

+++
title = "Go 语言之搭建通用 Web 项目开发脚手架"
date = 2023-06-18T19:31:41+08:00
description = "Go 语言之搭建通用 Web 项目开发脚手架"
[taxonomies]
tags = ["Go"]
categories = ["Go"]
+++

# Go 语言之搭建通用 Web 项目开发脚手架

## MVC 模式

MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。

- **Model（模型）** - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。
- **View（视图）** - 视图代表模型包含的数据的可视化。
- **Controller（控制器）** - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。

![](https://raw.githubusercontent.com/qiaopengjun5162/blogpicgo/master/img202306182104206.png)

## Web 项目 CLD 分层

协议处理层：支持各种协议

Controller：服务的入口，负责处理路由、参数校验、请求转发。

Logic/Service：逻辑（服务）层，负责处理业务逻辑。

DAO/Repository：负责数据与存储相关功能。

![](https://raw.githubusercontent.com/qiaopengjun5162/blogpicgo/master/img202306182139911.png)

## 搭建 Web 项目开发脚手架

### 创建 web_app 项目

![](https://raw.githubusercontent.com/qiaopengjun5162/blogpicgo/master/img202306182141188.png)

### 创建 main 文件

![](https://raw.githubusercontent.com/qiaopengjun5162/blogpicgo/master/img202306182144666.png)

### 项目目录

```bash
Code/go/web_app via 🐹 v1.20.3 via 🅒 base took 8h 53m 28.4s 
➜ tree                                      
.
├── config.yaml
├── controllers
├── dao
│   ├── mysql
│   │   └── mysql.go
│   └── redis
│       └── redis.go
├── go.mod
├── go.sum
├── logger
│   └── logger.go
├── logic
├── main.go
├── models
├── pkg
├── routes
│   └── routes.go
├── settings
│   └── settings.go
├── web_app
└── web_app.log

11 directories, 11 files

Code/go/web_app via 🐹 v1.20.3 via 🅒 base 
➜ 

```

#### config.yaml

```yaml
app:
  name: "web_app"
  mode: "dev"
  port: 8080

log:
  level: "debug"
  filename: "web_app.log"
  max_size: 30
  max_age: 30
  max_backups: 7

mysql:
  host: "127.0.0.1"
  port: 3306
  user: "root"
  password: "12345678"
  dbname: "sql_test"
  max_open_conns: 200
  max_idle_conns: 50

redis:
  host: "127.0.0.1"
  port: 6379
  password: ""
  db: 0
  pool_size: 100
```

#### settings/settings.go

```go
package settings

import (
 "fmt"

 "github.com/fsnotify/fsnotify"
 "github.com/spf13/viper"
)

func Init() (err error) {
 // 设置默认值
 viper.SetDefault("fileDir", "./")
 // 读取配置文件
 viper.SetConfigFile("./config.yaml") // 指定配置文件路径
 viper.SetConfigName("config")        // 配置文件名称(无扩展名)
 viper.SetConfigType("yaml")          // SetConfigType设置远端源返回的配置类型，例如:“json”。
 viper.AddConfigPath(".")             // 还可以在工作目录中查找配置

 err = viper.ReadInConfig() // 查找并读取配置文件
 if err != nil {            // 处理读取配置文件的错误
  fmt.Printf("viper.ReadInConfig failed, error: %v\n", err)
  return
 }

 // 实时监控配置文件的变化 WatchConfig 开始监视配置文件的更改。
 viper.WatchConfig()
 // OnConfigChange设置配置文件更改时调用的事件处理程序。
 // 当配置文件变化之后调用的一个回调函数
 viper.OnConfigChange(func(e fsnotify.Event) {
  fmt.Println("Config file changed:", e.Name)
 })

 return
}

```

#### logger/logger.go

```go
package settings

import (
 "fmt"

 "github.com/fsnotify/fsnotify"
 "github.com/spf13/viper"
)

func Init() (err error) {
 // 设置默认值
 viper.SetDefault("fileDir", "./")
 // 读取配置文件
 viper.SetConfigFile("./config.yaml") // 指定配置文件路径
 viper.SetConfigName("config")        // 配置文件名称(无扩展名)
 viper.SetConfigType("yaml")          // 如果配置文件的名称中没有扩展名，则需要配置此项
 viper.AddConfigPath(".")             // 还可以在工作目录中查找配置

 err = viper.ReadInConfig() // 查找并读取配置文件
 if err != nil {            // 处理读取配置文件的错误
  fmt.Printf("viper.ReadInConfig failed, error: %v\n", err)
  return
 }

 // 实时监控配置文件的变化 WatchConfig 开始监视配置文件的更改。
 viper.WatchConfig()
 // OnConfigChange设置配置文件更改时调用的事件处理程序。
 // 当配置文件变化之后调用的一个回调函数
 viper.OnConfigChange(func(e fsnotify.Event) {
  fmt.Println("Config file changed:", e.Name)
 })

 return
}

```

#### dao/mysql/mysql.go

```go
package mysql

import (
 "fmt"

 "go.uber.org/zap"

 "github.com/jmoiron/sqlx"
 "github.com/spf13/viper"

 _ "github.com/go-sql-driver/mysql" // 匿名导入 自动执行 init()
)

var db *sqlx.DB

func Init() (err error) {
 //DSN (Data Source Name) Sprintf根据格式说明符进行格式化，并返回结果字符串。
 dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&parseTime=true",
  viper.GetString("mysql.user"),
  viper.GetString("mysql.password"),
  viper.GetString("mysql.host"),
  viper.GetInt("mysql.port"),
  viper.GetString("mysql.dbname"),
 )
 // 连接到数据库并使用ping进行验证。
 // 也可以使用 MustConnect MustConnect连接到数据库，并在出现错误时恐慌 panic。
 db, err = sqlx.Connect("mysql", dsn)
 if err != nil {
  zap.L().Error("connect DB failed", zap.Error(err))
  return
 }
 db.SetMaxOpenConns(viper.GetInt("mysql.max_open_conns")) // 设置数据库的最大打开连接数。
 db.SetMaxIdleConns(viper.GetInt("mysql.max_idle_conns")) // 设置空闲连接池中的最大连接数。
 return
}

func Close() {
 _ = db.Close()
}

```

#### dao/redis/redis.go

```go
package redis

import (
 "context"
 "fmt"

 "github.com/redis/go-redis/v9"
 "github.com/spf13/viper"
)

// 声明一个全局的 rdb 变量
var rdb *redis.Client

// 初始化连接
func Init() (err error) {
 // NewClient将客户端返回给Options指定的Redis Server。
 // Options保留设置以建立redis连接。
 rdb = redis.NewClient(&redis.Options{
  Addr:     fmt.Sprintf("%s:%d", viper.GetString("redis.host"), viper.GetInt("redis.port")),
  Password: viper.GetString("redis.password"), // 没有密码，默认值
  DB:       viper.GetInt("redis.db"),          // 默认DB 0 连接到服务器后要选择的数据库。
  PoolSize: viper.GetInt("redis.pool_size"),   // 最大套接字连接数。 默认情况下，每个可用CPU有10个连接，由runtime.GOMAXPROCS报告。
 })

 // Background返回一个非空的Context。它永远不会被取消，没有值，也没有截止日期。
 // 它通常由main函数、初始化和测试使用，并作为传入请求的顶级上下文
 ctx := context.Background()

 _, err = rdb.Ping(ctx).Result()
 return
}

func Close() {
 _ = rdb.Close()
}

```

#### routes/routes.go

```go
package routes

import (
 "net/http"
 "web_app/logger"

 "github.com/gin-gonic/gin"
)

func Setup() *gin.Engine {
 r := gin.New()
 r.Use(logger.GinLogger(), logger.GinRecovery(true))

 r.GET("/", func(context *gin.Context) {
  context.String(http.StatusOK, "OK")
 })
 return r
}

```

#### main.go

```go
package main

import (
 "context"
 "fmt"
 "log"
 "net/http"
 "os"
 "os/signal"
 "syscall"
 "time"
 "web_app/dao/mysql"
 "web_app/dao/redis"
 "web_app/logger"
 "web_app/routes"
 "web_app/settings"

 "github.com/spf13/viper"

 "go.uber.org/zap"
)

// Go Web 开发通用的脚手架模版

func main() {
 // 1. 加载配置
 if err := settings.Init(); err != nil {
  fmt.Printf("init settings failed, error: %v\n", err)
  return
 }
 // 2. 初始化日志
 if err := logger.Init(); err != nil {
  fmt.Printf("init logger failed, error: %v\n", err)
  return
 }
 defer zap.L().Sync()
 zap.L().Debug("logger initialized successfully")
 // 3. 初始化 MySQL 连接
 if err := mysql.Init(); err != nil {
  fmt.Printf("init mysql failed, error: %v\n", err)
  return
 }
 defer mysql.Close()
 // 4. 初始化 Redis 连接
 if err := redis.Init(); err != nil {
  fmt.Printf("init redis failed, error: %v\n", err)
  return
 }
 defer redis.Close()
 // 5. 注册路由
 router := routes.Setup()
 // 6. 启动服务（优雅关机）
 // 服务器定义运行HTTP服务器的参数。Server的零值是一个有效的配置。
 srv := &http.Server{
  // Addr可选地以“host:port”的形式指定服务器要监听的TCP地址。如果为空，则使用“:http”(端口80)。
  // 服务名称在RFC 6335中定义，并由IANA分配
  Addr:    fmt.Sprintf(":%d", viper.GetInt("app.port")),
  Handler: router,
 }

 go func() {
  // 开启一个goroutine启动服务，如果不用 goroutine，下面的代码 ListenAndServe 会一直接收请求，处理请求，进入无限循环。代码就不会往下执行。

  // ListenAndServe监听TCP网络地址srv.Addr，然后调用Serve来处理传入连接上的请求。接受的连接配置为使TCP能保持连接。
  // ListenAndServe always returns a non-nil error. After Shutdown or Close,
  // the returned error is ErrServerClosed.
  if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
   log.Fatalf("listen: %s\n", err) // Fatalf 相当于Printf()之后再调用os.Exit(1)。
  }
 }()

 // 等待中断信号来优雅地关闭服务器，为关闭服务器操作设置一个5秒的超时

 // make内置函数分配并初始化(仅)slice、map或chan类型的对象。
 // 与new一样，第一个参数是类型，而不是值。
 // 与new不同，make的返回类型与其参数的类型相同，而不是指向它的指针
 // Channel:通道的缓冲区用指定的缓冲区容量初始化。如果为零，或者忽略大小，则通道未被缓冲。

 // 信号 Signal 表示操作系统信号。通常的底层实现依赖于操作系统:在Unix上是syscall.Signal。
 quit := make(chan os.Signal, 1) // 创建一个接收信号的通道
 // kill 默认会发送 syscall.SIGTERM 信号
 // kill -2 发送 syscall.SIGINT 信号，Ctrl+C 就是触发系统SIGINT信号
 // kill -9 发送 syscall.SIGKILL 信号，但是不能被捕获，所以不需要添加它
 // signal.Notify把收到的 syscall.SIGINT或syscall.SIGTERM 信号转发给quit

 // Notify使包信号将传入的信号转发给c，如果没有提供信号，则将所有传入的信号转发给c，否则仅将提供的信号转发给c。
 // 包信号不会阻塞发送到c:调用者必须确保c有足够的缓冲空间来跟上预期的信号速率。对于仅用于通知一个信号值的通道，大小为1的缓冲区就足够了。
 // 允许使用同一通道多次调用Notify:每次调用都扩展发送到该通道的信号集。从集合中移除信号的唯一方法是调用Stop。
 // 允许使用不同的通道和相同的信号多次调用Notify:每个通道独立地接收传入信号的副本。
 signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM) // 此处不会阻塞
 <-quit                                               // 阻塞在此，当接收到上述两种信号时才会往下执行
 zap.L().Info("Shutdown Server ...")
 // 创建一个5秒超时的context
 ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 defer cancel()
 // 5秒内优雅关闭服务（将未处理完的请求处理完再关闭服务），超过5秒就超时退出

 // 关机将在不中断任何活动连接的情况下优雅地关闭服务器。
 // Shutdown的工作原理是首先关闭所有打开的侦听器，然后关闭所有空闲连接，然后无限期地等待连接返回空闲状态，然后关闭。
 // 如果提供的上下文在关闭完成之前过期，则shutdown返回上下文的错误，否则返回关闭服务器的底层侦听器所返回的任何错误。
 // 当Shutdown被调用时，Serve, ListenAndServe和ListenAndServeTLS会立即返回ErrServerClosed。确保程序没有退出，而是等待Shutdown返回。
 // 关闭不试图关闭或等待被劫持的连接，如WebSockets。如果需要的话，Shutdown的调用者应该单独通知这些长寿命连接关闭，并等待它们关闭。
 // 一旦在服务器上调用Shutdown，它可能不会被重用;以后对Serve等方法的调用将返回ErrServerClosed。
 if err := srv.Shutdown(ctx); err != nil {
  zap.L().Fatal("Server Shutdown", zap.Error(err))
 }

 zap.L().Info("Server exiting")
}

```

### 运行并访问：<http://127.0.0.1:8080>

```bash
Code/go/web_app via 🐹 v1.20.3 via 🅒 base 
➜ go build 

Code/go/web_app via 🐹 v1.20.3 via 🅒 base 
➜ ./web_app
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:   export GIN_MODE=release
 - using code:  gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /                         --> web_app/routes.Setup.func1 (3 handlers)


```

![](https://raw.githubusercontent.com/qiaopengjun5162/blogpicgo/master/img202306190043937.png)

## 使用结构体变量保存配置信息

### 项目 web_app2 目录

```bash
ode/go/web_app2 via 🐹 v1.20.3 via 🅒 base
➜ tree
.
├── config.yaml
├── controllers
├── dao
│   ├── mysql
│   │   └── mysql.go
│   └── redis
│       └── redis.go
├── go.mod
├── go.sum
├── logger
│   └── logger.go
├── logic
├── main.go
├── models
├── pkg
├── routes
│   └── routes.go
├── settings
│   └── settings.go
├── web_app.log
└── web_app2

11 directories, 11 files

Code/go/web_app2 via 🐹 v1.20.3 via 🅒 base
➜
```

config.yaml

```yaml
name: "web_app"
mode: "dev"
port: 8080
version: "v0.0.2"

log:
  level: "debug"
  filename: "web_app.log"
  max_size: 30
  max_age: 30
  max_backups: 7

mysql:
  host: "127.0.0.1"
  port: 3306
  user: "root"
  password: "12345678"
  dbname: "sql_test"
  max_open_conns: 200
  max_idle_conns: 50

redis:
  host: "127.0.0.1"
  port: 6379
  password: ""
  db: 0
  pool_size: 100
```

settings/settings.go

```go
package settings

import (
 "fmt"

 "github.com/fsnotify/fsnotify"
 "github.com/spf13/viper"
)

// Conf 全局变量，用来保存程序的所有配置信息
var Conf = new(AppConfig)

type AppConfig struct {
 Name    string `mapstructure:"name"`
 Mode    string `mapstructure:"mode"`
 Version string `mapstructure:"version"`
 Port    int    `mapstructure:"port"`

 *LogConfig   `mapstructure:"log"`
 *MySQLConfig `mapstructure:"mysql"`
 *RedisConfig `mapstructure:"redis"`
}

type LogConfig struct {
 Level      string `mapstructure:"level"`
 Filename   string `mapstructure:"filename"`
 MaxSize    int    `mapstructure:"max_size"`
 MaxAge     int    `mapstructure:"max_age"`
 MaxBackups int    `mapstructure:"max_backups"`
}

type MySQLConfig struct {
 Host         string `mapstructure:"host"`
 User         string `mapstructure:"user"`
 Password     string `mapstructure:"password"`
 DbName       string `mapstructure:"db_name"`
 Port         int    `mapstructure:"port"`
 MaxOpenConns int    `mapstructure:"max_open_conns"`
 MaxIdleConns int    `mapstructure:"max_idle_conns"`
}

type RedisConfig struct {
 Host     string `mapstructure:"host"`
 Password string `mapstructure:"password"`
 Port     int    `matstructure:"port"`
 DB       int    `mapstructure:"db"`
 PoolSize int    `mapstructure:"pool_size"`
}

func Init() (err error) {
 // 方式1：直接指定配置文件路径（相对路径或者绝对路径）
 // 相对路径：相对执行的可执行文件的相对路径
 // viper.SetConfigFile("./conf/config.yaml")
 // 绝对路径：系统中实际的文件路径
 // viper.SetConfigFile("/Users/qiaopengjun/Desktop/web_app2 /conf/config.yaml")

 // 方式2：指定配置文件名和配置文件的位置，viper 自行查找可用的配置文件
 // 配置文件名不需要带后缀
 // 配置文件位置可配置多个
 // 注意：viper 是根据文件名查找，配置目录里不要有同名的配置文件。
 // 例如：在配置目录 ./conf 中不要同时存在 config.yaml、config.json

 // 读取配置文件
 viper.SetConfigFile("./config.yaml") // 指定配置文件路径
 viper.SetConfigName("config")        // 配置文件名称(无扩展名)
 viper.AddConfigPath(".")             // 指定查找配置文件的路径（这里使用相对路径）可以配置多个
 viper.AddConfigPath("./conf")        // 指定查找配置文件的路径（这里使用相对路径）可以配置多个
 // SetConfigType设置远端源返回的配置类型，例如:“json”。
 // 基本上是配合远程配置中心使用的，告诉viper 当前的数据使用什么格式去解析
 viper.SetConfigType("yaml")

 err = viper.ReadInConfig() // 查找并读取配置文件
 if err != nil {            // 处理读取配置文件的错误
  fmt.Printf("viper.ReadInConfig failed, error: %v\n", err)
  return
 }

 // 把读取到的配置信息反序列化到 Conf 变量中
 if err = viper.Unmarshal(Conf); err != nil {
  fmt.Printf("viper unmarshal failed, error: %v\n", err)
  return
 }

 // 实时监控配置文件的变化 WatchConfig 开始监视配置文件的更改。
 viper.WatchConfig()
 // OnConfigChange设置配置文件更改时调用的事件处理程序。
 // 当配置文件变化之后调用的一个回调函数
 viper.OnConfigChange(func(e fsnotify.Event) {
  fmt.Println("Config file changed:", e.Name)
  if err = viper.Unmarshal(Conf); err != nil {
   fmt.Printf("viper unmarshal OnConfigChange failed, error: %v\n", err)
  }
 })

 return
}

```

logger/logger.go

```go
package logger

import (
 "gopkg.in/natefinch/lumberjack.v2"
 "net"
 "net/http"
 "net/http/httputil"
 "os"
 "runtime/debug"
 "strings"
 "time"
 "web_app2/settings"

 "github.com/gin-gonic/gin"
 "go.uber.org/zap"
 "go.uber.org/zap/zapcore"
)

func Init(cfg *settings.LogConfig) (err error) {
 writeSyncer := getLogWriter(
  cfg.Filename,
  cfg.MaxSize,
  cfg.MaxBackups,
  cfg.MaxAge,
 )
 encoder := getEncoder()
 var l = new(zapcore.Level)
 err = l.UnmarshalText([]byte(cfg.Level))
 if err != nil {
  return
 }
 // NewCore创建一个向WriteSyncer写入日志的Core。

 // A WriteSyncer is an io.Writer that can also flush any buffered data. Note
 // that *os.File (and thus, os.Stderr and os.Stdout) implement WriteSyncer.

 // LevelEnabler决定在记录消息时是否启用给定的日志级别。
 // Each concrete Level value implements a static LevelEnabler which returns
 // true for itself and all higher logging levels. For example WarnLevel.Enabled()
 // will return true for WarnLevel, ErrorLevel, DPanicLevel, PanicLevel, and
 // FatalLevel, but return false for InfoLevel and DebugLevel.
 core := zapcore.NewCore(encoder, writeSyncer, l)

 // New constructs a new Logger from the provided zapcore.Core and Options. If
 // the passed zapcore.Core is nil, it falls back to using a no-op
 // implementation.

 // AddCaller configures the Logger to annotate each message with the filename,
 // line number, and function name of zap's caller. See also WithCaller.
 logger := zap.New(core, zap.AddCaller())
 // 替换 zap 库中全局的logger
 zap.ReplaceGlobals(logger)
 return
 // Sugar封装了Logger，以提供更符合人体工程学的API，但速度略慢。糖化一个Logger的成本非常低，
 // 因此一个应用程序同时使用Loggers和SugaredLoggers是合理的，在性能敏感代码的边界上在它们之间进行转换。
 //sugarLogger = logger.Sugar()
}

func getEncoder() zapcore.Encoder {
 // NewJSONEncoder创建了一个快速、低分配的JSON编码器。编码器适当地转义所有字段键和值。
 // NewProductionEncoderConfig returns an opinionated EncoderConfig for
 // production environments.
 encoderConfig := zap.NewProductionEncoderConfig()
 encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
 encoderConfig.TimeKey = "time"
 encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder
 encoderConfig.EncodeDuration = zapcore.SecondsDurationEncoder
 encoderConfig.EncodeCaller = zapcore.ShortCallerEncoder
 return zapcore.NewJSONEncoder(encoderConfig)
}

func getLogWriter(filename string, maxSize, maxBackup, maxAge int) zapcore.WriteSyncer {
 // Logger is an io.WriteCloser that writes to the specified filename.
 // 日志记录器在第一次写入时打开或创建日志文件。如果文件存在并且小于MaxSize兆字节，则lumberjack将打开并追加该文件。
 // 如果该文件存在并且其大小为>= MaxSize兆字节，
 // 则通过将当前时间放在文件扩展名(或者如果没有扩展名则放在文件名的末尾)的名称中的时间戳中来重命名该文件。
 // 然后使用原始文件名创建一个新的日志文件。
 // 每当写操作导致当前日志文件超过MaxSize兆字节时，将关闭当前文件，重新命名，并使用原始名称创建新的日志文件。
 // 因此，您给Logger的文件名始终是“当前”日志文件。
 // 如果MaxBackups和MaxAge均为0，则不会删除旧的日志文件。
 lumberJackLogger := &lumberjack.Logger{
  // Filename是要写入日志的文件。备份日志文件将保留在同一目录下
  Filename: filename,
  // MaxSize是日志文件旋转之前的最大大小(以兆字节为单位)。默认为100兆字节。
  MaxSize: maxSize, // M
  // MaxBackups是要保留的旧日志文件的最大数量。默认是保留所有旧的日志文件(尽管MaxAge仍然可能导致它们被删除)。
  MaxBackups: maxBackup, // 备份数量
  // MaxAge是根据文件名中编码的时间戳保留旧日志文件的最大天数。
  // 请注意，一天被定义为24小时，由于夏令时、闰秒等原因，可能与日历日不完全对应。默认情况下，不根据时间删除旧的日志文件。
  MaxAge: maxAge, // 备份天数
  // Compress决定是否应该使用gzip压缩旋转的日志文件。默认情况下不执行压缩。
  Compress: false, // 是否压缩
 }

 return zapcore.AddSync(lumberJackLogger)
}

// GinLogger
func GinLogger() gin.HandlerFunc {
 return func(c *gin.Context) {
  start := time.Now()
  path := c.Request.URL.Path
  query := c.Request.URL.RawQuery
  c.Next() // 执行后续中间件

  // Since returns the time elapsed since t.
  // It is shorthand for time.Now().Sub(t).
  cost := time.Since(start)
  zap.L().Info(path,
   zap.Int("status", c.Writer.Status()),
   zap.String("method", c.Request.Method),
   zap.String("path", path),
   zap.String("query", query),
   zap.String("ip", c.ClientIP()),
   zap.String("user-agent", c.Request.UserAgent()),
   zap.String("errors", c.Errors.ByType(gin.ErrorTypePrivate).String()),
   zap.Duration("cost", cost), // 运行时间
  )
 }
}

// GinRecovery
func GinRecovery(stack bool) gin.HandlerFunc {
 return func(c *gin.Context) {
  defer func() {
   if err := recover(); err != nil {
    // Check for a broken connection, as it is not really a
    // condition that warrants a panic stack trace.
    var brokenPipe bool
    if ne, ok := err.(*net.OpError); ok {
     if se, ok := ne.Err.(*os.SyscallError); ok {
      if strings.Contains(strings.ToLower(se.Error()), "broken pipe") || strings.Contains(strings.ToLower(se.Error()), "connection reset by peer") {
       brokenPipe = true
      }
     }
    }

    httpRequest, _ := httputil.DumpRequest(c.Request, false)
    if brokenPipe {
     zap.L().Error(c.Request.URL.Path,
      zap.Any("error", err),
      zap.String("request", string(httpRequest)),
     )
     // If the connection is dead, we can't write a status to it.
     c.Error(err.(error)) // nolint: errcheck
     c.Abort()
     return
    }

    if stack {
     zap.L().Error("[Recovery from panic]",
      zap.Any("error", err),
      zap.String("request", string(httpRequest)),
      zap.String("stack", string(debug.Stack())),
     )
    } else {
     zap.L().Error("[Recovery from panic]",
      zap.Any("error", err),
      zap.String("request", string(httpRequest)),
     )
    }
    c.AbortWithStatus(http.StatusInternalServerError)
   }
  }()
  c.Next()
 }
}

```

dao/mysql/mysql.go

```go
package mysql

import (
 "fmt"
 "web_app2/settings"

 "go.uber.org/zap"

 _ "github.com/go-sql-driver/mysql" // 匿名导入 自动执行 init()
 "github.com/jmoiron/sqlx"
)

var db *sqlx.DB

func Init(cfg *settings.MySQLConfig) (err error) {
 //DSN (Data Source Name) Sprintf根据格式说明符进行格式化，并返回结果字符串。
 dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&parseTime=true",
  cfg.User,
  cfg.Password,
  cfg.Host,
  cfg.Port,
  cfg.DbName,
 )
 // 连接到数据库并使用ping进行验证。
 // 也可以使用 MustConnect MustConnect连接到数据库，并在出现错误时恐慌 panic。
 db, err = sqlx.Connect("mysql", dsn)
 if err != nil {
  zap.L().Error("connect DB failed", zap.Error(err))
  return
 }
 db.SetMaxOpenConns(cfg.MaxOpenConns) // 设置数据库的最大打开连接数。
 db.SetMaxIdleConns(cfg.MaxIdleConns) // 设置空闲连接池中的最大连接数。
 return
}

func Close() {
 _ = db.Close()
}

```

dao/redis/redis.go

```go
package redis

import (
 "context"
 "fmt"
 "github.com/redis/go-redis/v9"
 "web_app2/settings"
)

// 声明一个全局的 rdb 变量
var rdb *redis.Client

// 初始化连接
func Init(cfg *settings.RedisConfig) (err error) {
 // NewClient将客户端返回给Options指定的Redis Server。
 // Options保留设置以建立redis连接。
 rdb = redis.NewClient(&redis.Options{
  Addr:     fmt.Sprintf("%s:%d", cfg.Host, cfg.Port),
  Password: cfg.Password, // 没有密码，默认值
  DB:       cfg.DB,       // 默认DB 0 连接到服务器后要选择的数据库。
  PoolSize: cfg.PoolSize, // 最大套接字连接数。 默认情况下，每个可用CPU有10个连接，由runtime.GOMAXPROCS报告。
 })

 // Background返回一个非空的Context。它永远不会被取消，没有值，也没有截止日期。
 // 它通常由main函数、初始化和测试使用，并作为传入请求的顶级上下文
 ctx := context.Background()

 _, err = rdb.Ping(ctx).Result()
 return
}

func Close() {
 _ = rdb.Close()
}

```

routes/routes.go

```go
package routes

import (
 "github.com/gin-gonic/gin"
 "net/http"
 "web_app2/logger"
 "web_app2/settings"
)

func Setup() *gin.Engine {
 r := gin.New()
 r.Use(logger.GinLogger(), logger.GinRecovery(true))

 r.GET("/version", func(context *gin.Context) {
  context.String(http.StatusOK, settings.Conf.Version)
 })
 return r
}

```

main.go

```go
package main

import (
 "context"
 "fmt"
 "log"
 "net/http"
 "os"
 "os/signal"
 "syscall"
 "time"
 "web_app2/dao/mysql"
 "web_app2/dao/redis"
 "web_app2/logger"
 "web_app2/routes"
 "web_app2/settings"

 "go.uber.org/zap"
)

// Go Web 开发通用的脚手架模版

func main() {
 // 1. 加载配置
 if err := settings.Init(); err != nil {
  fmt.Printf("init settings failed, error: %v\n", err)
  return
 }
 // 2. 初始化日志
 if err := logger.Init(settings.Conf.LogConfig); err != nil {
  fmt.Printf("init logger failed, error: %v\n", err)
  return
 }
 defer zap.L().Sync()
 zap.L().Debug("logger initialized successfully")
 // 3. 初始化 MySQL 连接
 if err := mysql.Init(settings.Conf.MySQLConfig); err != nil {
  fmt.Printf("init mysql failed, error: %v\n", err)
  return
 }
 defer mysql.Close()
 // 4. 初始化 Redis 连接
 if err := redis.Init(settings.Conf.RedisConfig); err != nil {
  fmt.Printf("init redis failed, error: %v\n", err)
  return
 }
 defer redis.Close()
 // 5. 注册路由
 router := routes.Setup()
 // 6. 启动服务（优雅关机）
 // 服务器定义运行HTTP服务器的参数。Server的零值是一个有效的配置。
 srv := &http.Server{
  // Addr可选地以“host:port”的形式指定服务器要监听的TCP地址。如果为空，则使用“:http”(端口80)。
  // 服务名称在RFC 6335中定义，并由IANA分配
  Addr:    fmt.Sprintf(":%d", settings.Conf.Port),
  Handler: router,
 }

 go func() {
  // 开启一个goroutine启动服务，如果不用 goroutine，下面的代码 ListenAndServe 会一直接收请求，处理请求，进入无限循环。代码就不会往下执行。

  // ListenAndServe监听TCP网络地址srv.Addr，然后调用Serve来处理传入连接上的请求。接受的连接配置为使TCP能保持连接。
  // ListenAndServe always returns a non-nil error. After Shutdown or Close,
  // the returned error is ErrServerClosed.
  if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
   log.Fatalf("listen: %s\n", err) // Fatalf 相当于Printf()之后再调用os.Exit(1)。
  }
 }()

 // 等待中断信号来优雅地关闭服务器，为关闭服务器操作设置一个5秒的超时

 // make内置函数分配并初始化(仅)slice、map或chan类型的对象。
 // 与new一样，第一个参数是类型，而不是值。
 // 与new不同，make的返回类型与其参数的类型相同，而不是指向它的指针
 // Channel:通道的缓冲区用指定的缓冲区容量初始化。如果为零，或者忽略大小，则通道未被缓冲。

 // 信号 Signal 表示操作系统信号。通常的底层实现依赖于操作系统:在Unix上是syscall.Signal。
 quit := make(chan os.Signal, 1) // 创建一个接收信号的通道
 // kill 默认会发送 syscall.SIGTERM 信号
 // kill -2 发送 syscall.SIGINT 信号，Ctrl+C 就是触发系统SIGINT信号
 // kill -9 发送 syscall.SIGKILL 信号，但是不能被捕获，所以不需要添加它
 // signal.Notify把收到的 syscall.SIGINT或syscall.SIGTERM 信号转发给quit

 // Notify使包信号将传入的信号转发给c，如果没有提供信号，则将所有传入的信号转发给c，否则仅将提供的信号转发给c。
 // 包信号不会阻塞发送到c:调用者必须确保c有足够的缓冲空间来跟上预期的信号速率。对于仅用于通知一个信号值的通道，大小为1的缓冲区就足够了。
 // 允许使用同一通道多次调用Notify:每次调用都扩展发送到该通道的信号集。从集合中移除信号的唯一方法是调用Stop。
 // 允许使用不同的通道和相同的信号多次调用Notify:每个通道独立地接收传入信号的副本。
 signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM) // 此处不会阻塞
 <-quit                                               // 阻塞在此，当接收到上述两种信号时才会往下执行
 zap.L().Info("Shutdown Server ...")
 // 创建一个5秒超时的context
 ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 defer cancel()
 // 5秒内优雅关闭服务（将未处理完的请求处理完再关闭服务），超过5秒就超时退出

 // 关机将在不中断任何活动连接的情况下优雅地关闭服务器。
 // Shutdown的工作原理是首先关闭所有打开的侦听器，然后关闭所有空闲连接，然后无限期地等待连接返回空闲状态，然后关闭。
 // 如果提供的上下文在关闭完成之前过期，则shutdown返回上下文的错误，否则返回关闭服务器的底层侦听器所返回的任何错误。
 // 当Shutdown被调用时，Serve, ListenAndServe和ListenAndServeTLS会立即返回ErrServerClosed。确保程序没有退出，而是等待Shutdown返回。
 // 关闭不试图关闭或等待被劫持的连接，如WebSockets。如果需要的话，Shutdown的调用者应该单独通知这些长寿命连接关闭，并等待它们关闭。
 // 一旦在服务器上调用Shutdown，它可能不会被重用;以后对Serve等方法的调用将返回ErrServerClosed。
 if err := srv.Shutdown(ctx); err != nil {
  zap.L().Fatal("Server Shutdown", zap.Error(err))
 }

 zap.L().Info("Server exiting")
}

```

运行

```bash
Code/go/web_app2 via 🐹 v1.20.3 via 🅒 base 
➜ go run main.go 
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:   export GIN_MODE=release
 - using code:  gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /version                  --> web_app2/routes.Setup.func1 (3 handlers)


```

![](https://raw.githubusercontent.com/qiaopengjun5162/blogpicgo/master/img202306200935229.png)

### Git 提交

```bash
~/Code/go via 🐹 v1.20.3 via 🅒 base
➜ cd web_app

Code/go/web_app via 🐹 v1.20.3 via 🅒 base
➜ echo "# go_web_app" >> README.md

Code/go/web_app via 🐹 v1.20.3 via 🅒 base
➜ git init
提示：使用 'master' 作为初始分支的名称。这个默认分支名称可能会更改。要在新仓库中
提示：配置使用初始分支名，并消除这条警告，请执行：
提示：
提示： git config --global init.defaultBranch <名称>
提示：
提示：除了 'master' 之外，通常选定的名字有 'main'、'trunk' 和 'development'。
提示：可以通过以下命令重命名刚创建的分支：
提示：
提示： git branch -m <name>
已初始化空的 Git 仓库于 /Users/qiaopengjun/Code/go/web_app/.git/

web_app on  master [?] via 🐹 v1.20.3 via 🅒 base
➜ git add .

web_app on  master [+] via 🐹 v1.20.3 via 🅒 base
➜ git commit -m "first commit"
[master（根提交） 6b90b06] first commit
 17 files changed, 1598 insertions(+)
 create mode 100644 .idea/.gitignore
 create mode 100644 .idea/dbnavigator.xml
 create mode 100644 .idea/modules.xml
 create mode 100644 .idea/watcherTasks.xml
 create mode 100644 .idea/web_app.iml
 create mode 100644 README.md
 create mode 100644 config.yaml
 create mode 100644 dao/mysql/mysql.go
 create mode 100644 dao/redis/redis.go
 create mode 100644 go.mod
 create mode 100644 go.sum
 create mode 100644 logger/logger.go
 create mode 100644 main.go
 create mode 100644 routes/routes.go
 create mode 100644 settings/settings.go
 create mode 100755 web_app
 create mode 100644 web_app.log

web_app on  master via 🐹 v1.20.3 via 🅒 base
➜ git branch -M main
# go_web_app

web_app on  main via 🐹 v1.20.3 via 🅒 base
➜ git remote add origin git@github.com:qiaopengjun5162/go_web_app.git

web_app on  main via 🐹 v1.20.3 via 🅒 base
➜ git push -u origin main
枚举对象中: 26, 完成.
对象计数中: 100% (26/26), 完成.
使用 12 个线程进行压缩
压缩对象中: 100% (20/20), 完成.
写入对象中: 100% (26/26), 6.68 MiB | 467.00 KiB/s, 完成.
总共 26（差异 0），复用 0（差异 0），包复用 0
To github.com:qiaopengjun5162/go_web_app.git
 * [new branch]      main -> main
分支 'main' 设置为跟踪 'origin/main'。


web_app on  main via 🐹 v1.20.3 via 🅒 base
# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gi➜ vim README.md

web_app on  main [!] via 🐹 v1.20.3 via 🅒 base took 32.0s
➜ ga

web_app on  main [+] via 🐹 v1.20.3 via 🅒 base
➜ git commit -m "update readme"
[main 9f5b231] update readme
 1 file changed, 1 insertion(+)

web_app on  main [⇡] via 🐹 v1.20.3 via 🅒 base
➜ gp
枚举对象中: 5, 完成.
对象计数中: 100% (5/5), 完成.
使用 12 个线程进行压缩
压缩对象中: 100% (3/3), 完成.
写入对象中: 100% (3/3), 329 字节 | 329.00 KiB/s, 完成.
总共 3（差异 1），复用 0（差异 0），包复用 0
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To github.com:qiaopengjun5162/go_web_app.git
   6b90b06..9f5b231  main -> main

web_app on  main via 🐹 v1.20.3 via 🅒 base took 4.1s
➜ vim .gitignore

web_app on  main [?] via 🐹 v1.20.3 via 🅒 base took 48.1s
➜ ga

web_app on  main [+] via 🐹 v1.20.3 via 🅒 base
➜ git commit -m "add gitignore"
[main 827e99b] add gitignore
 1 file changed, 23 insertions(+)
 create mode 100644 .gitignore

web_app on  main [⇡] via 🐹 v1.20.3 via 🅒 base
➜ gp
枚举对象中: 4, 完成.
对象计数中: 100% (4/4), 完成.
使用 12 个线程进行压缩
压缩对象中: 100% (3/3), 完成.
写入对象中: 100% (3/3), 586 字节 | 586.00 KiB/s, 完成.
总共 3（差异 1），复用 0（差异 0），包复用 0
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To github.com:qiaopengjun5162/go_web_app.git
   9f5b231..827e99b  main -> main



# web_app2
Code/go/web_app2 via 🐹 v1.20.3 via 🅒 base
➜ git init
提示：使用 'master' 作为初始分支的名称。这个默认分支名称可能会更改。要在新仓库中
提示：配置使用初始分支名，并消除这条警告，请执行：
提示：
提示： git config --global init.defaultBranch <名称>
提示：
提示：除了 'master' 之外，通常选定的名字有 'main'、'trunk' 和 'development'。
提示：可以通过以下命令重命名刚创建的分支：
提示：
提示： git branch -m <name>
已初始化空的 Git 仓库于 /Users/qiaopengjun/Code/go/web_app2/.git/

web_app2 on  master [?] via 🐹 v1.20.3 via 🅒 base
➜ git add .

web_app2 on  master [+] via 🐹 v1.20.3 via 🅒 base
➜ git commit -m "first commit"
[master（根提交） 00dd14d] first commit
 15 files changed, 1597 insertions(+)
 create mode 100644 .idea/.gitignore
 create mode 100644 .idea/dbnavigator.xml
 create mode 100644 .idea/modules.xml
 create mode 100644 .idea/web_app2.iml
 create mode 100644 config.yaml
 create mode 100644 dao/mysql/mysql.go
 create mode 100644 dao/redis/redis.go
 create mode 100644 go.mod
 create mode 100644 go.sum
 create mode 100644 logger/logger.go
 create mode 100644 main.go
 create mode 100644 routes/routes.go
 create mode 100644 settings/settings.go
 create mode 100644 web_app.log
 create mode 100755 web_app2

web_app2 on  master via 🐹 v1.20.3 via 🅒 base
➜ git remote add origin git@github.com:qiaopengjun5162/go_web_app2.git

web_app2 on  master via 🐹 v1.20.3 via 🅒 base
➜ git push -u origin main
错误：源引用规格 main 没有匹配
错误：无法推送一些引用到 'github.com:qiaopengjun5162/go_web_app2.git'

web_app2 on  master via 🐹 v1.20.3 via 🅒 base
➜ git branch -M main

web_app2 on  main via 🐹 v1.20.3 via 🅒 base
➜ git push -u origin main
To github.com:qiaopengjun5162/go_web_app2.git
 ! [rejected]        main -> main (fetch first)
错误：无法推送一些引用到 'github.com:qiaopengjun5162/go_web_app2.git'
提示：更新被拒绝，因为远程仓库包含您本地尚不存在的提交。这通常是因为另外
提示：一个仓库已向该引用进行了推送。再次推送前，您可能需要先整合远程变更
提示：（如 'git pull ...'）。
提示：详见 'git push --help' 中的 'Note about fast-forwards' 小节。

...

web_app2 on  main via 🐹 v1.20.3 via 🅒 base
➜ git push -u origin main
To github.com:qiaopengjun5162/go_web_app2.git
 ! [rejected]        main -> main (non-fast-forward)
错误：无法推送一些引用到 'github.com:qiaopengjun5162/go_web_app2.git'
提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。
提示：再次推送前，先与远程变更合并（如 'git pull ...'）。详见
提示：'git push --help' 中的 'Note about fast-forwards' 小节。

web_app2 on  main via 🐹 v1.20.3 via 🅒 base took 4.1s
➜ git fetch origin

web_app2 on  main via 🐹 v1.20.3 via 🅒 base took 4.1s
➜ git merge origin/main
致命错误：拒绝合并无关的历史

web_app2 on  main via 🐹 v1.20.3 via 🅒 base
➜ git pull origin main  --allow-unrelated-histories
来自 github.com:qiaopengjun5162/go_web_app2
 * branch            main       -> FETCH_HEAD
Merge made by the 'ort' strategy.
 .gitignore | 21 +++++++++++++++++++++
 LICENSE    | 21 +++++++++++++++++++++
 README.md  |  2 ++
 3 files changed, 44 insertions(+)
 create mode 100644 .gitignore
 create mode 100644 LICENSE
 create mode 100644 README.md

web_app2 on  main via 🐹 v1.20.3 via 🅒 base took 1m 37.5s
➜ git push -u origin main
枚举对象中: 27, 完成.
对象计数中: 100% (27/27), 完成.
使用 12 个线程进行压缩
压缩对象中: 100% (21/21), 完成.
写入对象中: 100% (26/26), 6.75 MiB | 681.00 KiB/s, 完成.
总共 26（差异 1），复用 0（差异 0），包复用 0
remote: Resolving deltas: 100% (1/1), done.
To github.com:qiaopengjun5162/go_web_app2.git
   62e4da1..e023f0b  main -> main
分支 'main' 设置为跟踪 'origin/main'。

web_app2 on  main via 🐹 v1.20.3 via 🅒 base took 14.4s
➜
```

### 通过命令行程序获取配置文件的路径

问题：目前只能在可执行文件所在项目目录下执行

```bash
web_app2 on  main via 🐹 v1.20.3 via 🅒 base 
➜ ./web_app2 
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:   export GIN_MODE=release
 - using code:  gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /version                  --> web_app2/routes.Setup.func1 (3 handlers)
^C%                                                                                                                                                                                                                                  
web_app2 on  main [!] via 🐹 v1.20.3 via 🅒 base took 7.6s 
➜ cd ..    

~/Code/go via 🐹 v1.20.3 via 🅒 base 
➜ web_app2/web_app2 
viper.ReadInConfig failed, error: Config File "config" Not Found in "[/Users/qiaopengjun/Code/go]"
init settings failed, error: Config File "config" Not Found in "[/Users/qiaopengjun/Code/go]"

~/Code/go via 🐹 v1.20.3 via 🅒 base 

```

web_app2/web_app2  执行，viper 读取配置文件失败，找不到配置文件。

#### 使用 os.Args 优化修改

settings.go

```go
package settings

import (
 "fmt"

 "github.com/fsnotify/fsnotify"
 "github.com/spf13/viper"
)

// Conf 全局变量，用来保存程序的所有配置信息
var Conf = new(AppConfig)

type AppConfig struct {
 Name    string `mapstructure:"name"`
 Mode    string `mapstructure:"mode"`
 Version string `mapstructure:"version"`
 Port    int    `mapstructure:"port"`

 *LogConfig   `mapstructure:"log"`
 *MySQLConfig `mapstructure:"mysql"`
 *RedisConfig `mapstructure:"redis"`
}

type LogConfig struct {
 Level      string `mapstructure:"level"`
 Filename   string `mapstructure:"filename"`
 MaxSize    int    `mapstructure:"max_size"`
 MaxAge     int    `mapstructure:"max_age"`
 MaxBackups int    `mapstructure:"max_backups"`
}

type MySQLConfig struct {
 Host         string `mapstructure:"host"`
 User         string `mapstructure:"user"`
 Password     string `mapstructure:"password"`
 DbName       string `mapstructure:"db_name"`
 Port         int    `mapstructure:"port"`
 MaxOpenConns int    `mapstructure:"max_open_conns"`
 MaxIdleConns int    `mapstructure:"max_idle_conns"`
}

type RedisConfig struct {
 Host     string `mapstructure:"host"`
 Password string `mapstructure:"password"`
 Port     int    `matstructure:"port"`
 DB       int    `mapstructure:"db"`
 PoolSize int    `mapstructure:"pool_size"`
}

func Init(filePath string) (err error) {
 // 方式1：直接指定配置文件路径（相对路径或者绝对路径）
 // 相对路径：相对执行的可执行文件的相对路径
 // viper.SetConfigFile("./conf/config.yaml")
 // 绝对路径：系统中实际的文件路径
 // viper.SetConfigFile("/Users/qiaopengjun/Desktop/web_app2 /conf/config.yaml")

 // 方式2：指定配置文件名和配置文件的位置，viper 自行查找可用的配置文件
 // 配置文件名不需要带后缀
 // 配置文件位置可配置多个
 // 注意：viper 是根据文件名查找，配置目录里不要有同名的配置文件。
 // 例如：在配置目录 ./conf 中不要同时存在 config.yaml、config.json

 // 读取配置文件
 viper.SetConfigFile(filePath) // 指定配置文件路径
 //viper.SetConfigName("config")        // 配置文件名称(无扩展名)
 //viper.AddConfigPath(".")             // 指定查找配置文件的路径（这里使用相对路径）可以配置多个
 //viper.AddConfigPath("./conf")        // 指定查找配置文件的路径（这里使用相对路径）可以配置多个
 // SetConfigType设置远端源返回的配置类型，例如:“json”。
 // 基本上是配合远程配置中心使用的，告诉viper 当前的数据使用什么格式去解析
 //viper.SetConfigType("yaml")

 err = viper.ReadInConfig() // 查找并读取配置文件
 if err != nil {            // 处理读取配置文件的错误
  fmt.Printf("viper.ReadInConfig failed, error: %v\n", err)
  return
 }

 // 把读取到的配置信息反序列化到 Conf 变量中
 if err = viper.Unmarshal(Conf); err != nil {
  fmt.Printf("viper unmarshal failed, error: %v\n", err)
  return
 }

 // 实时监控配置文件的变化 WatchConfig 开始监视配置文件的更改。
 viper.WatchConfig()
 // OnConfigChange设置配置文件更改时调用的事件处理程序。
 // 当配置文件变化之后调用的一个回调函数
 viper.OnConfigChange(func(e fsnotify.Event) {
  fmt.Println("Config file changed:", e.Name)
  if err = viper.Unmarshal(Conf); err != nil {
   fmt.Printf("viper unmarshal OnConfigChange failed, error: %v\n", err)
  }
 })

 return
}

```

main.go

```go
package main

import (
 "context"
 "fmt"
 "log"
 "net/http"
 "os"
 "os/signal"
 "syscall"
 "time"
 "web_app2/dao/mysql"
 "web_app2/dao/redis"
 "web_app2/logger"
 "web_app2/routes"
 "web_app2/settings"

 "go.uber.org/zap"
)

// Go Web 开发通用的脚手架模版

func main() {
 if len(os.Args) < 2 {
  fmt.Println("please need config file.eg: web_app2 config.yaml")
  return
 }
 // 1. 加载配置
 if err := settings.Init(os.Args[1]); err != nil {
  fmt.Printf("init settings failed, error: %v\n", err)
  return
 }
 // 2. 初始化日志
 if err := logger.Init(settings.Conf.LogConfig); err != nil {
  fmt.Printf("init logger failed, error: %v\n", err)
  return
 }
 defer zap.L().Sync()
 zap.L().Debug("logger initialized successfully")
 // 3. 初始化 MySQL 连接
 if err := mysql.Init(settings.Conf.MySQLConfig); err != nil {
  fmt.Printf("init mysql failed, error: %v\n", err)
  return
 }
 defer mysql.Close()
 // 4. 初始化 Redis 连接
 if err := redis.Init(settings.Conf.RedisConfig); err != nil {
  fmt.Printf("init redis failed, error: %v\n", err)
  return
 }
 defer redis.Close()
 // 5. 注册路由
 router := routes.Setup()
 // 6. 启动服务（优雅关机）
 // 服务器定义运行HTTP服务器的参数。Server的零值是一个有效的配置。
 srv := &http.Server{
  // Addr可选地以“host:port”的形式指定服务器要监听的TCP地址。如果为空，则使用“:http”(端口80)。
  // 服务名称在RFC 6335中定义，并由IANA分配
  Addr:    fmt.Sprintf(":%d", settings.Conf.Port),
  Handler: router,
 }

 go func() {
  // 开启一个goroutine启动服务，如果不用 goroutine，下面的代码 ListenAndServe 会一直接收请求，处理请求，进入无限循环。代码就不会往下执行。

  // ListenAndServe监听TCP网络地址srv.Addr，然后调用Serve来处理传入连接上的请求。接受的连接配置为使TCP能保持连接。
  // ListenAndServe always returns a non-nil error. After Shutdown or Close,
  // the returned error is ErrServerClosed.
  if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
   log.Fatalf("listen: %s\n", err) // Fatalf 相当于Printf()之后再调用os.Exit(1)。
  }
 }()

 // 等待中断信号来优雅地关闭服务器，为关闭服务器操作设置一个5秒的超时

 // make内置函数分配并初始化(仅)slice、map或chan类型的对象。
 // 与new一样，第一个参数是类型，而不是值。
 // 与new不同，make的返回类型与其参数的类型相同，而不是指向它的指针
 // Channel:通道的缓冲区用指定的缓冲区容量初始化。如果为零，或者忽略大小，则通道未被缓冲。

 // 信号 Signal 表示操作系统信号。通常的底层实现依赖于操作系统:在Unix上是syscall.Signal。
 quit := make(chan os.Signal, 1) // 创建一个接收信号的通道
 // kill 默认会发送 syscall.SIGTERM 信号
 // kill -2 发送 syscall.SIGINT 信号，Ctrl+C 就是触发系统SIGINT信号
 // kill -9 发送 syscall.SIGKILL 信号，但是不能被捕获，所以不需要添加它
 // signal.Notify把收到的 syscall.SIGINT或syscall.SIGTERM 信号转发给quit

 // Notify使包信号将传入的信号转发给c，如果没有提供信号，则将所有传入的信号转发给c，否则仅将提供的信号转发给c。
 // 包信号不会阻塞发送到c:调用者必须确保c有足够的缓冲空间来跟上预期的信号速率。对于仅用于通知一个信号值的通道，大小为1的缓冲区就足够了。
 // 允许使用同一通道多次调用Notify:每次调用都扩展发送到该通道的信号集。从集合中移除信号的唯一方法是调用Stop。
 // 允许使用不同的通道和相同的信号多次调用Notify:每个通道独立地接收传入信号的副本。
 signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM) // 此处不会阻塞
 <-quit                                               // 阻塞在此，当接收到上述两种信号时才会往下执行
 zap.L().Info("Shutdown Server ...")
 // 创建一个5秒超时的context
 ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 defer cancel()
 // 5秒内优雅关闭服务（将未处理完的请求处理完再关闭服务），超过5秒就超时退出

 // 关机将在不中断任何活动连接的情况下优雅地关闭服务器。
 // Shutdown的工作原理是首先关闭所有打开的侦听器，然后关闭所有空闲连接，然后无限期地等待连接返回空闲状态，然后关闭。
 // 如果提供的上下文在关闭完成之前过期，则shutdown返回上下文的错误，否则返回关闭服务器的底层侦听器所返回的任何错误。
 // 当Shutdown被调用时，Serve, ListenAndServe和ListenAndServeTLS会立即返回ErrServerClosed。确保程序没有退出，而是等待Shutdown返回。
 // 关闭不试图关闭或等待被劫持的连接，如WebSockets。如果需要的话，Shutdown的调用者应该单独通知这些长寿命连接关闭，并等待它们关闭。
 // 一旦在服务器上调用Shutdown，它可能不会被重用;以后对Serve等方法的调用将返回ErrServerClosed。
 if err := srv.Shutdown(ctx); err != nil {
  zap.L().Fatal("Server Shutdown", zap.Error(err))
 }

 zap.L().Info("Server exiting")
}

```

运行

```bash
web_app2 on  main [!] via 🐹 v1.20.3 via 🅒 base 
➜ go build

web_app2 on  main [!] via 🐹 v1.20.3 via 🅒 base 
➜ ./web_app2 
please need config file.eg: web_app2 config.yaml

web_app2 on  main [!] via 🐹 v1.20.3 via 🅒 base 
➜ ./web_app2 config.yaml 
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:   export GIN_MODE=release
 - using code:  gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /version                  --> web_app2/routes.Setup.func1 (3 handlers)

~/Code/go via 🐹 v1.20.3 via 🅒 base 
➜ web_app2/web_app2 web_app2/config.yaml 
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:   export GIN_MODE=release
 - using code:  gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /version                  --> web_app2/routes.Setup.func1 (3 handlers)


```

#### 使用 flag包 优化修改

main.go

```go
package main

import (
 "context"
 "flag"
 "fmt"
 "log"
 "net/http"
 "os"
 "os/signal"
 "syscall"
 "time"
 "web_app2/dao/mysql"
 "web_app2/dao/redis"
 "web_app2/logger"
 "web_app2/routes"
 "web_app2/settings"

 "go.uber.org/zap"
)

// Go Web 开发通用的脚手架模版

func main() {
 filename := flag.String("filename", "config.yaml", "config file")
 // 解析命令行参数
 flag.Parse()
 fmt.Println(*filename)
 //返回命令行参数后的其他参数
 fmt.Println(flag.Args())
 //返回命令行参数后的其他参数个数
 fmt.Println("NArg", flag.NArg())
 //返回使用的命令行参数个数
 fmt.Println("NFlag", flag.NFlag())
 if flag.NArg() != 1 || flag.NArg() != 1 {
  fmt.Println("please need config file.eg: web_app2 config.yaml")
  return
 }
 // 1. 加载配置
 if err := settings.Init(*filename); err != nil {
  fmt.Printf("init settings failed, error: %v\n", err)
  return
 }
 // 2. 初始化日志
 if err := logger.Init(settings.Conf.LogConfig); err != nil {
  fmt.Printf("init logger failed, error: %v\n", err)
  return
 }
 defer zap.L().Sync()
 zap.L().Debug("logger initialized successfully")
 // 3. 初始化 MySQL 连接
 if err := mysql.Init(settings.Conf.MySQLConfig); err != nil {
  fmt.Printf("init mysql failed, error: %v\n", err)
  return
 }
 defer mysql.Close()
 // 4. 初始化 Redis 连接
 if err := redis.Init(settings.Conf.RedisConfig); err != nil {
  fmt.Printf("init redis failed, error: %v\n", err)
  return
 }
 defer redis.Close()
 // 5. 注册路由
 router := routes.Setup()
 // 6. 启动服务（优雅关机）
 // 服务器定义运行HTTP服务器的参数。Server的零值是一个有效的配置。
 srv := &http.Server{
  // Addr可选地以“host:port”的形式指定服务器要监听的TCP地址。如果为空，则使用“:http”(端口80)。
  // 服务名称在RFC 6335中定义，并由IANA分配
  Addr:    fmt.Sprintf(":%d", settings.Conf.Port),
  Handler: router,
 }

 go func() {
  // 开启一个goroutine启动服务，如果不用 goroutine，下面的代码 ListenAndServe 会一直接收请求，处理请求，进入无限循环。代码就不会往下执行。

  // ListenAndServe监听TCP网络地址srv.Addr，然后调用Serve来处理传入连接上的请求。接受的连接配置为使TCP能保持连接。
  // ListenAndServe always returns a non-nil error. After Shutdown or Close,
  // the returned error is ErrServerClosed.
  if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
   log.Fatalf("listen: %s\n", err) // Fatalf 相当于Printf()之后再调用os.Exit(1)。
  }
 }()

 // 等待中断信号来优雅地关闭服务器，为关闭服务器操作设置一个5秒的超时

 // make内置函数分配并初始化(仅)slice、map或chan类型的对象。
 // 与new一样，第一个参数是类型，而不是值。
 // 与new不同，make的返回类型与其参数的类型相同，而不是指向它的指针
 // Channel:通道的缓冲区用指定的缓冲区容量初始化。如果为零，或者忽略大小，则通道未被缓冲。

 // 信号 Signal 表示操作系统信号。通常的底层实现依赖于操作系统:在Unix上是syscall.Signal。
 quit := make(chan os.Signal, 1) // 创建一个接收信号的通道
 // kill 默认会发送 syscall.SIGTERM 信号
 // kill -2 发送 syscall.SIGINT 信号，Ctrl+C 就是触发系统SIGINT信号
 // kill -9 发送 syscall.SIGKILL 信号，但是不能被捕获，所以不需要添加它
 // signal.Notify把收到的 syscall.SIGINT或syscall.SIGTERM 信号转发给quit

 // Notify使包信号将传入的信号转发给c，如果没有提供信号，则将所有传入的信号转发给c，否则仅将提供的信号转发给c。
 // 包信号不会阻塞发送到c:调用者必须确保c有足够的缓冲空间来跟上预期的信号速率。对于仅用于通知一个信号值的通道，大小为1的缓冲区就足够了。
 // 允许使用同一通道多次调用Notify:每次调用都扩展发送到该通道的信号集。从集合中移除信号的唯一方法是调用Stop。
 // 允许使用不同的通道和相同的信号多次调用Notify:每个通道独立地接收传入信号的副本。
 signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM) // 此处不会阻塞
 <-quit                                               // 阻塞在此，当接收到上述两种信号时才会往下执行
 zap.L().Info("Shutdown Server ...")
 // 创建一个5秒超时的context
 ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 defer cancel()
 // 5秒内优雅关闭服务（将未处理完的请求处理完再关闭服务），超过5秒就超时退出

 // 关机将在不中断任何活动连接的情况下优雅地关闭服务器。
 // Shutdown的工作原理是首先关闭所有打开的侦听器，然后关闭所有空闲连接，然后无限期地等待连接返回空闲状态，然后关闭。
 // 如果提供的上下文在关闭完成之前过期，则shutdown返回上下文的错误，否则返回关闭服务器的底层侦听器所返回的任何错误。
 // 当Shutdown被调用时，Serve, ListenAndServe和ListenAndServeTLS会立即返回ErrServerClosed。确保程序没有退出，而是等待Shutdown返回。
 // 关闭不试图关闭或等待被劫持的连接，如WebSockets。如果需要的话，Shutdown的调用者应该单独通知这些长寿命连接关闭，并等待它们关闭。
 // 一旦在服务器上调用Shutdown，它可能不会被重用;以后对Serve等方法的调用将返回ErrServerClosed。
 if err := srv.Shutdown(ctx); err != nil {
  zap.L().Fatal("Server Shutdown", zap.Error(err))
 }

 zap.L().Info("Server exiting")
}

```

运行

```bash
web_app2 on  main [!] via 🐹 v1.20.3 via 🅒 base 
➜ go build                        

web_app2 on  main [!] via 🐹 v1.20.3 via 🅒 base 
➜ ./web_app2 -filename config.yaml
config.yaml
[]
NArg 0
NFlag 1
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:   export GIN_MODE=release
 - using code:  gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /version                  --> web_app2/routes.Setup.func1 (3 handlers)
^C%                                                                                                                                                                                                                                  
web_app2 on  main [!] via 🐹 v1.20.3 via 🅒 base took 17.8s 
➜ ./web_app2 -filename=config.yaml
config.yaml
[]
NArg 0
NFlag 1
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:   export GIN_MODE=release
 - using code:  gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /version                  --> web_app2/routes.Setup.func1 (3 handlers)
^C%                                                                                                                                                                                                                                  
web_app2 on  main [!] via 🐹 v1.20.3 via 🅒 base took 9.2s 
➜ ./web_app2 --filename=config.yaml
config.yaml
[]
NArg 0
NFlag 1
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:   export GIN_MODE=release
 - using code:  gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /version                  --> web_app2/routes.Setup.func1 (3 handlers)
^C%                                                                                                                                                                                                                                  
web_app2 on  main [!] via 🐹 v1.20.3 via 🅒 base took 3.8s 
➜ ./web_app2 --filename config.yaml
config.yaml
[]
NArg 0
NFlag 1
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:   export GIN_MODE=release
 - using code:  gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /version                  --> web_app2/routes.Setup.func1 (3 handlers)
^C%                                                                                                                                                                                                                                  
web_app2 on  main [!] via 🐹 v1.20.3 via 🅒 base took 2.7s 
➜ ./web_app2 config.yaml           
config.yaml
[config.yaml]
NArg 1
NFlag 0
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:   export GIN_MODE=release
 - using code:  gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /version                  --> web_app2/routes.Setup.func1 (3 handlers)


```

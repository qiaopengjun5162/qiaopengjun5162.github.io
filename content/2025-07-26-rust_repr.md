+++
title = "Rust 内存布局深度解析：从对齐、填充到 repr 属性"
description = "本文深度解析Rust的内存布局机制。从数据对齐与填充的基本原理讲起，系统阐述了repr(C)、repr(Rust)、repr(packed)等属性如何精确控制结构体内存表示，以优化性能、兼容C语言或节省空间。最后探讨了动态大小类型（DST）与宽指针的内存模型，帮助开发者掌控底层细节。"
date = 2025-07-26T06:51:57Z
[taxonomies]
categories = ["Rust"]
tags = ["Rust"]
+++

<!-- more -->

# Rust 内存布局深度解析：从对齐、填充到 repr 属性

Rust 以其内存安全和高性能而著称，但要真正发挥其潜力、编写出极致高效且能与其他语言无缝交互的代码，理解其底层的内存模型至关重要。一个值在内存中如何表示？为什么 struct 的内存占用可能比其所有字段大小之和还大？我们又该如何精确控制类型的内存布局以实现特定目标？

本文旨在深度剖析 Rust 中的类型内存表示机制。我们将从最基本的内存对齐（Alignment）和填充（Padding）规则出发，详细探讨 Rust 如何通过 repr 属性——如 repr(C)、repr(Rust)、repr(packed)等——为开发者提供控制内存布局的强大能力，并最终揭示动态大小类型（DST）和宽指针背后的内存秘密。

## 内存中的类型

### 内存中的类型

- 每个 Rust 值都有类型：
  - 一个基本职责：告诉你如何解释内存中的 bits
  - 例如：0b10111101 这串 bit 本身不代表什么
    - 按 u8 类型解释：数字 189
    - 按 i8 类型解释：数字 -67
- 当自定义类型时：编译器决定该类型的各部分在内存表示中的位置

### 对齐（Alignment）

- 对齐（Alignment）：决定了类型的字节可以被存在哪
- 实际上，计算机硬件对给定的类型可以存放的位置是有约束的
  - 例如：指针指向字节（bytes）而不是位（bits）
    - 如果将某类型 T 的值放在计算机内存中的索引为 4 的位（bit）上，那就无法引用它的地址。你只能创建一个指针指向 byte 0 或者 byte 1
- 所有的值（无论什么类型），都必须开始于 byte 的边界
  - 必须至少是字节对齐（byte-aligned）
  - 存放的地址必须是 8 bits 的倍数

### 更严格的对齐规则

- 一些类型的对齐规则比字节对齐还严格：
  - 在 CPU 和内存系统里，内存经常按大于单个 byte 的块进行访问
    - 例如：在 64 位 CPU 上，大部分的值是按 8 bytes 的块进行访问的，每个操作都开始于 “8 bytes 对齐” 的地址上。（这也叫做 CPU 的字长，word size）
    - CPU 有办法处理更小值的读写，以及跨域边界的值
- 应该尽可能的保证硬件可以操作于它的“原生（native）”对齐
  - 例如：想读取的 i64 的值开始于 8 bytes 块的中间...

### 没对齐的操作

- 对数据进行没对齐操作叫做 “misaligned access"：
  - 可导致 性能低 和 并发问题
- 很多 CPU 操作多要求或强烈建议：它们的参数是自然对齐的（naturally aligned）
- 自然对齐的值：对齐匹配值的大小
  - 例如：加载 8 bytes，那么提供的地址就需要 8 bytes 对齐

### 编译器会尽可能利用对齐

- 基于类型包含的内容，编译器通过计算，为类型分配一个对齐（安排它如何对齐）
- 内置值，通常对齐到他们的大小
  - u8 - byte 对齐；u16 - 2 bytes 对齐；u32 - 4 bytes 对齐； u64 - 8 bytes 对齐
- 复杂类型（包含其它类型的类似），通常被赋予所含类型的最大对齐：
  - 例：某类型含有 u8、u16、u32，那么该类型就应该是 4 bytes 对齐

### 布局（Layout）

- 类型的布局（Layout）：（编译器如何决定）类型的内存中表示
- Rust 编译器对于类型如何布局，并没有给出多少保证
- Rust 提供了 repr 属性（attribute）：
  - 可以添加到你类型的定义上，来请求特定内存表示

### repr(C)

- 最常见的一个是 repr(C)：布局方式与 C、C++ 编译器对同类型的布局兼容
  - 对于使用 FFI 与其它语言交互的 Rust 代码很有用
  - Rust 会生成一个匹配其他语言编译器期望的布局
- 因为 C 布局可预测、不易改变
  - 在 unsafe 上下文中有用：
    - 使用指向该类型的原始指针
    - 在两个具有相同字段的类型间进行转换

### repr(transparent)

- repr(transparent)：仅能用于只含有单个字段的类型，它保证了外层类型的布局与内层类型一样
  - 这与 ”newtype“ 模式结合很好用
    - 例如：你想操作于 struct A 和 struct New(A) 内存表示，就如同他们是一样的
    - newtype 模式：在 tuple struct 里创建一个新的类型，只有一个字段，针对某型的薄封装

### 例子

| 代码         | 字段类型的大小 | 默认内存表示 | 填充    | 最终对齐               |
| ------------ | -------------- | ------------ | ------- | ---------------------- |
| #[repr(C)]   |                |              |         |                        |
| struct Foo { |                |              |         |                        |
| tiny: bool,  | 1 bit          | 1 byte 对齐  | 3 bytes | 4bytes                 |
| normal: u32, | 4 bytes        | 4 bytes 对齐 |         | 4 bytes 与上共 8 bytes |
| small: u8,   | 1 byte         | 1 byte 对齐  | 7 bytes | 8 bytes                |
| long: u64,   | 8 bytes        | 8 bytes 对齐 |         | 8 bytes                |
| short: u16,  | 2 bytes        | 2 bytes 对齐 | 6 bytes | 8 bytes                |
| }            |                |              | 一共    | 32 bytes               |

### repr(Rust)

- C 表示的限制：需要将所有字段按原 struct 定义的顺序放置
- repr(Rust) 去掉了该限制以及其它几个较小的限制：
  - 对恰好具有相同字段的类型的确定性字段排序
    - 两个不同类型的字段相同，字段类型也相同，定义顺序也一样
    - 在 Rust 里，如果使用 repr(Rust)，就不能保证这两种类型的布局是一样的
- repr(Rust) 允许重新对字段排序：
  - 可按大小递减的顺序排列（对于 Foo 例子来说就不需要填充了）
- 对布局的保证少了，编译器有余地进行重新安排，产生高效代码

### 例子

| 代码         | 字段类型的大小 | 默认内存表示 | 填充 | 最终对齐                  |
| ------------ | -------------- | ------------ | ---- | ------------------------- |
| #[repr(C)]   |                |              |      |                           |
| struct Foo { |                |              |      |                           |
| long: u64,   | 8 bytes        | 8 bytes 对齐 |      | 8 bytes                   |
| normal: u32, | 4 bytes        | 4 bytes 对齐 |      |                           |
| short: u16,  | 2 bytes        | 2 bytes 对齐 |      |                           |
| small: u8,   | 1 byte         | 1 byte 对齐  |      |                           |
| tiny: bool,  | 1 bit          | 1 byte 对齐  |      | 以上 3 个字段一共 8 bytes |
| }            |                |              | 一共 | 16 bytes                  |

### 无填充布局

- 可以告诉编译器字段之间无需任何填充：
  - 承担不对齐访问的性能损失
  - 使用场景举例：
    - 内存有限，类型实例较多
    - 通常低带宽网络连接发送内存表示
- 启用该功能：在你类型上添加 #[repr(packed)] 注解
- 注意：
  - 可能会导致代码运行速度慢；
  - 极端情况下，如果 CPU 仅支持对齐操作，可导致程序崩溃

### 给特定字段或类型更大的对齐

- 使用 #[repr(align(n))]
  - 例如：保证在内存中连续（相邻）存储（就像数组）的不同值最终位于 CPU 上不同的缓存行上，就可以避免伪共享（false sharing）
    - 缓存是由缓存行组成的，缓存都是以缓存行作为一个单位来处理的；缓存行（cache line）是可以映射到缓存中的最小数据部分
    - 伪共享（false sharing）：两个不同的 CPU 访问共享同一个缓存行的不同变量时，就发生了伪共享。理论上它们可以并行操作，但最终它们都争相更新缓存中的同一个条目。它可导致并发类程序中的巨大性能降级。

### 复杂类型的内存表示

- 元组（Tuple）：就像 struct，其字段类型与元组元素类型按顺序相同
- 数组：所包含类型的连续序列，元素间没有填充
- Union：对于每个变体来说，其布局的选择是独立的；对齐就是所有变体里最大的那个。
- 枚举：和 Union 一样，额外有一个隐藏的共享字段，用于存储枚举变体的鉴别符
  - 代码用鉴别符的值来判定给定值所含的是哪个变体
  - 鉴别符的大小取决于变体的数量

### 动态大小的类型和宽指针

- Rust 中大多数类型自动实现了 Sized：
  - 它的大小在编译时就已知了
- 两个常见的类型除外：Trait 对象、切片（slice）
  - 例如：dyn Iterator、[u8]等（DST：dynamically sized types）的大小在运行时才能确定
- 问题：通常编译器需要知道东西的大小来产生合理的代码：
  - 例如为 tuple 分配多大空间，或者访问第四个元素时需要多少偏移量
  - 如果类型不是 Sized，上述信息就无法获得

### 编译器需要 Sized 类型

- 几乎在所有地方，编译器都需要 Sized 类型：
  - struct 字段、函数参数、返回值、变量、数组类型都必须 Sized
  - 自定义的 Type Bound 自动包含 T: Sized，除非你写明 T:?Sized
- 但例如当函数需要接收 DST（例如：trait 对象、切片 等）作为参数时怎么办？
  - 可以使用宽指针（wide pointer 或叫 fat pointer）

### 宽指针（Wide Pointer）

- 通过将非 Sized 类型放在宽指针后边，就可弥补 Sized 和非 Sized 类型 间的差距
- 宽指针：
  - 就是普通指针
  - 附加了一个”字大小（word-sized）“的字段
    - 它可以提供给编译器所需要的关于指针的额外信息：生产使用该指针的合理代码
- 当引用 DST 时，编译器自动为你组建一个宽指针
- 例如：
  - 切片 slice，它的附加信息就是切片的长度
  - Trait 对象，以后再说
- 宽指针是 Sized：是 usize 的两倍大小
  - usize 就是所在目标平台上一个字（word）的大小
  - 一个 usize 持有指针
  - 另外的 usize 持有附件信息，用于“完善”该类型
- 备注：Box 和 Arc 都支持存储宽指针，所以它们都支持 T:?Sized

## 总结

通过本文的探讨，我们深入了解了 Rust 如何将抽象的类型映射到具体的内存位（bits）上。我们明白了内存对齐不仅是编译器的要求，更是 CPU 高效工作的物理基础；而填充则是为了满足对齐要求所做的必要补充。

核心要点在于，Rust 通过 repr 属性系列，赋予了开发者在“让编译器优化”和“由我精确掌控”之间做选择的权力：

- 默认的 repr(Rust)给予编译器最大的优化自由，以获得最佳性能。
- repr(C)则提供了与 C 语言兼容的、可预测的稳定布局，是 FFI（外部函数接口）的基石。
- repr(packed)和 repr(align(n))则是在空间与性能之间进行极致权衡的高级工具。

最后，对动态大小类型（DST）和宽指针的理解，揭示了 Rust 如何在编译时大小未知的情况下，依然能安全、高效地处理切片和 Trait 对象。掌握这些内存布局的知识，是每一位希望编写高性能、高可靠性系统，或从事底层与 unsafe 代码开发的 Rust 工程师的必经之路。

## 参考

- https://www.rust-lang.org/zh-CN
- https://course.rs/about-book.html
- https://lab.cs.tsinghua.edu.cn/rust/
- https://github.com/rust-lang

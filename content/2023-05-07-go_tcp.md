+++
title = "Goè¯­è¨€ï¼ˆGolangï¼‰ç¼–å†™ TCP ç«¯å£æ‰«æå™¨"
date = 2023-05-07T22:48:59+08:00
description = "Go è¯­è¨€ç¼–å†™ TCP æ‰«æå™¨"
[taxonomies]
tags = ["Go"]
categories = ["Go"]
+++

# Go è¯­è¨€ç¼–å†™ TCP æ‰«æå™¨

## TCP

- TCPï¼Œä¹Ÿå°±æ˜¯ä¼ è¾“æ§åˆ¶åè®®ï¼ˆTransmission Control Protocolï¼‰ã€‚

## TCPæ¡æ‰‹

- å»ºç«‹ TCPè¿æ¥ï¼ˆæˆ–è€…å«æ‰“å¼€ç«¯å£ï¼‰ï¼Œéœ€è¦3æ¬¡æ¡æ‰‹

å®¢æˆ·ç«¯ -> ç«¯å£æ‰“å¼€ ->æœåŠ¡å™¨

1. syn  ï¼ˆè¯·æ±‚å»ºç«‹æ–°è¿æ¥ï¼‰
2. syn-ack  ï¼ˆåŒæ„åˆ›å»ºæ–°è¿æ¥ï¼‰
3. ack ï¼ˆè¡¨ç¤ºå“åº”ï¼‰

- æœåŠ¡ç«¯ç«¯å£å…³é—­ Closed Port
  - client -syn-> Server
  - Server -rst-> Client
- å¦‚æœå­˜åœ¨é˜²ç«å¢™ Filtered Port
  - Client â€”syn (Timeout)â€” Firewall         Server

## éå¹¶å‘çš„ TCP æ‰«æå™¨

åˆ›å»ºç›®å½•å¹¶åœ¨è¯¥ç›®å½•åˆ›å»ºmain.go æ–‡ä»¶

```bash
~/Code/go via ğŸ¹ v1.20.3 via ğŸ…’ base
âœ mcd tcp-scanner

Code/go/tcp-scanner via ğŸ¹ v1.20.3 via ğŸ…’ base
âœ go mod init
go: cannot determine module path for source directory /Users/qiaopengjun/Code/go/tcp-scanner (outside GOPATH, module path must be specified)

Example usage:
 'go mod init example.com/m' to initialize a v0 or v1 module
 'go mod init example.com/m/v2' to initialize a v2 module

Run 'go help mod init' for more information.

Code/go/tcp-scanner via ğŸ¹ v1.20.3 via ğŸ…’ base
âœ go mod init tcp-scanner
go: creating new go.mod: module tcp-scanner

Code/go/tcp-scanner via ğŸ¹ v1.20.3 via ğŸ…’ base
âœ c

Code/go/tcp-scanner via ğŸ¹ v1.20.3 via ğŸ…’ base
âœ
```

main.go æ–‡ä»¶

```go
package main

import (
 "fmt"
 "net"
)

func main() {
 for i := 21; i < 120; i++ {
  address := fmt.Sprintf("20.194.168.28:%d", i)
  conn, err := net.Dial("tcp", address)
  if err != nil {
   fmt.Printf("%s failed å…³é—­äº†\n", address)
   continue
  }
  conn.Close()
  fmt.Printf("%s connected æ‰“å¼€äº†ï¼ï¼ï¼\n", address)
 }
}

```

## å¹¶å‘çš„ TCP æ‰«æå™¨

```go
package main

import (
 "fmt"
 "net"
 "sync"
 "time"
)

func main() {
 start := time.Now()
 var wg sync.WaitGroup
 for i := 21; i < 120; i++ {
  wg.Add(1)
  go func(j int) {
   defer wg.Done()
   address := fmt.Sprintf("20.194.168.28:%d", j)
   conn, err := net.Dial("tcp", address)
   if err != nil {
    fmt.Printf("%s å…³é—­äº†\n", address)
    return
   }
   conn.Close()
   fmt.Printf("%s æ‰“å¼€äº†ï¼ï¼ï¼\n", address)
  }(i)
 }
 wg.Wait()
 elapsed := time.Since(start) / 1e9
 fmt.Printf("\n\n%d seconds", elapsed)
}

// func main() {
//  for i := 21; i < 120; i++ {
//   address := fmt.Sprintf("20.194.168.28:%d", i)
//   conn, err := net.Dial("tcp", address)
//   if err != nil {
//    fmt.Printf("%s failed å…³é—­äº†\n", address)
//    continue
//   }
//   conn.Close()
//   fmt.Printf("%s connected æ‰“å¼€äº†ï¼ï¼ï¼\n", address)
//  }
// }

```

## å¹¶å‘çš„ TCP æ‰«æå™¨ - WORKER æ± 

```go
package main

import (
 "fmt"
 "sync"
)

func worker(ports chan int, wg *sync.WaitGroup) {
 for p := range ports {
  fmt.Println("p", p)
  wg.Done()
 }
}

func main() {
 ports := make(chan int, 100)
 var wg sync.WaitGroup

 for i := 0; i < cap(ports); i++ {
  go worker(ports, &wg)
 }

 for i := 1; i < 1024; i++ {
  wg.Add(1)
  ports <- i
 }

 wg.Wait()
 close(ports)
}

// func main() {
//  start := time.Now()
//  var wg sync.WaitGroup
//  for i := 21; i < 120; i++ {
//   wg.Add(1)
//   go func(j int) {
//    defer wg.Done()
//    address := fmt.Sprintf("20.194.168.28:%d", j)
//    conn, err := net.Dial("tcp", address)
//    if err != nil {
//     fmt.Printf("%s å…³é—­äº†\n", address)
//     return
//    }
//    conn.Close()
//    fmt.Printf("%s æ‰“å¼€äº†ï¼ï¼ï¼\n", address)
//   }(i)
//  }
//  wg.Wait()
//  elapsed := time.Since(start) / 1e9
//  fmt.Printf("\n\n%d seconds", elapsed)
// }

// func main() {
//  for i := 21; i < 120; i++ {
//   address := fmt.Sprintf("20.194.168.28:%d", i)
//   conn, err := net.Dial("tcp", address)
//   if err != nil {
//    fmt.Printf("%s failed å…³é—­äº†\n", address)
//    continue
//   }
//   conn.Close()
//   fmt.Printf("%s connected æ‰“å¼€äº†ï¼ï¼ï¼\n", address)
//  }
// }

```

ä¼˜åŒ–ä¹‹å

```go
package main

import (
 "fmt"
 "net"
 "sort"
)

func worker(ports chan int, results chan int) {
 for p := range ports {
  address := fmt.Sprintf("20.194.168.28:%d", p)
  conn, err := net.Dial("tcp", address)
  if err != nil {
   results <- 0
   continue
  }
  conn.Close()
  results <- p
 }
}

func main() {
 ports := make(chan int, 100)
 results := make(chan int)
 var openports []int
 var closeports []int

 for i := 0; i < cap(ports); i++ {
  go worker(ports, results)
 }
 go func() {
  for i := 1; i < 1024; i++ {

   ports <- i
  }
 }()

 for i := 1; i < 1024; i++ {
  port := <-results
  if port != 0 {
   openports = append(openports, port)
  } else {
   closeports = append(closeports, port)
  }
 }

 close(ports)
 close(results)

 sort.Ints(openports)
 sort.Ints(closeports)

 for _, port := range closeports {
  fmt.Printf("%d closed\n", port)
 }

 for _, port := range openports {
  fmt.Printf("%d opened\n", port)
 }
}

// func main() {
//  start := time.Now()
//  var wg sync.WaitGroup
//  for i := 21; i < 120; i++ {
//   wg.Add(1)
//   go func(j int) {
//    defer wg.Done()
//    address := fmt.Sprintf("20.194.168.28:%d", j)
//    conn, err := net.Dial("tcp", address)
//    if err != nil {
//     fmt.Printf("%s å…³é—­äº†\n", address)
//     return
//    }
//    conn.Close()
//    fmt.Printf("%s æ‰“å¼€äº†ï¼ï¼ï¼\n", address)
//   }(i)
//  }
//  wg.Wait()
//  elapsed := time.Since(start) / 1e9
//  fmt.Printf("\n\n%d seconds", elapsed)
// }

// func main() {
//  for i := 21; i < 120; i++ {
//   address := fmt.Sprintf("20.194.168.28:%d", i)
//   conn, err := net.Dial("tcp", address)
//   if err != nil {
//    fmt.Printf("%s failed å…³é—­äº†\n", address)
//    continue
//   }
//   conn.Close()
//   fmt.Printf("%s connected æ‰“å¼€äº†ï¼ï¼ï¼\n", address)
//  }
// }

```

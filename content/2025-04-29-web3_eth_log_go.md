+++
title = "Web3 æ•°æ®ç¥å™¨ï¼šç”¨ Go è§£é”ä»¥å¤ªåŠäº‹ä»¶è§£æ"
description = "Web3 æ•°æ®ç¥å™¨ï¼šç”¨ Go è§£é”ä»¥å¤ªåŠäº‹ä»¶è§£æ"
date = 2025-04-29T11:42:22Z
[taxonomies]
categories = ["Web3", "Go", "ä»¥å¤ªåŠ", "Ethereum"]
tags = ["Web3", "Go", "ä»¥å¤ªåŠ", "Ethereum"]
+++

<!-- more -->

# Web3 æ•°æ®ç¥å™¨ï¼šç”¨ Go è§£é”ä»¥å¤ªåŠäº‹ä»¶è§£æ

åœ¨ Web3 æ—¶ä»£ï¼Œä»¥å¤ªåŠä½œä¸ºåŒºå—é“¾ä¸–ç•Œçš„æ ¸å¿ƒæ¢çº½ï¼Œæ¯å¤©äº§ç”Ÿæµ·é‡çš„äº‹ä»¶æ•°æ®ã€‚å¦‚ä½•ä»è¿™äº›æ•°æ®ä¸­å¿«é€Ÿæå–æœ‰ä»·å€¼çš„ä¿¡æ¯ï¼Œæˆä¸ºå¼€å‘è€…è§£é”åŒºå—é“¾æ½œåŠ›çš„å…³é”®ã€‚æƒ³è±¡ä¸€ä¸‹ï¼šç”¨ Go è¯­è¨€æ‰“é€ ä¸€ä¸ªé«˜æ•ˆå·¥å…·ï¼Œè½»æ¾è§£æä»¥å¤ªåŠçš„äº¤æ˜“æ”¶æ®å’Œäº‹ä»¶æ—¥å¿—ï¼Œè·å–ç²¾å‡†çš„ä¸šåŠ¡æ•°æ®ï¼æœ¬æ–‡é€šè¿‡ä¸€ä¸ªå®æˆ˜é¡¹ç›®ï¼ˆEthertraceï¼‰ï¼Œæ‰‹æŠŠæ‰‹å¸¦ä½ ç”¨ Go æ„å»ºä¸€ä¸ª Web3 æ•°æ®ç¥å™¨ï¼Œä»è¿æ¥ä»¥å¤ªåŠèŠ‚ç‚¹åˆ°è§£æ ConfirmDataStore äº‹ä»¶ï¼Œå…¨ç¨‹ä»£ç æ¸…æ™°ã€æµ‹è¯•è¦†ç›– 100%ã€‚æ— è®ºä½ æ˜¯ Web3 æ–°æ‰‹è¿˜æ˜¯èµ„æ·±å¼€å‘è€…ï¼Œè¿™ç¯‡å¹²è´§å°†ä¸ºä½ æ‰“å¼€ä»¥å¤ªåŠæ•°æ®è§£æçš„å¤§é—¨ï¼

æœ¬æ–‡é€šè¿‡ä¸€ä¸ªåŸºäº Go è¯­è¨€çš„ Web3 æ•°æ®è§£æé¡¹ç›®ï¼ˆEthertraceï¼‰ï¼Œè¯¦ç»†å±•ç¤ºå¦‚ä½•æ‰“é€ ä¸€ä¸ªä»¥å¤ªåŠäº‹ä»¶è§£æå·¥å…·ã€‚é¡¹ç›®æ¶µç›–å®Œæ•´ä»£ç å®ç°ï¼ŒåŒ…æ‹¬è¿æ¥ä»¥å¤ªåŠèŠ‚ç‚¹ï¼ˆclient.goï¼‰ã€è§£æ ConfirmDataStore äº‹ä»¶ï¼ˆevent_parser.goï¼‰ä»¥åŠä¸»ç¨‹åºé€»è¾‘ï¼ˆmain.goï¼‰ã€‚é€šè¿‡ ethclient è·å–äº¤æ˜“æ”¶æ®å’ŒåŒºå—æ—¥å¿—ï¼Œç»“åˆ ABI è§£æäº‹ä»¶æ•°æ®ï¼Œå·¥å…·é«˜æ•ˆä¸”æ˜“ç”¨ã€‚é¡¹ç›®è¿˜åŒ…å«å…¨é¢çš„æµ‹è¯•ç”¨ä¾‹ï¼ˆclient_test.go å’Œ event_parser_test.goï¼‰ï¼Œå®ç° 100% æµ‹è¯•è¦†ç›–ç‡ï¼Œå¹¶é€šè¿‡å¯è§†åŒ–æŠ¥å‘ŠéªŒè¯ä»£ç è´¨é‡ã€‚æœ¬æ–‡é€‚åˆå¯¹ Web3 å¼€å‘ã€ä»¥å¤ªåŠæ•°æ®æå–æˆ– Go è¯­è¨€æ„Ÿå…´è¶£çš„è¯»è€…ï¼Œæä¾›äº†å¯å¤ç”¨çš„ä»£ç æ¡†æ¶å’Œå®æˆ˜ç»éªŒã€‚

## å®æ“

### é¡¹ç›®ç›®å½•ç»“æ„

```bash
Web3Wallet/ethertrace/go via ğŸ¹ v1.24.2 took 3.0s 
âœ ls
ethertrace go.mod     go.sum     main.go

Web3Wallet/ethertrace/go via ğŸ¹ v1.24.2 
âœ tree . -L 6 -I "__pycache__|python.egg-info|htmlcov|ethertrace.egg-info"
.
â”œâ”€â”€ ethertrace
â”‚Â Â  â”œâ”€â”€ client.go
â”‚Â Â  â”œâ”€â”€ client_test.go
â”‚Â Â  â”œâ”€â”€ coverage.out
â”‚Â Â  â”œâ”€â”€ event_parser.go
â”‚Â Â  â””â”€â”€ event_parser_test.go
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â””â”€â”€ main.go

2 directories, 8 files


```

### ä»£ç å®ç°

#### `client.go` æ–‡ä»¶

```go
package ethertrace

import (
 "context"
 "fmt"
 "github.com/ethereum/go-ethereum"
 "github.com/ethereum/go-ethereum/common"
 "github.com/ethereum/go-ethereum/core/types"
 "github.com/ethereum/go-ethereum/ethclient"
 "github.com/ethereum/go-ethereum/log"
 "math/big"
 "regexp"
)

var (
 // æ”¯æŒçš„åè®®åˆ—è¡¨
 allowedSchemes = map[string]bool{
  "http":  true,
  "https": true,
  "ws":    true,
  "wss":   true,
 }

 // åŸŸåæ ¼å¼éªŒè¯ï¼ˆæ”¯æŒIPå’ŒåŸŸåï¼‰
 domainRegex = regexp.MustCompile(`^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.?)+$`)
)

// EthClient å°è£…ä»¥å¤ªåŠå®¢æˆ·ç«¯
type EthClient struct {
 client *ethclient.Client
}

// NewEthClient åˆ›å»ºæ–°çš„ä»¥å¤ªåŠå®¢æˆ·ç«¯
func NewEthClient(rpcURL string) (*EthClient, error) {
 // åˆ¤æ–­ rpcURL
 // 1. åŸºç¡€éªŒè¯
 if rpcURL == "" {
  log.Error("Empty RPC URL provided")
  return nil, fmt.Errorf("empty RPC URL")
 }

 // å®é™…è¿æ¥æµ‹è¯•
 client, err := ethclient.DialContext(context.Background(), rpcURL)
 if err != nil {
  log.Error("Failed to connect to Ethereum node", "url", rpcURL, "error", err)
  return nil, err
 }
 return &EthClient{client: client}, nil
}

// GetTxReceiptByHash è·å–äº¤æ˜“æ”¶æ®
func (ec *EthClient) GetTxReceiptByHash(txHash string) (*types.Receipt, error) {
 hash := common.HexToHash(txHash)
 receipt, err := ec.client.TransactionReceipt(context.Background(), hash)
 if err != nil {
  log.Error("Failed to get transaction receipt", "txHash", txHash, "error", err)
  return nil, err
 }
 return receipt, nil
}

// GetLogs è·å–æŒ‡å®šåŒºå—èŒƒå›´å†…çš„æ—¥å¿—
func (ec *EthClient) GetLogs(startBlock, endBlock *big.Int, addresses []common.Address) ([]*types.Log, error) {
 query := ethereum.FilterQuery{
  FromBlock: startBlock,
  ToBlock:   endBlock,
  Addresses: addresses,
 }
 logs, err := ec.client.FilterLogs(context.Background(), query)
 fmt.Println("GetLogs: ", logs)
 fmt.Println("err:", err)
 if err != nil {
  log.Error("Failed to get logs", "startBlock", startBlock, "endBlock", endBlock, "error", err)
  return nil, err
 }
 // Convert logs to pointers
 logPtrs := make([]*types.Log, len(logs))
 for i := range logs {
  logPtrs[i] = &logs[i]
 }
 return logPtrs, nil
}

// Close å…³é—­å®¢æˆ·ç«¯è¿æ¥
func (ec *EthClient) Close() {
 ec.client.Close()
}

```

#### `event_parser.go` æ–‡ä»¶

```go
package ethertrace

import (
 "errors"
 "strings"

 "github.com/ethereum/go-ethereum/accounts/abi"
 "github.com/ethereum/go-ethereum/common"
 "github.com/ethereum/go-ethereum/core/types"
 "github.com/ethereum/go-ethereum/crypto"
 "github.com/ethereum/go-ethereum/log"
)

// EventParser äº‹ä»¶è§£æå™¨
type EventParser struct {
 eventABI     abi.Arguments
 eventHash    common.Hash
 contractAddr common.Address
}

// ConfirmDataStoreData å­˜å‚¨è§£æåçš„äº‹ä»¶æ•°æ®
type ConfirmDataStoreData struct {
 DataStoreID uint32
 HeaderHash  common.Hash
}

// NewEventParser åˆ›å»º ConfirmDataStore äº‹ä»¶è§£æå™¨
func NewEventParser(contractAddr string) (*EventParser, error) {
 // éªŒè¯åˆçº¦åœ°å€
 if contractAddr == "" {
  return nil, errors.New("åˆçº¦åœ°å€ä¸èƒ½ä¸ºç©º")
 }
 if !strings.HasPrefix(contractAddr, "0x") || len(contractAddr) != 42 {
  return nil, errors.New("æ— æ•ˆçš„åˆçº¦åœ°å€æ ¼å¼")
 }
 addr := common.HexToAddress(contractAddr)
 if addr.Hex() == "0x0000000000000000000000000000000000000000" {
  return nil, errors.New("åˆçº¦åœ°å€ä¸èƒ½ä¸ºé›¶åœ°å€")
 }

 // å®šä¹‰ ConfirmDataStore äº‹ä»¶çš„ ABI
 uint32Type, _ := abi.NewType("uint32", "uint32", nil)
 //if err != nil {
 // return nil, err
 //}
 bytes32Type, _ := abi.NewType("bytes32", "bytes32", nil)
 //if err != nil {
 // return nil, err
 //}

 eventABI := abi.Arguments{
  {Name: "dataStoreId", Type: uint32Type},
  {Name: "headerHash", Type: bytes32Type},
 }

 // è®¡ç®—äº‹ä»¶ç­¾åå“ˆå¸Œ
 eventHash := crypto.Keccak256Hash([]byte("ConfirmDataStore(uint32,bytes32)"))

 return &EventParser{
  eventABI:     eventABI,
  eventHash:    eventHash,
  contractAddr: addr,
 }, nil
}

// EventHash returns the event signature hash
func (ep *EventParser) EventHash() common.Hash {
 return ep.eventHash
}

// ParseLogs è§£ææ—¥å¿—å¹¶æå– ConfirmDataStore äº‹ä»¶æ•°æ®
func (ep *EventParser) ParseLogs(logs []*types.Log) ([]ConfirmDataStoreData, error) {
 var results []ConfirmDataStoreData

 for _, l := range logs {
  // è¿‡æ»¤åˆçº¦åœ°å€å’Œäº‹ä»¶ç­¾å
  if !strings.EqualFold(l.Address.String(), ep.contractAddr.String()) {
   continue
  }
  if len(l.Topics) == 0 || l.Topics[0] != ep.eventHash {
   continue
  }

  // è§£ç æ—¥å¿—æ•°æ®
  dataMap := make(map[string]interface{})
  if err := ep.eventABI.UnpackIntoMap(dataMap, l.Data); err != nil {
   log.Error("Failed to unpack log data", "error", err)
   continue
  }

  // æå–å­—æ®µ
  dataStoreID, _ := dataMap["dataStoreId"].(uint32)
  //dataStoreID, ok := dataMap["dataStoreId"].(uint32)
  //if !ok {
  // log.Warn("Invalid dataStoreId type")
  // continue
  //}
  headerHash, _ := dataMap["headerHash"].([32]byte)
  //headerHash, ok := dataMap["headerHash"].([32]byte)
  //if !ok {
  // log.Warn("Invalid headerHash type")
  // continue
  //}

  results = append(results, ConfirmDataStoreData{
   DataStoreID: dataStoreID,
   HeaderHash:  common.Hash(headerHash),
  })
 }

 return results, nil
}

```

#### `main.go` æ–‡ä»¶

```go
package main

import (
 "fmt"
 "math/big"

 "github.com/ethereum/go-ethereum/common"

 "github.com/qiaopengjun5162/ethertrace/go/ethertrace"
)

const (
 rpcURL        = "https://rpc.mevblocker.io"
 contractAddr  = "0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1"
 txHashExample = "0xfd26d40e17213bcafcf94bab9af92343302df9df970f20e1c9d515525e86e23e"
 startBlock    = 20483831
 endBlock      = 20483833
)

func main() {
 // åˆå§‹åŒ–å®¢æˆ·ç«¯
 client, err := ethertrace.NewEthClient(rpcURL)
 if err != nil {
  fmt.Printf("Failed to create eth client: %v\n", err)
  return
 }
 defer client.Close()

 // åˆå§‹åŒ–äº‹ä»¶è§£æå™¨
 parser, err := ethertrace.NewEventParser(contractAddr)
 if err != nil {
  fmt.Printf("Failed to create event parser: %v\n", err)
  return
 }

 // ç¤ºä¾‹ 1: è·å–äº¤æ˜“æ”¶æ®å¹¶è§£ææ—¥å¿—
 receipt, err := client.GetTxReceiptByHash(txHashExample)
 if err != nil {
  fmt.Printf("Failed to get tx receipt: %v\n", err)
  return
 }
 txResults, err := parser.ParseLogs(receipt.Logs)
 if err != nil {
  fmt.Printf("Failed to parse tx logs: %v\n", err)
  return
 }
 for _, result := range txResults {
  fmt.Printf("Tx Receipt - DataStoreID: %d, HeaderHash: %s\n", result.DataStoreID, result.HeaderHash.Hex())
 }

 // ç¤ºä¾‹ 2: è·å–åŒºå—èŒƒå›´å†…çš„æ—¥å¿—å¹¶è§£æ
 logs, err := client.GetLogs(big.NewInt(int64(startBlock)), big.NewInt(int64(endBlock)), []common.Address{common.HexToAddress(contractAddr)})
 if err != nil {
  fmt.Printf("Failed to get logs: %v\n", err)
  return
 }
 logResults, err := parser.ParseLogs(logs)
 if err != nil {
  fmt.Printf("Failed to parse logs: %v\n", err)
  return
 }
 for _, result := range logResults {
  fmt.Printf("Logs - DataStoreID: %d, HeaderHash: %s\n", result.DataStoreID, result.HeaderHash.Hex())
 }
}

```

### æ‰§è¡Œ go mod tidy

```bash
Web3Wallet/ethertrace/go via ğŸ¹ v1.24.2 
âœ go mod tidy

```

### è¿è¡Œ main æ–‡ä»¶

```bash
Web3Wallet/ethertrace/go via ğŸ¹ v1.24.2 
âœ go run ./main.go
Tx Receipt - DataStoreID: 35258, HeaderHash: 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243
GetLogs:  [{0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1 [0x34d57e230be557a52d94166eb9035810e61ac973182a92b09e6b0e99110665a9] [173 67 67 239 116 234 22 115 43 6 168 238 25 6 135 134 190 71 250 49 42 180 111 252 143 155 203 188 17 102 114 65 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 137 137 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 211 194 27 206 204 237 161 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 160 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 20483832 0xbc00672e67935e54c08d895b88fe41aa5cf664dc8f855836c7d26726e0c59ea4 132 0xc4254a63b8ef260bf3e271ff7c38b97817d08c7195600c0b2e0de404ec11d798 96 false} {0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1 [0xfbb7f4f1b0b9ad9e75d69d22c364e13089418d86fcb5106792a53046c0fb33aa] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 137 138 247 74 220 237 98 226 119 32 201 25 189 191 165 87 183 176 180 209 84 227 250 235 54 73 198 244 242 222 237 52 86 219] 20483832 0xbc00672e67935e54c08d895b88fe41aa5cf664dc8f855836c7d26726e0c59ea4 132 0xc4254a63b8ef260bf3e271ff7c38b97817d08c7195600c0b2e0de404ec11d798 97 false}]
err: <nil>
Logs - DataStoreID: 35210, HeaderHash: 0xf74adced62e27720c919bdbfa557b7b0b4d154e3faeb3649c6f4f2deed3456db


```

### æµ‹è¯•ä»£ç 

#### `client_test.go` æ–‡ä»¶

```go
package ethertrace

import (
 "fmt"
 "github.com/stretchr/testify/assert"
 "github.com/stretchr/testify/require"
 "math/big"
 "strings"
 "testing"

 "github.com/ethereum/go-ethereum/common"
)

func TestEthClient_GetTxReceiptByHash(t *testing.T) {
 client, err := NewEthClient("https://eth.llamarpc.com")
 if err != nil {
  t.Fatalf("Failed to create client: %v", err)
 }
 defer client.Close()

 txHash := "0xfd26d40e17213bcafcf94bab9af92343302df9df970f20e1c9d515525e86e23e"
 receipt, err := client.GetTxReceiptByHash(txHash)
 if err != nil {
  t.Fatalf("Failed to get receipt: %v", err)
 }
 if receipt == nil {
  t.Fatal("Receipt is nil")
 }
 fmt.Println("receipt:", receipt)
}

func TestEthClient_GetLogs(t *testing.T) {
 client, err := NewEthClient("https://rpc.mevblocker.io")
 if err != nil {
  t.Fatalf("Failed to create client: %v", err)
 }
 defer client.Close()

 logs, err := client.GetLogs(big.NewInt(20483831), big.NewInt(20483833), []common.Address{common.HexToAddress("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1")})
 if err != nil {
  t.Fatalf("Failed to get logs: %v", err)
 }
 if len(logs) == 0 {
  t.Log("No logs found, but test passes as query was successful")
 }
 fmt.Println("logs: ", logs)
}

func TestEthClient_GetTxReceiptByHash2(t *testing.T) {
 client, err := NewEthClient("https://eth.llamarpc.com") // æ›¿æ¢ä¸ºæµ‹è¯•èŠ‚ç‚¹
 if err != nil {
  t.Fatalf("åˆ›å»º EthClient å¤±è´¥: %v", err)
 }

 tests := []struct {
  name        string
  txHash      string
  expectError string
 }{
  {
   name:        "æœ‰æ•ˆäº¤æ˜“å“ˆå¸Œ",
   txHash:      "0xfd26d40e17213bcafcf94bab9af92343302df9df970f20e1c9d515525e86e23e",
   expectError: "",
  },
  {
   name:        "æ— æ•ˆäº¤æ˜“å“ˆå¸Œ",
   txHash:      "0x0000000000000000000000000000000000000000000000000000000000000000",
   expectError: "not found", // å‡è®¾èŠ‚ç‚¹è¿”å›æ­¤é”™è¯¯
  },
 }

 for _, tt := range tests {
  t.Run(tt.name, func(t *testing.T) {
   _, err := client.GetTxReceiptByHash(tt.txHash)
   if tt.expectError == "" {
    if err != nil {
     t.Errorf("GetTxReceiptByHash æœŸæœ›æ— é”™è¯¯ï¼Œå®é™…é”™è¯¯: %v", err)
    }
   } else {
    if err == nil || !strings.Contains(err.Error(), tt.expectError) {
     t.Errorf("GetTxReceiptByHash æœŸæœ›é”™è¯¯åŒ…å« %qï¼Œå®é™…é”™è¯¯: %v", tt.expectError, err)
    }
   }
  })
 }
}

func TestNewEthClient(t *testing.T) {
 client, err := NewEthClient("https://rpc.mevblocker.io")
 if err != nil {
  t.Fatalf("Failed to create client: %v", err)
 }
 defer client.Close()
}

func TestNewEthClientRpcUrl(t *testing.T) {
 client, err := NewEthClient("")
 t.Log("err:", err)
 assert.EqualError(t, err, "empty RPC URL")
 // åœ¨é”™è¯¯æƒ…å†µä¸‹ä¸è¦æ“ä½œ client
 if client != nil {
  client.Close() // å¦‚æœæµ‹è¯•éœ€è¦ï¼Œå¯ä»¥æ‰‹åŠ¨å…³é—­
 }

}

func TestNewEthClient_InvalidURLs(t *testing.T) {
 tests := []struct {
  name        string
  rpcURL      string
  expectError string
 }{
  {
   name:        "ç©ºåœ°å€",
   rpcURL:      "",
   expectError: "empty RPC URL",
  },
  {
   name:        "æ— æ•ˆåè®®",
   rpcURL:      "ftp://localhost",
   expectError: "no known transport for URL scheme \"ftp\"",
  },
  {
   name:        "<UNK>",
   rpcURL:      "http://localhost:12w222q",
   expectError: "invalid port",
  },
  {
   name:        "éæ³•ç«¯å£",
   rpcURL:      "http://localhost:abc",
   expectError: "invalid port",
  },
 }

 for _, tt := range tests {
  t.Run(tt.name, func(t *testing.T) {
   client, err := NewEthClient(tt.rpcURL)
   t.Log("client:", client)
   t.Log("err:", err)

   // éªŒè¯é”™è¯¯
   require.Error(t, err, "åº”è¯¥è¿”å›é”™è¯¯")
   assert.Contains(t, err.Error(), tt.expectError, "é”™è¯¯ä¿¡æ¯ä¸åŒ¹é…")

   // å®‰å…¨å¤„ç† client
   if client != nil {
    t.Error("é”™è¯¯æƒ…å†µä¸‹åº”è¯¥è¿”å› nil client")
    client.Close()
   }
  })
 }
}

// TestEthClient_GetLogs æµ‹è¯• GetLogsï¼ŒåŒ…æ‹¬é”™è¯¯è·¯å¾„
func TestEthClient2(t *testing.T) {
 // æ•è·æ—¥å¿—
 _, err := NewEthClient("htrpc.mevlocke")
 t.Log("err:", err)
 require.Error(t, err, "åº”è¯¥è¿”å›é”™è¯¯")
}

func TestEthClient_GetLogs2(t *testing.T) {
 client, err := NewEthClient("https://rpc.mevblocker.io")
 if err != nil {
  t.Fatalf("Failed to create client: %v", err)
 }
 defer client.Close()

 logs, err := client.GetLogs(big.NewInt(20483831), big.NewInt(0), []common.Address{common.HexToAddress("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1")})
 t.Log("logs: ", logs)
 t.Log("err:", err)
 if len(logs) == 0 {
  t.Log("No logs found, but test passes as query was successful")
 }
 fmt.Println("logs: ", logs)
}

```

#### `event_parser_test.go` æ–‡ä»¶

```go
package ethertrace

import (
 "fmt"
 "strings"
 "testing"

 "github.com/ethereum/go-ethereum/common"
 "github.com/ethereum/go-ethereum/core/types"
)

func TestEventParser_ParseLogs(t *testing.T) {
 parser, err := NewEventParser("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1")
 if err != nil {
  t.Fatalf("Failed to create parser: %v", err)
 }

 // æ¨¡æ‹Ÿæ—¥å¿—æ•°æ®ï¼ˆéœ€æ ¹æ®å®é™…äº‹ä»¶æ•°æ®æ„é€ ï¼‰
 logs := []*types.Log{
  {
   Address: common.HexToAddress("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1"),
   Topics:  []common.Hash{parser.EventHash()}, // äº‹ä»¶å“ˆå¸Œ
   Data:    common.Hex2Bytes("00000000000000000000000000000000000000000000000000000000000089ba27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243"),
  },
 }

 results, err := parser.ParseLogs(logs)
 if err != nil {
  t.Fatalf("Failed to parse logs: %v", err)
 }
 if len(results) == 0 {
  t.Log("No valid logs parsed, ensure test data is correct")
 }
 fmt.Println("results", results)
}

// æµ‹è¯• NewEventParser çš„å„ç§åœºæ™¯
func TestNewEventParser(t *testing.T) {
 tests := []struct {
  name        string
  address     string
  expectError string
 }{
  {
   name:        "æœ‰æ•ˆåœ°å€",
   address:     "0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1",
   expectError: "",
  },
  {
   name:        "æ— æ•ˆåœ°å€",
   address:     "0xInvalidAddress",
   expectError: "æ— æ•ˆçš„åˆçº¦åœ°å€æ ¼å¼",
  },
  {
   name:        "ç©ºåœ°å€",
   address:     "",
   expectError: "åˆçº¦åœ°å€ä¸èƒ½ä¸ºç©º",
  },
  {
   name:        "é›¶åœ°å€",
   address:     "0x0000000000000000000000000000000000000000",
   expectError: "åˆçº¦åœ°å€ä¸èƒ½ä¸ºé›¶åœ°å€",
  },
  {
   name:        "ç¼ºå°‘0xå‰ç¼€",
   address:     "5BD63a7ECc13b955C4F57e3F12A64c10263C14c1",
   expectError: "æ— æ•ˆçš„åˆçº¦åœ°å€æ ¼å¼",
  },
 }

 for _, tt := range tests {
  t.Run(tt.name, func(t *testing.T) {
   parser, err := NewEventParser(tt.address)
   if tt.expectError == "" {
    if err != nil {
     t.Errorf("NewEventParser(%q) æœŸæœ›æ— é”™è¯¯ï¼Œå®é™…é”™è¯¯: %v", tt.address, err)
    }
    if parser == nil || parser.contractAddr != common.HexToAddress(tt.address) {
     t.Errorf("NewEventParser(%q) è¿”å›çš„è§£æå™¨ä¸ç¬¦åˆé¢„æœŸ", tt.address)
    }
   } else {
    if err == nil || !strings.Contains(err.Error(), tt.expectError) {
     t.Errorf("NewEventParser(%q) æœŸæœ›é”™è¯¯åŒ…å« %qï¼Œå®é™…é”™è¯¯: %v", tt.address, tt.expectError, err)
    }
    if parser != nil {
     t.Errorf("NewEventParser(%q) æœŸæœ›è¿”å› nil è§£æå™¨ï¼Œå®é™…è¿”å›: %v", tt.address, parser)
    }
   }
  })
 }
}

// æµ‹è¯•å•ä¸ªæœ‰æ•ˆæ—¥å¿—
func TestEventParser_ParseLogs_SingleValidLog(t *testing.T) {
 parser, err := NewEventParser("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1")
 if err != nil {
  t.Fatalf("åˆ›å»º EventParser å¤±è´¥: %v", err)
 }

 logs := []*types.Log{
  {
   Address: common.HexToAddress("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1"),
   Topics:  []common.Hash{parser.EventHash()},
   Data:    common.Hex2Bytes("00000000000000000000000000000000000000000000000000000000000089ba27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243"),
  },
 }
 expectResult := 1
 validate := func(results []ConfirmDataStoreData) error {
  if len(results) != expectResult {
   return fmt.Errorf("æœŸæœ› %d ä¸ªç»“æœï¼Œå®é™…å¾—åˆ° %d ä¸ª", expectResult, len(results))
  }
  result := results[0]
  if result.DataStoreID != 35258 {
   return fmt.Errorf("DataStoreID æœŸæœ› 35258ï¼Œå®é™… %d", result.DataStoreID)
  }
  if result.HeaderHash != common.HexToHash("0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243") {
   return fmt.Errorf("HeaderHash ä¸ç¬¦åˆé¢„æœŸ")
  }
  return nil
 }

 results, err := parser.ParseLogs(logs)
 if err != nil {
  t.Errorf("ParseLogs æœŸæœ›æ— é”™è¯¯ï¼Œå®é™…é”™è¯¯: %v", err)
 }
 if len(results) != expectResult {
  t.Errorf("ParseLogs æœŸæœ› %d ä¸ªç»“æœï¼Œå®é™…å¾—åˆ° %d ä¸ª", expectResult, len(results))
 }
 if err := validate(results); err != nil {
  t.Errorf("ç»“æœéªŒè¯å¤±è´¥: %v", err)
 }
 if len(results) > 0 {
  fmt.Printf("æµ‹è¯• 'å•ä¸ªæœ‰æ•ˆæ—¥å¿—' çš„ç»“æœ: %v\n", results)
 }
}

// æµ‹è¯•ç©ºæ—¥å¿—åˆ—è¡¨
func TestEventParser_ParseLogs_EmptyLogs(t *testing.T) {
 parser, err := NewEventParser("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1")
 if err != nil {
  t.Fatalf("åˆ›å»º EventParser å¤±è´¥: %v", err)
 }

 logs := []*types.Log{}
 expectResult := 0
 validate := func(results []ConfirmDataStoreData) error {
  if len(results) != expectResult {
   return fmt.Errorf("æœŸæœ› %d ä¸ªç»“æœï¼Œå®é™…å¾—åˆ° %d ä¸ª", expectResult, len(results))
  }
  return nil
 }

 results, err := parser.ParseLogs(logs)
 if err != nil {
  t.Errorf("ParseLogs æœŸæœ›æ— é”™è¯¯ï¼Œå®é™…é”™è¯¯: %v", err)
 }
 if len(results) != expectResult {
  t.Errorf("ParseLogs æœŸæœ› %d ä¸ªç»“æœï¼Œå®é™…å¾—åˆ° %d ä¸ª", expectResult, len(results))
 }
 if err := validate(results); err != nil {
  t.Errorf("ç»“æœéªŒè¯å¤±è´¥: %v", err)
 }
 if len(results) > 0 {
  fmt.Printf("æµ‹è¯• 'ç©ºæ—¥å¿—åˆ—è¡¨' çš„ç»“æœ: %v\n", results)
 }
}

// æµ‹è¯•æ— æ•ˆæ—¥å¿—ï¼ˆé”™è¯¯åœ°å€ï¼‰
func TestEventParser_ParseLogs_InvalidAddress(t *testing.T) {
 parser, err := NewEventParser("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1")
 if err != nil {
  t.Fatalf("åˆ›å»º EventParser å¤±è´¥: %v", err)
 }

 logs := []*types.Log{
  {
   Address: common.HexToAddress("0xWrongAddress"),
   Topics:  []common.Hash{parser.EventHash()},
   Data:    common.Hex2Bytes("00000000000000000000000000000000000000000000000000000000000089ba27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243"),
  },
 }
 expectResult := 0
 validate := func(results []ConfirmDataStoreData) error {
  if len(results) != expectResult {
   return fmt.Errorf("æœŸæœ› %d ä¸ªç»“æœï¼Œå®é™…å¾—åˆ° %d ä¸ª", expectResult, len(results))
  }
  return nil
 }

 results, err := parser.ParseLogs(logs)
 if err != nil {
  t.Errorf("ParseLogs æœŸæœ›æ— é”™è¯¯ï¼Œå®é™…é”™è¯¯: %v", err)
 }
 if len(results) != expectResult {
  t.Errorf("ParseLogs æœŸæœ› %d ä¸ªç»“æœï¼Œå®é™…å¾—åˆ° %d ä¸ª", expectResult, len(results))
 }
 if err := validate(results); err != nil {
  t.Errorf("ç»“æœéªŒè¯å¤±è´¥: %v", err)
 }
 if len(results) > 0 {
  fmt.Printf("æµ‹è¯• 'æ— æ•ˆæ—¥å¿—ï¼ˆé”™è¯¯åœ°å€ï¼‰' çš„ç»“æœ: %v\n", results)
 }
}

// æµ‹è¯•ä¸»é¢˜ä¸åŒ¹é…
func TestEventParser_ParseLogs_TopicMismatch(t *testing.T) {
 parser, err := NewEventParser("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1")
 if err != nil {
  t.Fatalf("åˆ›å»º EventParser å¤±è´¥: %v", err)
 }

 logs := []*types.Log{
  {
   Address: common.HexToAddress("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1"),
   Topics:  []common.Hash{common.HexToHash("0xWrongHash")},
   Data:    common.Hex2Bytes("00000000000000000000000000000000000000000000000000000000000089ba27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243"),
  },
 }
 expectResult := 0
 validate := func(results []ConfirmDataStoreData) error {
  if len(results) != expectResult {
   return fmt.Errorf("æœŸæœ› %d ä¸ªç»“æœï¼Œå®é™…å¾—åˆ° %d ä¸ª", expectResult, len(results))
  }
  return nil
 }

 results, err := parser.ParseLogs(logs)
 if err != nil {
  t.Errorf("ParseLogs æœŸæœ›æ— é”™è¯¯ï¼Œå®é™…é”™è¯¯: %v", err)
 }
 if len(results) != expectResult {
  t.Errorf("ParseLogs æœŸæœ› %d ä¸ªç»“æœï¼Œå®é™…å¾—åˆ° %d ä¸ª", expectResult, len(results))
 }
 if err := validate(results); err != nil {
  t.Errorf("ç»“æœéªŒè¯å¤±è´¥: %v", err)
 }
 if len(results) > 0 {
  fmt.Printf("æµ‹è¯• 'ä¸»é¢˜ä¸åŒ¹é…' çš„ç»“æœ: %v\n", results)
 }
}

// æµ‹è¯•ç©ºä¸»é¢˜
func TestEventParser_ParseLogs_EmptyTopics(t *testing.T) {
 parser, err := NewEventParser("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1")
 if err != nil {
  t.Fatalf("åˆ›å»º EventParser å¤±è´¥: %v", err)
 }

 logs := []*types.Log{
  {
   Address: common.HexToAddress("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1"),
   Topics:  []common.Hash{},
   Data:    common.Hex2Bytes("00000000000000000000000000000000000000000000000000000000000089ba27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243"),
  },
 }
 expectResult := 0
 validate := func(results []ConfirmDataStoreData) error {
  if len(results) != expectResult {
   return fmt.Errorf("æœŸæœ› %d ä¸ªç»“æœï¼Œå®é™…å¾—åˆ° %d ä¸ª", expectResult, len(results))
  }
  return nil
 }

 results, err := parser.ParseLogs(logs)
 if err != nil {
  t.Errorf("ParseLogs æœŸæœ›æ— é”™è¯¯ï¼Œå®é™…é”™è¯¯: %v", err)
 }
 if len(results) != expectResult {
  t.Errorf("ParseLogs æœŸæœ› %d ä¸ªç»“æœï¼Œå®é™…å¾—åˆ° %d ä¸ª", expectResult, len(results))
 }
 if err := validate(results); err != nil {
  t.Errorf("ç»“æœéªŒè¯å¤±è´¥: %v", err)
 }
 if len(results) > 0 {
  fmt.Printf("æµ‹è¯• 'ç©ºä¸»é¢˜' çš„ç»“æœ: %v\n", results)
 }
}

// æµ‹è¯•æ— æ•ˆæ•°æ®æ ¼å¼
func TestEventParser_ParseLogs_InvalidDataFormat(t *testing.T) {
 parser, err := NewEventParser("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1")
 if err != nil {
  t.Fatalf("åˆ›å»º EventParser å¤±è´¥: %v", err)
 }

 logs := []*types.Log{
  {
   Address: common.HexToAddress("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1"),
   Topics:  []common.Hash{parser.EventHash()},
   Data:    common.Hex2Bytes("invalid"),
  },
 }
 expectResult := 0
 validate := func(results []ConfirmDataStoreData) error {
  if len(results) != expectResult {
   return fmt.Errorf("æœŸæœ› %d ä¸ªç»“æœï¼Œå®é™…å¾—åˆ° %d ä¸ª", expectResult, len(results))
  }
  return nil
 }

 results, err := parser.ParseLogs(logs)
 if err != nil {
  t.Errorf("ParseLogs æœŸæœ›æ— é”™è¯¯ï¼Œå®é™…é”™è¯¯: %v", err)
 }
 if len(results) != expectResult {
  t.Errorf("ParseLogs æœŸæœ› %d ä¸ªç»“æœï¼Œå®é™…å¾—åˆ° %d ä¸ª", expectResult, len(results))
 }
 if err := validate(results); err != nil {
  t.Errorf("ç»“æœéªŒè¯å¤±è´¥: %v", err)
 }
 if len(results) > 0 {
  fmt.Printf("æµ‹è¯• 'æ— æ•ˆæ•°æ®æ ¼å¼' çš„ç»“æœ: %v\n", results)
 }
}

// æµ‹è¯•å¤§é‡æ—¥å¿—ï¼ˆå‹åŠ›æµ‹è¯•ï¼‰
func TestEventParser_ParseLogs_LargeNumberOfLogs(t *testing.T) {
 parser, err := NewEventParser("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1")
 if err != nil {
  t.Fatalf("åˆ›å»º EventParser å¤±è´¥: %v", err)
 }

 logs := func() []*types.Log {
  var logs []*types.Log
  for i := 0; i < 1000; i++ {
   logs = append(logs, &types.Log{
    Address: common.HexToAddress("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1"),
    Topics:  []common.Hash{parser.EventHash()},
    Data:    common.Hex2Bytes("00000000000000000000000000000000000000000000000000000000000089ba27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243"),
   })
  }
  return logs
 }()
 expectResult := 1000
 validate := func(results []ConfirmDataStoreData) error {
  if len(results) != expectResult {
   return fmt.Errorf("æœŸæœ› %d ä¸ªç»“æœï¼Œå®é™…å¾—åˆ° %d ä¸ª", expectResult, len(results))
  }
  for i, result := range results {
   if result.DataStoreID != 35258 {
    return fmt.Errorf("ç¬¬ %d ä¸ª DataStoreID æœŸæœ› 35258ï¼Œå®é™… %d", i, result.DataStoreID)
   }
   if result.HeaderHash != common.HexToHash("0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243") {
    return fmt.Errorf("ç¬¬ %d ä¸ª HeaderHash ä¸ç¬¦åˆé¢„æœŸ", i)
   }
  }
  return nil
 }

 results, err := parser.ParseLogs(logs)
 if err != nil {
  t.Errorf("ParseLogs æœŸæœ›æ— é”™è¯¯ï¼Œå®é™…é”™è¯¯: %v", err)
 }
 if len(results) != expectResult {
  t.Errorf("ParseLogs æœŸæœ› %d ä¸ªç»“æœï¼Œå®é™…å¾—åˆ° %d ä¸ª", expectResult, len(results))
 }
 if err := validate(results); err != nil {
  t.Errorf("ç»“æœéªŒè¯å¤±è´¥: %v", err)
 }
 if len(results) > 0 {
  fmt.Printf("æµ‹è¯• 'å¤§é‡æ—¥å¿—ï¼ˆå‹åŠ›æµ‹è¯•ï¼‰' çš„ç»“æœ: %v\n", results[:5])
 }
}

// æµ‹è¯•æ— æ•ˆ dataStoreId ç±»å‹
func TestEventParser_ParseLogs_InvalidDataStoreIDType(t *testing.T) {
 parser, err := NewEventParser("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1")
 if err != nil {
  t.Fatalf("åˆ›å»º EventParser å¤±è´¥: %v", err)
 }

 // æ„é€ ä¸€ä¸ª Data å­—æ®µï¼Œå°è¯•ä½¿ dataStoreId è¢«è§£æä¸ºé uint32 ç±»å‹
 logs := []*types.Log{
  {
   Address: common.HexToAddress("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1"),
   Topics:  []common.Hash{parser.EventHash()},
   Data:    common.Hex2Bytes("000000000000000000000000000000000000000000000000000000010000000027bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243"), // dataStoreId ä¸º uint64
  },
 }
 expectResult := 0
 validate := func(results []ConfirmDataStoreData) error {
  if len(results) != expectResult {
   return fmt.Errorf("æœŸæœ› %d ä¸ªç»“æœï¼Œå®é™…å¾—åˆ° %d ä¸ª", expectResult, len(results))
  }
  return nil
 }

 results, err := parser.ParseLogs(logs)
 if err != nil {
  t.Errorf("ParseLogs æœŸæœ›æ— é”™è¯¯ï¼Œå®é™…é”™è¯¯: %v", err)
 }
 if len(results) != expectResult {
  t.Errorf("ParseLogs æœŸæœ› %d ä¸ªç»“æœï¼Œå®é™…å¾—åˆ° %d ä¸ª", expectResult, len(results))
 }
 if err := validate(results); err != nil {
  t.Errorf("ç»“æœéªŒè¯å¤±è´¥: %v", err)
 }
 if len(results) > 0 {
  fmt.Printf("æµ‹è¯• 'æ— æ•ˆ dataStoreId ç±»å‹' çš„ç»“æœ: %v\n", results)
 }
}

// æµ‹è¯• ParseLogs çš„ç±»å‹æ–­è¨€é”™è¯¯è·¯å¾„
func TestEventParser_ParseLogs_TypeErrors(t *testing.T) {
 parser, err := NewEventParser("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1")
 if err != nil {
  t.Fatalf("Failed to create parser: %v", err)
 }

 // æ„é€ æ—¥å¿—æ•°æ®ï¼šuint64 å’ŒåŠ¨æ€ bytes
 logs := []*types.Log{
  {
   Address: common.HexToAddress("0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1"),
   Topics:  []common.Hash{parser.eventHash},
   Data: common.Hex2Bytes(
    "00000000000000000000000000000000000000000000000000000000000089ba" + // uint64 dataStoreId = 35226
     "0000000000000000000000000000000000000000000000000000000000000020" + // bytes åç§»é‡
     "0000000000000000000000000000000000000000000000000000000000000020" + // bytes é•¿åº¦ = 32
     "27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243"), // bytes æ•°æ®
  },
 }

 results, err := parser.ParseLogs(logs)
 if err != nil {
  t.Fatalf("Failed to parse logs: %v", err)
 }
 if len(results) == 0 {
  t.Log("No valid logs parsed, ensure test data is correct")
 }
}

```

### è¿è¡Œæµ‹è¯•

```bash
ethertrace/go/ethertrace via ğŸ¹ v1.24.2 took 4.2s 
âœ go test
receipt: &{2 [] 1 4504702 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0 64 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 0 0 0] [0x140001d24d0 0x140001d2580] 0xfd26d40e17213bcafcf94bab9af92343302df9df970f20e1c9d515525e86e23e 0x0000000000000000000000000000000000000000 217366 1983676084 0 <nil> 0x7efe14a2db20d977d1267d7701e3fb5e40ddbbc5ac31af3326e4194e84522eec 20487721 62}
GetLogs:  [{0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1 [0x34d57e230be557a52d94166eb9035810e61ac973182a92b09e6b0e99110665a9] [173 67 67 239 116 234 22 115 43 6 168 238 25 6 135 134 190 71 250 49 42 180 111 252 143 155 203 188 17 102 114 65 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 137 137 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 211 194 27 206 204 237 161 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 160 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 20483832 0xbc00672e67935e54c08d895b88fe41aa5cf664dc8f855836c7d26726e0c59ea4 132 0xc4254a63b8ef260bf3e271ff7c38b97817d08c7195600c0b2e0de404ec11d798 96 false} {0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1 [0xfbb7f4f1b0b9ad9e75d69d22c364e13089418d86fcb5106792a53046c0fb33aa] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 137 138 247 74 220 237 98 226 119 32 201 25 189 191 165 87 183 176 180 209 84 227 250 235 54 73 198 244 242 222 237 52 86 219] 20483832 0xbc00672e67935e54c08d895b88fe41aa5cf664dc8f855836c7d26726e0c59ea4 132 0xc4254a63b8ef260bf3e271ff7c38b97817d08c7195600c0b2e0de404ec11d798 97 false}]
err: <nil>
logs:  [0x1400015c000 0x1400015c0a8]
GetLogs:  []
err: end (0) < begin (20483831)
logs:  []
results [{35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243}]
æµ‹è¯• 'å•ä¸ªæœ‰æ•ˆæ—¥å¿—' çš„ç»“æœ: [{35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243}]
æµ‹è¯• 'å¤§é‡æ—¥å¿—ï¼ˆå‹åŠ›æµ‹è¯•ï¼‰' çš„ç»“æœ: [{35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243} {35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243} {35258 0x27bc3002d7e4ee667592949a50f4f01d8d4632461a12f2243} {35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243} {35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243}]
PASS
ok      github.com/qiaopengjun5162/ethertrace/go/ethertrace     2.773s

ethertrace/go/ethertrace via ğŸ¹ v1.24.2 took 4.2s 
âœ go test -v                        
=== RUN   TestEthClient_GetTxReceiptByHash
receipt: &{2 [] 1 4504702 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0 64 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 0 0 0] [0x140003b80b0 0x140003b8160] 0xfd26d40e17213bcafcf94bab9af92343302df9df970f20e1c9d515525e86e23e 0x0000000000000000000000000000000000000000 217366 1983676084 0 <nil> 0x7efe14a2db20d977d1267d7701e3fb5e40ddbbc5ac31af3326e4194e84522eec 20487721 62}
--- PASS: TestEthClient_GetTxReceiptByHash (0.52s)
=== RUN   TestEthClient_GetLogs
GetLogs:  [{0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1 [0x34d57e230be557a52d94166eb9035810e61ac973182a92b09e6b0e99110665a9] [173 67 67 239 116 234 22 115 43 6 168 238 25 6 135 134 190 71 250 49 42 180 111 252 143 155 203 188 17 102 114 65 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 137 137 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 211 194 27 206 204 237 161 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 160 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 20483832 0xbc00672e67935e54c08d895b88fe41aa5cf664dc8f855836c7d26726e0c59ea4 132 0xc4254a63b8ef260bf3e271ff7c38b97817d08c7195600c0b2e0de404ec11d798 96 false} {0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1 [0xfbb7f4f1b0b9ad9e75d69d22c364e13089418d86fcb5106792a53046c0fb33aa] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 137 138 247 74 220 237 98 226 119 32 201 25 189 191 165 87 183 176 180 209 84 227 250 235 54 73 198 244 242 222 237 52 86 219] 20483832 0xbc00672e67935e54c08d895b88fe41aa5cf664dc8f855836c7d26726e0c59ea4 132 0xc4254a63b8ef260bf3e271ff7c38b97817d08c7195600c0b2e0de404ec11d798 97 false}]
err: <nil>
logs:  [0x140000b4000 0x140000b40a8]
--- PASS: TestEthClient_GetLogs (1.38s)
=== RUN   TestEthClient_GetTxReceiptByHash2
=== RUN   TestEthClient_GetTxReceiptByHash2/æœ‰æ•ˆäº¤æ˜“å“ˆå¸Œ
=== RUN   TestEthClient_GetTxReceiptByHash2/æ— æ•ˆäº¤æ˜“å“ˆå¸Œ
--- PASS: TestEthClient_GetTxReceiptByHash2 (0.61s)
    --- PASS: TestEthClient_GetTxReceiptByHash2/æœ‰æ•ˆäº¤æ˜“å“ˆå¸Œ (0.30s)
    --- PASS: TestEthClient_GetTxReceiptByHash2/æ— æ•ˆäº¤æ˜“å“ˆå¸Œ (0.31s)
=== RUN   TestNewEthClient
--- PASS: TestNewEthClient (0.00s)
=== RUN   TestNewEthClientRpcUrl
    client_test.go:98: err: empty RPC URL
--- PASS: TestNewEthClientRpcUrl (0.00s)
=== RUN   TestNewEthClient_InvalidURLs
=== RUN   TestNewEthClient_InvalidURLs/ç©ºåœ°å€
    client_test.go:138: client: <nil>
    client_test.go:139: err: empty RPC URL
=== RUN   TestNewEthClient_InvalidURLs/æ— æ•ˆåè®®
    client_test.go:138: client: <nil>
    client_test.go:139: err: no known transport for URL scheme "ftp"
=== RUN   TestNewEthClient_InvalidURLs/<UNK>
    client_test.go:138: client: <nil>
    client_test.go:139: err: parse "http://localhost:12w222q": invalid port ":12w222q" after host
=== RUN   TestNewEthClient_InvalidURLs/éæ³•ç«¯å£
    client_test.go:138: client: <nil>
    client_test.go:139: err: parse "http://localhost:abc": invalid port ":abc" after host
--- PASS: TestNewEthClient_InvalidURLs (0.00s)
    --- PASS: TestNewEthClient_InvalidURLs/ç©ºåœ°å€ (0.00s)
    --- PASS: TestNewEthClient_InvalidURLs/æ— æ•ˆåè®® (0.00s)
    --- PASS: TestNewEthClient_InvalidURLs/<UNK> (0.00s)
    --- PASS: TestNewEthClient_InvalidURLs/éæ³•ç«¯å£ (0.00s)
=== RUN   TestEthClient2
    client_test.go:158: err: dial unix htrpc.mevlocke: connect: no such file or directory
--- PASS: TestEthClient2 (0.00s)
=== RUN   TestEthClient_GetLogs2
GetLogs:  []
err: end (0) < begin (20483831)
    client_test.go:170: logs:  []
    client_test.go:171: err: end (0) < begin (20483831)
    client_test.go:173: No logs found, but test passes as query was successful
logs:  []
--- PASS: TestEthClient_GetLogs2 (0.30s)
=== RUN   TestEventParser_ParseLogs
results [{35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243}]
--- PASS: TestEventParser_ParseLogs (0.00s)
=== RUN   TestNewEventParser
=== RUN   TestNewEventParser/æœ‰æ•ˆåœ°å€
=== RUN   TestNewEventParser/æ— æ•ˆåœ°å€
=== RUN   TestNewEventParser/ç©ºåœ°å€
=== RUN   TestNewEventParser/é›¶åœ°å€
=== RUN   TestNewEventParser/ç¼ºå°‘0xå‰ç¼€
--- PASS: TestNewEventParser (0.00s)
    --- PASS: TestNewEventParser/æœ‰æ•ˆåœ°å€ (0.00s)
    --- PASS: TestNewEventParser/æ— æ•ˆåœ°å€ (0.00s)
    --- PASS: TestNewEventParser/ç©ºåœ°å€ (0.00s)
    --- PASS: TestNewEventParser/é›¶åœ°å€ (0.00s)
    --- PASS: TestNewEventParser/ç¼ºå°‘0xå‰ç¼€ (0.00s)
=== RUN   TestEventParser_ParseLogs_SingleValidLog
æµ‹è¯• 'å•ä¸ªæœ‰æ•ˆæ—¥å¿—' çš„ç»“æœ: [{35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243}]
--- PASS: TestEventParser_ParseLogs_SingleValidLog (0.00s)
=== RUN   TestEventParser_ParseLogs_EmptyLogs
--- PASS: TestEventParser_ParseLogs_EmptyLogs (0.00s)
=== RUN   TestEventParser_ParseLogs_InvalidAddress
--- PASS: TestEventParser_ParseLogs_InvalidAddress (0.00s)
=== RUN   TestEventParser_ParseLogs_TopicMismatch
--- PASS: TestEventParser_ParseLogs_TopicMismatch (0.00s)
=== RUN   TestEventParser_ParseLogs_EmptyTopics
--- PASS: TestEventParser_ParseLogs_EmptyTopics (0.00s)
=== RUN   TestEventParser_ParseLogs_InvalidDataFormat
--- PASS: TestEventParser_ParseLogs_InvalidDataFormat (0.00s)
=== RUN   TestEventParser_ParseLogs_LargeNumberOfLogs
æµ‹è¯• 'å¤§é‡æ—¥å¿—ï¼ˆå‹åŠ›æµ‹è¯•ï¼‰' çš„ç»“æœ: [{35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243} {35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243} {35258 0x27bc3002d7e4ee667592949a50f4f01d8d4632461a12f2243} {35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243} {35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243}]
--- PASS: TestEventParser_ParseLogs_LargeNumberOfLogs (0.01s)
=== RUN   TestEventParser_ParseLogs_InvalidDataStoreIDType
--- PASS: TestEventParser_ParseLogs_InvalidDataStoreIDType (0.00s)
=== RUN   TestEventParser_ParseLogs_TypeErrors
--- PASS: TestEventParser_ParseLogs_TypeErrors (0.00s)
PASS
ok      github.com/qiaopengjun5162/ethertrace/go/ethertrace     3.027s


```

### ç»ˆç«¯æŸ¥çœ‹å½“å‰æµ‹è¯•è¦†ç›–ç‡

```bash
ethertrace/go/ethertrace via ğŸ¹ v1.24.2 took 3.6s 
âœ  go test -cover
receipt: &{2 [] 1 4504702 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0 64 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 0 0 0] [0x1400015e000 0x1400015e0b0] 0xfd26d40e17213bcafcf94bab9af92343302df9df970f20e1c9d515525e86e23e 0x0000000000000000000000000000000000000000 217366 1983676084 0 <nil> 0x7efe14a2db20d977d1267d7701e3fb5e40ddbbc5ac31af3326e4194e84522eec 20487721 62}
GetLogs:  [{0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1 [0x34d57e230be557a52d94166eb9035810e61ac973182a92b09e6b0e99110665a9] [173 67 67 239 116 234 22 115 43 6 168 238 25 6 135 134 190 71 250 49 42 180 111 252 143 155 203 188 17 102 114 65 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 137 137 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 211 194 27 206 204 237 161 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 160 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 20483832 0xbc00672e67935e54c08d895b88fe41aa5cf664dc8f855836c7d26726e0c59ea4 132 0xc4254a63b8ef260bf3e271ff7c38b97817d08c7195600c0b2e0de404ec11d798 96 false} {0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1 [0xfbb7f4f1b0b9ad9e75d69d22c364e13089418d86fcb5106792a53046c0fb33aa] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 137 138 247 74 220 237 98 226 119 32 201 25 189 191 165 87 183 176 180 209 84 227 250 235 54 73 198 244 242 222 237 52 86 219] 20483832 0xbc00672e67935e54c08d895b88fe41aa5cf664dc8f855836c7d26726e0c59ea4 132 0xc4254a63b8ef260bf3e271ff7c38b97817d08c7195600c0b2e0de404ec11d798 97 false}]
err: <nil>
logs:  [0x14000176420 0x140001764c8]
GetLogs:  []
err: end (0) < begin (20483831)
logs:  []
results [{35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243}]
æµ‹è¯• 'å•ä¸ªæœ‰æ•ˆæ—¥å¿—' çš„ç»“æœ: [{35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243}]
æµ‹è¯• 'å¤§é‡æ—¥å¿—ï¼ˆå‹åŠ›æµ‹è¯•ï¼‰' çš„ç»“æœ: [{35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243} {35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243} {35258 0x27bc3002d7e4ee667592949a50f4f01d8d4632461a12f2243} {35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243} {35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243}]
PASS
coverage: 100.0% of statements
ok      github.com/qiaopengjun5162/ethertrace/go/ethertrace     2.935s


```

è¿™ä¸ªè¾“å‡ºç»“æœè¡¨ç¤ºæµ‹è¯•è¿è¡ŒæˆåŠŸï¼Œå¹¶ä¸”è¾¾åˆ°äº† 100% çš„ä»£ç è¦†ç›–ç‡ï¼

### ç”Ÿæˆå¯è§†åŒ–æŠ¥å‘Š

 ç”Ÿæˆè¦†ç›–ç‡æ•°æ®æ–‡ä»¶

```bash
ethertrace/go/ethertrace via ğŸ¹ v1.24.2 took 4.4s 
âœ go test -coverprofile=coverage.out


receipt: &{2 [] 1 4504702 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0 64 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 0 0 0] [0x1400015e000 0x1400015e0b0] 0xfd26d40e17213bcafcf94bab9af92343302df9df970f20e1c9d515525e86e23e 0x0000000000000000000000000000000000000000 217366 1983676084 0 <nil> 0x7efe14a2db20d977d1267d7701e3fb5e40ddbbc5ac31af3326e4194e84522eec 20487721 62}
GetLogs:  [{0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1 [0x34d57e230be557a52d94166eb9035810e61ac973182a92b09e6b0e99110665a9] [173 67 67 239 116 234 22 115 43 6 168 238 25 6 135 134 190 71 250 49 42 180 111 252 143 155 203 188 17 102 114 65 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 137 137 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 211 194 27 206 204 237 161 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 160 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 20483832 0xbc00672e67935e54c08d895b88fe41aa5cf664dc8f855836c7d26726e0c59ea4 132 0xc4254a63b8ef260bf3e271ff7c38b97817d08c7195600c0b2e0de404ec11d798 96 false} {0x5BD63a7ECc13b955C4F57e3F12A64c10263C14c1 [0xfbb7f4f1b0b9ad9e75d69d22c364e13089418d86fcb5106792a53046c0fb33aa] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 137 138 247 74 220 237 98 226 119 32 201 25 189 191 165 87 183 176 180 209 84 227 250 235 54 73 198 244 242 222 237 52 86 219] 20483832 0xbc00672e67935e54c08d895b88fe41aa5cf664dc8f855836c7d26726e0c59ea4 132 0xc4254a63b8ef260bf3e271ff7c38b97817d08c7195600c0b2e0de404ec11d798 97 false}]
err: <nil>
logs:  [0x14000260840 0x140002608e8]
GetLogs:  []
err: end (0) < begin (20483831)
logs:  []
results [{35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243}]
æµ‹è¯• 'å•ä¸ªæœ‰æ•ˆæ—¥å¿—' çš„ç»“æœ: [{35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243}]
æµ‹è¯• 'å¤§é‡æ—¥å¿—ï¼ˆå‹åŠ›æµ‹è¯•ï¼‰' çš„ç»“æœ: [{35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243} {35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243} {35258 0x27bc3002d7e4ee667592949a50f4f01d8d4632461a12f2243} {35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243} {35258 0x27bc30064cc44c6aef26ca2d7e4ee667592949a50f4f01d8d4632461a12f2243}]
PASS
coverage: 100.0% of statements
ok      github.com/qiaopengjun5162/ethertrace/go/ethertrace     2.486s


```

ç”ŸæˆHTMLæŠ¥å‘Šï¼ˆè‡ªåŠ¨åœ¨æµè§ˆå™¨æ‰“å¼€ï¼‰

```bash
ethertrace/go/ethertrace via ğŸ¹ v1.24.2 took 3.9s 
âœ go tool cover -html=coverage.out  

```

### æµè§ˆå™¨æŸ¥çœ‹æµ‹è¯•è¦†ç›–ç‡

`client.go` æ–‡ä»¶

![image-20250428151815203](/images/image-20250428151815203.png)

`event_parser.go`æ–‡ä»¶

![image-20250428151836109](/images/image-20250428151836109.png)

ç¡®è®¤æµ‹è¯•è¦†ç›–ç‡è¾¾åˆ°100%ï¼

## æ€»ç»“

é€šè¿‡æœ¬æ–‡çš„å®æˆ˜ä¹‹æ—…ï¼Œæˆ‘ä»¬ç”¨ Go è¯­è¨€æ‰“é€ äº†ä¸€ä¸ªå¼ºå¤§çš„ Web3 æ•°æ®ç¥å™¨ï¼ŒæˆåŠŸè§£é”ä»¥å¤ªåŠäº‹ä»¶è§£æçš„ç§˜å¯†ï¼ä»è¿æ¥ä»¥å¤ªåŠèŠ‚ç‚¹åˆ°æå–äº¤æ˜“æ”¶æ®å’ŒåŒºå—æ—¥å¿—ï¼Œå†åˆ°ç²¾å‡†è§£æ ConfirmDataStore äº‹ä»¶ï¼Œé¡¹ç›®å±•ç¤ºäº† Go åœ¨åŒºå—é“¾å¼€å‘ä¸­çš„é«˜æ•ˆä¸ä¼˜é›…ã€‚ä»¥ä¸‹æ˜¯æ ¸å¿ƒäº®ç‚¹ï¼š

1. æ¨¡å—åŒ–è®¾è®¡ï¼šclient.go å’Œ event_parser.go åˆ†ç¦»ç½‘ç»œå’Œè§£æé€»è¾‘ï¼Œä»£ç æ¸…æ™°æ˜“ç»´æŠ¤ã€‚
2. æè‡´å¯é æ€§ï¼šå…¨é¢æµ‹è¯•ç”¨ä¾‹è¦†ç›–æ­£å¸¸å’Œå¼‚å¸¸åœºæ™¯ï¼Œ100% æµ‹è¯•è¦†ç›–ç‡ç¡®ä¿ä»£ç ç¨³å¦‚ç£çŸ³ã€‚
3. é«˜æ‰©å±•æ€§ï¼šé¡¹ç›®ç»“æ„æ”¯æŒæ‰©å±•åˆ°å…¶ä»–äº‹ä»¶è§£ææˆ–å¤šé“¾æ•°æ®å¤„ç†ï¼Œé€‚åˆå¤šæ ·åŒ–åœºæ™¯ã€‚
4. å®ç”¨æ€§å¼ºï¼šæä¾›äº†å¯ç›´æ¥å¤ç”¨çš„ä»£ç æ¡†æ¶ï¼Œé™ä½ Web3 å¼€å‘çš„å…¥é—¨é—¨æ§›ã€‚

å¯¹äº Web3 å¼€å‘è€…ï¼Œè¿™æ˜¯ä¸€ä¸ªç†æƒ³çš„èµ·ç‚¹ã€‚ä½ å¯ä»¥åŸºäºæ­¤é¡¹ç›®ä¼˜åŒ–æ€§èƒ½ã€æ”¯æŒå®æ—¶äº‹ä»¶ç›‘å¬ï¼Œæˆ–æ‰©å±•åˆ°å…¶ä»–åŒºå—é“¾ç”Ÿæ€ã€‚æœªæ¥ï¼Œå°è¯•åŠ å…¥å¤šé“¾å…¼å®¹ã€å¹¶å‘å¤„ç†æˆ–é”™è¯¯é‡è¯•æœºåˆ¶ï¼Œå°†è®©ä½ çš„å·¥å…·æ›´ä¸Šä¸€å±‚æ¥¼ï¼æƒ³æ·±å…¥æ¢ç´¢ï¼Ÿæ–‡æœ«å‚è€ƒèµ„æ–™ä¸ºä½ æä¾› Go å’Œä»¥å¤ªåŠå¼€å‘çš„å®è´µèµ„æºã€‚å¿«æ¥åŠ¨æ‰‹å®è·µï¼Œè§£é”å±äºä½ çš„ Web3 æ•°æ®ä¸–ç•Œï¼

## å‚è€ƒ

- <https://go.dev/dl/>
- <https://github.com/adjust/go-wrk>
- <https://github.com/ethereum/go-ethereum/>
- <https://geth.ethereum.org/>
- <https://etherscan.io/>
- <https://github.com/qiaopengjun5162/ethertrace>
- <https://github.com/golang/go>
- <https://go.googlesource.com/go>
- <https://github.com/TheAlgorithms/Go>

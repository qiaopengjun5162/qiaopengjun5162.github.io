<!DOCTYPE html>
<html class="not-ready lg:text-base" lang="en">
  <!-- Head section: Includes meta tags, styles, and scripts -->
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  <!-- Title -->
  <title>
    数据结构与算法（Python版）之算法分析 - Paxon Qiao&#x27;s Tech Blog
  </title>

  <!-- Meta -->
  <meta name="theme-color" />

  
  <!-- Author -->
  
  <!---->
  
  <!---->
  
  <!---->
  
  <!---->
  
  <!---->
  <meta name="description" content="数据结构与算法（Python版）之算法分析" />
  <meta name="author" content="Paxon Qiao" />
  <!-- The Open Graph protocol -->
  <meta property="og:type" content="website" />
  <meta property="og:title" content="数据结构与算法（Python版）之算法分析" />
  <meta property="og:site_name" content="Paxon Qiao&#x27;s Tech Blog" />
  <meta property="og:description" content="数据结构与算法（Python版）之算法分析" />
  <meta property="og:url" content="https:&#x2F;&#x2F;qiaopengjun5162.github.io&#x2F;algorithm2&#x2F;" />
  
  <!---->
  
  <!---->
  
  <!---->
  
  <meta property="og:image" content="https://qiaopengjun5162.github.io/icons/github.svg" />
  
  <!---->
  

  <!-- CSS & JS -->
  <link rel="preload stylesheet" as="style" href="https://qiaopengjun5162.github.io/main.css" />
  <style>
    :root {
      --bg: #f4f4f5;
      --bg-dark: #18181b;
      --header: #e4e4e7;
      --header-dark: #27272a;
    }
  </style>

  

  <!-- Dark Icon -->
  <link rel="preload" as="image" href="https://qiaopengjun5162.github.io/icons/theme.svg" />

  <!-- Math -->
  
  <!---->
  <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css"
  integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI"
  crossorigin="anonymous"
/>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js"
  integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t"
  crossorigin="anonymous"
></script>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js"
  integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
  crossorigin="anonymous"
></script>

<script>
  document.addEventListener("DOMContentLoaded", () =>
    renderMathInElement(document.body, {
      // customised options
      // • auto-render specific keys, e.g.:
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
      ],
      // • rendering keys, e.g.:
      throwOnError: false,
    }),
  );
</script>

  <!---->
  
  <!---->

  <!-- Mermaid -->
  
  <!---->

  <!-- Favicon -->
  <link rel="icon" href="https://qiaopengjun5162.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://qiaopengjun5162.github.io/apple-touch-icon.png" />

  <!-- Feeds -->
  
  <!---->
  
  <link
    rel="alternate"
    type="application/atom+xml"
    title="Atom"
    href="https://qiaopengjun5162.github.io/atom.xml"
  />
   
  <!---->
  

  <!-- Canonical -->
  <link rel="canonical" href="https:&#x2F;&#x2F;qiaopengjun5162.github.io&#x2F;algorithm2&#x2F;" />

  <!-- Head inject -->
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <!-- Header: Navigation and branding -->
    <header
  class="header fixed top-0 z-40 mx-auto min-h-[3.5rem] w-full"
>
  <div class="mx-auto w-full max-w-4xl p-3 lg:flex lg:justify-between">
    <div class="flex justify-between">
      <div class="flex items-center">
        <a class="text-2xl font-semibold" href="https://qiaopengjun5162.github.io">Paxon Qiao&#x27;s Tech Blog</a>
        <div
          class="btn-dark ml-4 h-6 w-6 shrink-0 cursor-pointer text-[0] [background:url(./icons/theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
          role="button"
          aria-label="Dark"
        ></div>
      </div>
      
      <div
        class="btn-menu relative z-50 flex h-8 w-8 shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
        role="button"
        aria-label="Menu"
      ></div>
      
    </div>
    <script>
      // base
      const htmlClass = document.documentElement.classList;
      setTimeout(() => {
        htmlClass.remove("not-ready");
      }, 10);

      // mobile menu
      const btnMenu = document.querySelector(".btn-menu");
      btnMenu?.addEventListener("click", () => {
        htmlClass.toggle("open");
      });

      // dark theme
      const setDark = (isDark) => {
        if (isDark) {
          document.body.dispatchEvent(new CustomEvent("set-theme", { detail: "dark" }));
          htmlClass.add("dark");
        } else {
          document.body.dispatchEvent(new CustomEvent("set-theme", { detail: "light" }));
          htmlClass.remove("dark");
        }
        localStorage.setItem("dark", isDark);
      };

      // init
      const darkScheme = window.matchMedia("(prefers-color-scheme: dark)");
      if (htmlClass.contains("dark")) {
        setDark(true);
      } else {
        const darkVal = localStorage.getItem("dark");
        setDark(darkVal ? darkVal === "true" : darkScheme.matches);
      }

      // listen system
      darkScheme.addEventListener("change", (event) => {
        setDark(event.matches);
      });

      // manual switch
      const btnDark = document.querySelector(".btn-dark");
      btnDark.addEventListener("click", () => {
        setDark(localStorage.getItem("dark") !== "true");
      });
    </script>
    
    <nav class="flex w-full items-center lg:w-auto">
      <ul
        class="nav-wrapper flex w-full flex-col py-2 lg:w-auto lg:flex-row lg:self-center lg:py-0"
      >
        
        <li>
          <a
            class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0"
            href="https://qiaopengjun5162.github.io//projects"
            >Projects</a
          >
        </li>
        
        <li>
          <a
            class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0"
            href="https://qiaopengjun5162.github.io//archive"
            >Archive</a
          >
        </li>
        
        <li>
          <a
            class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0"
            href="https://qiaopengjun5162.github.io//tags"
            >Tags</a
          >
        </li>
        
        <li>
          <a
            class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0"
            href="https://qiaopengjun5162.github.io//categories"
            >Categories</a
          >
        </li>
        
        <li>
          <a
            class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0"
            href="https://qiaopengjun5162.github.io//about"
            >About</a
          >
        </li>
        
      </ul>
      <!-- Header Nav inject -->
      
    </nav>
    
  </div>
</header>


    <!-- Body Start: Content injection point -->
    

    <!-- Main Content -->
    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl break-words px-4 pb-16 pt-32 dark:prose-invert prose-pre:rounded-lg prose-img:rounded-lg"
    >
      
<article>
  <!-- Page Start inject -->
  

  <header class="mb-16">
    <h1 class="!my-0 pb-2.5">数据结构与算法（Python版）之算法分析</h1>
    <div class="text-sm antialiased opacity-60">
  
  <time>2023-03-24</time>
  <span class="mx-1">&middot;</span>
  <span>21min</span>
  <!---->
  <!---->
  <!---->
  <!---->
  
  <span class="mx-1">&middot;</span>
  <span>Paxon Qiao</span>
  
  <!-- Page Info inject -->
  
</div>

  </header>

  

  <!-- TOC -->
  
<div class="block-bg mb-12 flex rounded-lg p-2 text-lg">
  <details>
    <summary class="cursor-pointer py-1 pl-4">
      <span>Table of Contents</span>
    </summary>
    <div class="px-2">
      <ul>
        
        <li>
          <a
            class="no-underline hover:underline"
            href="https://qiaopengjun5162.github.io/algorithm2/#er-suan-fa-fen-xi"
            >二、算法分析</a
          >
          
          <ul>
            
            <li>
              <a
                class="no-underline hover:underline"
                href="https://qiaopengjun5162.github.io/algorithm2/#201-shen-me-shi-suan-fa-fen-xi"
                >201 什么是算法分析</a
              >
            </li>
            
            <li>
              <a
                class="no-underline hover:underline"
                href="https://qiaopengjun5162.github.io/algorithm2/#202-da-obiao-shi-fa"
                >202 大O表示法</a
              >
            </li>
            
            <li>
              <a
                class="no-underline hover:underline"
                href="https://qiaopengjun5162.github.io/algorithm2/#203-bian-wei-ci-pan-duan-wen-ti-shang"
                >203 “变位词”判断问题（上）</a
              >
            </li>
            
            <li>
              <a
                class="no-underline hover:underline"
                href="https://qiaopengjun5162.github.io/algorithm2/#204-bian-wei-ci-pan-duan-wen-ti-xia"
                >204 “变位词”判断问题（下）</a
              >
            </li>
            
            <li>
              <a
                class="no-underline hover:underline"
                href="https://qiaopengjun5162.github.io/algorithm2/#205-pythonshu-ju-lei-xing-de-xing-neng-shang"
                >205 Python数据类型的性能（上）</a
              >
            </li>
            
            <li>
              <a
                class="no-underline hover:underline"
                href="https://qiaopengjun5162.github.io/algorithm2/#206-pythonshu-ju-lei-xing-de-xing-neng-xia"
                >206 Python数据类型的性能（下）</a
              >
            </li>
            
          </ul>
          
        </li>
        
      </ul>
    </div>
  </details>
</div>



  <!-- Content -->
  <section><h1 id="er-suan-fa-fen-xi">二、算法分析</h1>
<h2 id="201-shen-me-shi-suan-fa-fen-xi">201 什么是算法分析</h2>
<h3 id="dui-bi-cheng-xu-huan-shi-suan-fa">对比程序，还是算法？</h3>
<ul>
<li>如何对比两个程序？
<ul>
<li>看起来不同，但解决同一个问题的程序，哪个“更好”？</li>
</ul>
</li>
<li>程序和算法的区别
<ul>
<li>算法是对问题解决的分布描述</li>
<li>程序则是采用某种编程语言实现的算法，同一个算法通过不同的程序员采用不同的编程语言，能产生很多程序</li>
</ul>
</li>
</ul>
<h3 id="lei-ji-qiu-he-wen-ti">累计求和问题</h3>
<ul>
<li>我们来看一段程序，完成从 1 到 n 的累加，输出总和
<ul>
<li>设置累计变量 = 0</li>
<li>从 1 到 n 循环，逐次累加到累计变量</li>
<li>返回累计变量</li>
</ul>
</li>
</ul>
<pre data-lang="python" style="background-color:#272822;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span style="font-style:italic;color:#f92672;">def </span><span style="color:#a6e22e;">sum0fN</span><span>(</span><span style="font-style:italic;color:#fd971f;">n</span><span>):
</span><span>  theSum </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">0
</span><span>  </span><span style="color:#f92672;">for </span><span>i </span><span style="color:#f92672;">in </span><span style="color:#66d9ef;">range</span><span>(</span><span style="color:#ae81ff;">1</span><span>, n </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1</span><span>):
</span><span>    theSum </span><span style="color:#f92672;">= </span><span>theSum </span><span style="color:#f92672;">+ </span><span>i
</span><span>  </span><span style="color:#f92672;">return </span><span>theSum
</span><span>
</span><span style="color:#66d9ef;">print</span><span>(sum0fN(</span><span style="color:#ae81ff;">10</span><span>))
</span></code></pre>
<ul>
<li>再看第二段程序，是否感觉怪怪的？
<ul>
<li>但实际上本程序功能与前面那段相同</li>
<li>这段程序失败之处在于：变了命名词不达意，以及包含了无用的垃圾代码</li>
</ul>
</li>
</ul>
<pre data-lang="python" style="background-color:#272822;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span style="font-style:italic;color:#f92672;">def </span><span style="color:#a6e22e;">foo</span><span>(</span><span style="font-style:italic;color:#fd971f;">tom</span><span>):
</span><span>  fred </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">0
</span><span>  </span><span style="color:#f92672;">for </span><span>bill </span><span style="color:#f92672;">in </span><span style="color:#66d9ef;">range</span><span>(</span><span style="color:#ae81ff;">1</span><span>, tom </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1</span><span>):
</span><span>    barney </span><span style="color:#f92672;">= </span><span>bill
</span><span>    fred </span><span style="color:#f92672;">= </span><span>fred </span><span style="color:#f92672;">+ </span><span>barney
</span><span>  </span><span style="color:#f92672;">return </span><span>fred
</span><span>
</span><span style="color:#66d9ef;">print</span><span>(foo(</span><span style="color:#ae81ff;">10</span><span>))
</span></code></pre>
<h3 id="suan-fa-fen-xi-de-gai-nian">算法分析的概念</h3>
<ul>
<li>比较程序的“好坏”，有很多因素
<ul>
<li>代码风格、可读性等等</li>
</ul>
</li>
<li>我们主要感兴趣的是算法本身特性</li>
<li>算法分析主要就是从计算资源消耗的角度来评判和比较算法
<ul>
<li>更高效利用计算资源，或者更少占用计算资源的算法，就是好算法</li>
<li>从这个角度，前述两段程序实际上是基本相同的，它们都采用了一样的算法来解决累计求和问题</li>
</ul>
</li>
</ul>
<h3 id="shuo-dao-dai-ma-feng-ge-he-ke-du-xing">说到代码风格和可读性</h3>
<ul>
<li>为什么Python的强制缩进是好的？
<ul>
<li>语句块功能和视觉效果统一</li>
</ul>
</li>
<li>苹果公司的一个低级Bug
<ul>
<li>由于c语言源代码书写缩进对齐的疏忽</li>
<li>造成SSL连接验证被跳过</li>
<li>2014.2.22修正iOS7.0.6</li>
</ul>
</li>
<li>代码不像看起来那样运行</li>
</ul>
<h3 id="ji-suan-zi-yuan-zhi-biao">计算资源指标</h3>
<ul>
<li>那么何为计算资源？</li>
<li>一种是算法解决问题过程中需要的存储空间或内存
<ul>
<li>但存储空间受到问题自身数据规模的变化影响</li>
<li>要区分哪些存储空间是问题本身描述所需，哪些是算法占用，不容易</li>
</ul>
</li>
<li>另一种是算法的执行时间
<ul>
<li>我们可以对程序进行实际运行测试，获得真实的运行时间</li>
</ul>
</li>
</ul>
<h3 id="yun-xing-shi-jian-jian-ce">运行时间检测</h3>
<ul>
<li>Python中有一个time模块，可以获取计算机系统当前时间
<ul>
<li>在算法开始前和结束后分别记录系统时间，即可得到运行时间</li>
</ul>
</li>
</ul>
<pre data-lang="python" style="background-color:#272822;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#f92672;">import </span><span>time
</span><span>time.time()
</span></code></pre>
<ul>
<li>累计求和程序的运行时间检测
<ul>
<li>用time 检测总运行时间</li>
<li>返回累计和，以及运行时间（秒）</li>
</ul>
</li>
</ul>
<pre data-lang="python" style="background-color:#272822;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#f92672;">import </span><span>time
</span><span>
</span><span style="font-style:italic;color:#f92672;">def </span><span style="color:#a6e22e;">sum0fN2</span><span>(</span><span style="font-style:italic;color:#fd971f;">n</span><span>):
</span><span>  start </span><span style="color:#f92672;">= </span><span>time.time()
</span><span>  theSum </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">0
</span><span>  </span><span style="color:#f92672;">for </span><span>i </span><span style="color:#f92672;">in </span><span style="color:#66d9ef;">range</span><span>(</span><span style="color:#ae81ff;">1</span><span>, n </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1</span><span>):
</span><span>    theSum </span><span style="color:#f92672;">= </span><span>theSum </span><span style="color:#f92672;">+ </span><span>i
</span><span>  end </span><span style="color:#f92672;">= </span><span>time.time()
</span><span>  </span><span style="color:#f92672;">return </span><span>theSum, end </span><span style="color:#f92672;">= </span><span>start
</span><span>
</span><span style="color:#f92672;">for </span><span>i </span><span style="color:#f92672;">in </span><span style="color:#66d9ef;">range</span><span>(</span><span style="color:#ae81ff;">5</span><span>):
</span><span>  </span><span style="color:#66d9ef;">print</span><span>(</span><span style="color:#e6db74;">&quot;Sum is </span><span style="color:#ae81ff;">%d</span><span style="color:#e6db74;"> required </span><span style="color:#ae81ff;">%10.7f</span><span style="color:#e6db74;"> seconds&quot; </span><span style="color:#f92672;">% </span><span>sum0fN2(</span><span style="color:#ae81ff;">10000</span><span>))
</span></code></pre>
<ul>
<li>在交互窗口连续运行5次看看
<ul>
<li>1 到 10000累加</li>
<li>每次运行约需 0.0007秒</li>
</ul>
</li>
<li>如果累加到100000？
<ul>
<li>看起来运行时间增加到 10000的10倍</li>
</ul>
</li>
<li>进一步累加到 1000000？
<ul>
<li>运行时间又是 100000的10倍了</li>
</ul>
</li>
</ul>
<h3 id="di-er-chong-wu-die-dai-de-lei-ji-suan-fa">第二种无迭代的累计算法</h3>
<ul>
<li>利用求和公式的无迭代算法</li>
</ul>
<pre data-lang="python" style="background-color:#272822;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span style="font-style:italic;color:#f92672;">def </span><span style="color:#a6e22e;">sum0fN3</span><span>(</span><span style="font-style:italic;color:#fd971f;">n</span><span>):
</span><span>  start </span><span style="color:#f92672;">= </span><span>time.time()
</span><span>  theSum </span><span style="color:#f92672;">= </span><span>(n </span><span style="color:#f92672;">* </span><span>(n </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1</span><span>)) </span><span style="color:#f92672;">/ </span><span style="color:#ae81ff;">2
</span><span>  end </span><span style="color:#f92672;">= </span><span>time.time()
</span><span>  </span><span style="color:#f92672;">return </span><span>theSum, end </span><span style="color:#f92672;">- </span><span>start
</span></code></pre>
<ul>
<li>利用同样的方法检测运行时间
<ul>
<li>10000；100000；1000000；10000000；100000000</li>
<li>0.000010 接近于0</li>
</ul>
</li>
<li>需要关注的两点
<ul>
<li>这种算法的运行时间比前种都短很多</li>
<li>运行时间与累计对象n的大小没有关系（前种算法是倍数增长关系）</li>
</ul>
</li>
<li>新算法运行时间几乎与需要累计的数目无关</li>
</ul>
<h3 id="yun-xing-shi-jian-jian-ce-de-fen-xi">运行时间检测的分析</h3>
<ul>
<li>观察一下第一种迭代算法
<ul>
<li>包含了一个循环，可能会执行更多语句</li>
<li>这个循环运行次数跟累加值n有关系，n增加，循环次数也增加</li>
</ul>
</li>
</ul>
<pre data-lang="python" style="background-color:#272822;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span style="font-style:italic;color:#f92672;">def </span><span style="color:#a6e22e;">sum0fN</span><span>(</span><span style="font-style:italic;color:#fd971f;">n</span><span>):
</span><span>  theSum </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">0
</span><span>  </span><span style="color:#f92672;">for </span><span>i </span><span style="color:#f92672;">in </span><span style="color:#66d9ef;">range</span><span>(</span><span style="color:#ae81ff;">1</span><span>, n </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1</span><span>):
</span><span>    theSum </span><span style="color:#f92672;">= </span><span>theSum </span><span style="color:#f92672;">+ </span><span>i
</span><span>  </span><span style="color:#f92672;">return </span><span>theSum
</span><span>
</span><span style="color:#66d9ef;">print</span><span>(sum0fN(</span><span style="color:#ae81ff;">10</span><span>))
</span></code></pre>
<ul>
<li>但关系运行时间的实际检测，有点问题
<ul>
<li>关于编程语言和运行环境</li>
</ul>
</li>
<li>同一个算法，采用不同的编程语言编写，放在不同的机器上运行，得到的运行时间会不一样，有时候会大不一样：
<ul>
<li>比如把非迭代算法放在老旧机器上跑，甚至可能慢过新机器上的迭代算法</li>
</ul>
</li>
<li>我们需要更好的方法来衡量算法运行时间
<ul>
<li>这个指标与具体的机器、程序、运行时段都无关</li>
</ul>
</li>
</ul>
<h2 id="202-da-obiao-shi-fa">202 大O表示法</h2>
<h3 id="suan-fa-shi-jian-du-liang-zhi-biao">算法时间度量指标</h3>
<ul>
<li>一个算法所实施的操作数量或步骤数可作为独立于具体程序/机器的度量指标
<ul>
<li>哪种操作跟算法的具体实现无关？</li>
<li>需要一种通用的基本操作来作为运行步骤的计量单位</li>
</ul>
</li>
<li>赋值语句是一个合适的选择
<ul>
<li>一条赋值语句同时包含了（表达式）计算和（变量）存储两个基本资源</li>
<li>仔细观察程序设计语言特性，除了与计算资源无关的定义语句外，主要就是三种控制流语句和赋值语句，而控制流仅仅起了组织语句的作用，并不实施处理。</li>
</ul>
</li>
</ul>
<h3 id="fu-zhi-yu-ju-zhi-xing-ci-shu">赋值语句执行次数</h3>
<ul>
<li>分析 Sum0fN的赋值语句执行次数
<ul>
<li>对于“问题规模”n</li>
<li>赋值语句数量 T(n) = 1 + n</li>
<li>那么，什么是问题规模？</li>
</ul>
</li>
</ul>
<pre data-lang="python" style="background-color:#272822;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span style="font-style:italic;color:#f92672;">def </span><span style="color:#a6e22e;">sum0fN</span><span>(</span><span style="font-style:italic;color:#fd971f;">n</span><span>):
</span><span>  theSum </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">0  </span><span style="color:#75715e;"># 1
</span><span>  </span><span style="color:#f92672;">for </span><span>i </span><span style="color:#f92672;">in </span><span style="color:#66d9ef;">range</span><span>(</span><span style="color:#ae81ff;">1</span><span>, n </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1</span><span>):  </span><span style="color:#75715e;"># n
</span><span>    theSum </span><span style="color:#f92672;">= </span><span>theSum </span><span style="color:#f92672;">+ </span><span>i  </span><span style="color:#75715e;"># 1
</span><span>    </span><span style="color:#f92672;">return </span><span>theSum
</span><span>
</span></code></pre>
<h3 id="wen-ti-gui-mo-ying-xiang-suan-fa-zhi-xing-shi-jian">问题规模影响算法执行时间</h3>
<ul>
<li>问题规模：影响算法执行时间的主要因素</li>
<li>在前n个整数累计求和的算法中，需要累计的整数个数合适作为问题规模的指标
<ul>
<li>前 100000个整数求和对比前1000个整数求和，算是同一问题的更大规模</li>
</ul>
</li>
<li>算法分析的目标是要找出问题规模会怎么影响一个算法的执行时间</li>
</ul>
<h3 id="shu-liang-ji-han-shu-order-of-magnitude">数量级函数 Order of Magnitude</h3>
<ul>
<li>基本操作数量函数 T(n) 的精确值并不是特别重要，重要的是 T(n) 中起决定性因素的主导部分
<ul>
<li>用动态的眼光看，就是当问题规模增大的时候，T(n) 中的一些部分会盖过其它部分的贡献</li>
</ul>
</li>
<li>数量级函数描述了 T(n) 中随着n增加而增加速度最快的主导部分
<ul>
<li>称作“大O”表示法，记作o(f(n))，其中 f(n) 表示 T(n) 中的主导部分</li>
</ul>
</li>
</ul>
<h3 id="que-ding-yun-xing-shi-jian-shu-liang-ji-da-ode-fang-fa">确定运行时间数量级大O的方法</h3>
<ul>
<li>
<p>例1：T(n) = 1 + n</p>
<ul>
<li>当n增大时，常数1在最终结果中显得越来越无足轻重</li>
<li>所以可以去掉1，保留n 作为主要部分，运行时间数量级就是O(n)</li>
<li>O(n)</li>
</ul>
</li>
<li>
<p>例2：T(n)=5n²+27n+1005</p>
<ul>
<li>当n很小时，常数1005其决定性作用</li>
<li>但当n越来越大，n²项就越来越重要，其它两项对结果的影响则越来越小</li>
<li>同样，n²项中的系数5，对于n²的增长速度来说也影响不大</li>
<li>所以可以在数量级中去掉27n+1005，以及系数5的部分，确定为O（n²）</li>
<li>O(n²)</li>
</ul>
</li>
</ul>
<h3 id="ying-xiang-suan-fa-yun-xing-shi-jian-de-qi-ta-yin-su">影响算法运行时间的其它因素</h3>
<ul>
<li>有时决定运行时间的不仅是问题规模</li>
<li>某些具体数据也会影响算法运行时间
<ul>
<li>分为最好、最差和平均情况，平均状况体现了算法的主流性能</li>
<li>对算法的分析要看主流，而不被某几种特定的运行状况所迷惑</li>
</ul>
</li>
</ul>
<h3 id="chang-jian-de-da-oshu-liang-ji-han-shu">常见的大O数量级函数</h3>
<ul>
<li>通常当n较小时，难以确定其数量级</li>
<li>当n增长到较大时，容易看出其主要变化量级</li>
</ul>
<table><thead><tr><th>f(n)</th><th>名称</th></tr></thead><tbody>
<tr><td>1</td><td>常数</td></tr>
<tr><td>log(n)</td><td>对数</td></tr>
<tr><td>n</td><td>线性</td></tr>
<tr><td>n*log(n)</td><td>对数线性</td></tr>
<tr><td>n²</td><td>平方</td></tr>
<tr><td>n³</td><td>立方</td></tr>
<tr><td>2^n</td><td>指数</td></tr>
</tbody></table>
<h3 id="cong-dai-ma-fen-xi-que-ding-zhi-xing-shi-jian-shu-liang-ji-han-shu">从代码分析确定执行时间数量级函数</h3>
<ul>
<li>代码赋值语句可以分为4个部分
<ul>
<li>T(n) = 3+3n²+2n+1 = 3n²+2n+4</li>
</ul>
</li>
</ul>
<pre data-lang="python" style="background-color:#272822;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span>a </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">5
</span><span>b </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">6
</span><span>c </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">10
</span><span style="color:#f92672;">for </span><span>i </span><span style="color:#f92672;">in </span><span style="color:#66d9ef;">range</span><span>(n):
</span><span>  </span><span style="color:#f92672;">for </span><span>j </span><span style="color:#f92672;">in </span><span style="color:#66d9ef;">range</span><span>(n):
</span><span>    x </span><span style="color:#f92672;">= </span><span>i </span><span style="color:#f92672;">* </span><span>i
</span><span>    y </span><span style="color:#f92672;">= </span><span>j </span><span style="color:#f92672;">* </span><span>j
</span><span>    z </span><span style="color:#f92672;">= </span><span>i </span><span style="color:#f92672;">* </span><span>j
</span><span style="color:#f92672;">for </span><span>k </span><span style="color:#f92672;">in </span><span style="color:#66d9ef;">range</span><span>(n):
</span><span>  w </span><span style="color:#f92672;">= </span><span>a </span><span style="color:#f92672;">* </span><span>k </span><span style="color:#f92672;">+</span><span style="color:#ae81ff;">45
</span><span>  v </span><span style="color:#f92672;">= </span><span>b </span><span style="color:#f92672;">* </span><span>b
</span><span>d </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">33
</span></code></pre>
<ul>
<li>仅保留最高阶项n²，去掉所有系数</li>
<li>数量级为 O(n²)</li>
</ul>
<h3 id="qi-ta-suan-fa-fu-za-du-biao-shi-fa">其它算法复杂度表示法</h3>
<ul>
<li>大O表示法
<ul>
<li>表示了所有上限中最小的那个上限</li>
</ul>
</li>
<li>大Ω表示法
<ul>
<li>表示了所有下限中最大的那个下限</li>
<li>f(n) = Ω(g(n)) 当且仅当 g(n) = o(f(n))</li>
</ul>
</li>
<li>大θ表示法
<ul>
<li>如果上下限相同，那么就可以用大θ表示</li>
<li>f(n) = θ(g(n))</li>
<li>当且仅当 f(n) = O(g(n)) 且 f(n) = Ω(g(n))</li>
</ul>
</li>
</ul>
<h2 id="203-bian-wei-ci-pan-duan-wen-ti-shang">203 “变位词”判断问题（上）</h2>
<h3 id="bian-wei-ci-pan-duan-wen-ti">“变位词”判断问题</h3>
<ul>
<li>问题描述
<ul>
<li>所谓“变位词”是指两个词之间存在组成字母的重新排列关系</li>
<li>如：heart和earth，Python和typhon</li>
<li>为了简单起见，假设参与判断的两个词仅由小写字母构成，而且长度相等</li>
</ul>
</li>
<li>解题目标：写一个bool函数，以两个词作为参数，返回这两个词是否变位词</li>
<li>可以很好展示同一问题的不同数量级算法</li>
</ul>
<h3 id="jie-fa-1-zhu-zi-jian-cha">解法1：逐字检查</h3>
<ul>
<li>解法思路
<ul>
<li>将词1中的字符逐个到词2中检查是否存在</li>
<li>存在就“打勾”标记（防止重复检查）</li>
<li>如果每个字符都能找到，则两个词是变位词</li>
<li>只要有1个字符找不到，就不是变位词</li>
</ul>
</li>
<li>程序技巧
<ul>
<li>实现“打勾”标记：将词2对应字符设为None</li>
<li>由于字符串是不可变类型，需要先复制到列表中</li>
</ul>
</li>
</ul>
<h3 id="jie-fa-1-zhu-zi-jian-cha-cheng-xu-dai-ma">解法1：逐字检查-程序代码</h3>
<pre data-lang="python" style="background-color:#272822;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span style="font-style:italic;color:#f92672;">def </span><span style="color:#a6e22e;">anagramSolution1</span><span>(</span><span style="font-style:italic;color:#fd971f;">s1</span><span>, </span><span style="font-style:italic;color:#fd971f;">s2</span><span>):
</span><span>  alist </span><span style="color:#f92672;">= </span><span style="font-style:italic;color:#66d9ef;">list</span><span>(s2)
</span><span>  pos1 </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">0
</span><span>  stillOK </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">True
</span><span>  </span><span style="color:#f92672;">while </span><span>pos1 </span><span style="color:#f92672;">&lt; </span><span style="color:#66d9ef;">len</span><span>(s1) </span><span style="color:#f92672;">and </span><span>stillOK:
</span><span>    pos2 </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">0
</span><span>    found </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">False
</span><span>    </span><span style="color:#f92672;">while </span><span>pos2 </span><span style="color:#f92672;">&lt; </span><span style="color:#66d9ef;">len</span><span>(alist) </span><span style="color:#f92672;">and not </span><span>found:
</span><span>      </span><span style="color:#f92672;">if </span><span>s1[pos1] </span><span style="color:#f92672;">== </span><span>alist[pos2]:
</span><span>        found </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">True
</span><span>      </span><span style="color:#f92672;">else</span><span>:
</span><span>        pos2 </span><span style="color:#f92672;">= </span><span>pos2 </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1
</span><span>    </span><span style="color:#f92672;">if </span><span>found:
</span><span>      alist[pos2] </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">None
</span><span>    </span><span style="color:#f92672;">else</span><span>:
</span><span>      stillOK </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">False
</span><span>    pos1 </span><span style="color:#f92672;">= </span><span>pos1 </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1
</span><span>  </span><span style="color:#f92672;">return </span><span>stillOk
</span><span>
</span><span style="color:#66d9ef;">print</span><span>(anagramSolution1(</span><span style="color:#e6db74;">&#39;abcd&#39;</span><span>, </span><span style="color:#e6db74;">&#39;dcba&#39;</span><span>))
</span></code></pre>
<h3 id="jie-fa-1-zhu-zi-jian-cha-suan-fa-fen-xi">解法1：逐字检查-算法分析</h3>
<ul>
<li>问题规模：词中包含的字符个数n</li>
<li>主要部分在与两重循环
<ul>
<li>外层循环遍历 s1 每个字符，将内层循环执行n次</li>
<li>而内层循环在s2中查找字符，每个字符的对比次数，分别是1、2…n中的一个，而且各不相同</li>
</ul>
</li>
<li>所以总执行次数是 1 + 2 + 3 + ……+ n
<ul>
<li>可知其数量级为 O(n²)</li>
</ul>
</li>
</ul>
<h3 id="jie-fa-2-pai-xu-bi-jiao">解法2：排序比较</h3>
<ul>
<li>解题思路
<ul>
<li>将两个字符串都安装字母顺序排好序</li>
<li>再逐个字符对比是否相同，如果相同则是变为词</li>
<li>有任何不同就不是变位词</li>
</ul>
</li>
</ul>
<h3 id="jie-fa-2-pai-xu-bi-jiao-cheng-xu-dai-ma">解法2：排序比较-程序代码</h3>
<pre data-lang="python" style="background-color:#272822;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span style="font-style:italic;color:#f92672;">def </span><span style="color:#a6e22e;">anagramSolution2</span><span>(</span><span style="font-style:italic;color:#fd971f;">s1</span><span>, </span><span style="font-style:italic;color:#fd971f;">s2</span><span>):
</span><span>  alist1 </span><span style="color:#f92672;">= </span><span style="font-style:italic;color:#66d9ef;">list</span><span>(s1)
</span><span>  alist2 </span><span style="color:#f92672;">= </span><span style="font-style:italic;color:#66d9ef;">list</span><span>(s2)
</span><span>  
</span><span>  alist1.sort()
</span><span>  alist2.sort()
</span><span>  pos </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">0
</span><span>  matches </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">True
</span><span>  </span><span style="color:#f92672;">while </span><span>pos </span><span style="color:#f92672;">&lt; </span><span style="color:#66d9ef;">len</span><span>(s1) </span><span style="color:#f92672;">and </span><span>matches:
</span><span>    </span><span style="color:#f92672;">if </span><span>alist1[pos] </span><span style="color:#f92672;">== </span><span>alist2[pos]:
</span><span>      pos </span><span style="color:#f92672;">= </span><span>pos </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1
</span><span>    </span><span style="color:#f92672;">else</span><span>:
</span><span>      matches </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">False
</span><span>  </span><span style="color:#f92672;">return </span><span>matches
</span><span>
</span><span style="color:#66d9ef;">print</span><span>(anagramSolution2(</span><span style="color:#e6db74;">&#39;abcde&#39;</span><span>, </span><span style="color:#e6db74;">&#39;edcba&#39;</span><span>))
</span></code></pre>
<h3 id="jie-fa-2-pai-xu-bi-jiao-suan-fa-fen-xi">解法2： 排序比较-算法分析</h3>
<ul>
<li>粗看上去，本算法只有一个循环，最多执行n次，数量级是 O(n)
<ul>
<li>但循环前面的两个sort并不是无代价的</li>
<li>如果查询下后面的章节，会发现排序算法采用不同的解决方案，其运行时间数量级差不多是 O(n²) 或者 O(n log n)，大过循环的O(n)</li>
</ul>
</li>
<li>所以本算法时间主导的步骤是排序步骤</li>
<li>本算法的运行时间数量级就等于排序过程的数量级O(n log n)</li>
</ul>
<h2 id="204-bian-wei-ci-pan-duan-wen-ti-xia">204 “变位词”判断问题（下）</h2>
<h3 id="jie-fa-3-bao-li-fa">解法3：暴力法</h3>
<ul>
<li>暴力法解题思路为：穷尽所有可能组合</li>
<li>将s1 中出现的字符进行全排列，再查看 s2 是否出现在全排列列表中</li>
<li>这里最大困难时产生s1所有字符的全排列
<ul>
<li>根据组合数学的结论，如果n个字符进行全排列，其所有可能的字符串个数为n!</li>
</ul>
</li>
<li>我们已知 n! 的增长速度甚至超过 2^n
<ul>
<li>例如，对于 20 个字符长的词来说，将产生 20! = 2,432,902,008,176,640,000 个候选词</li>
<li>如果每微秒处理1个候选词的话，需要近8万年时间来做完所有的匹配。</li>
</ul>
</li>
<li>结论：暴力法恐怕不能算是个好算法</li>
</ul>
<h3 id="jie-fa-4-ji-shu-bi-jiao">解法4：计数比较</h3>
<ul>
<li>解题思路：对比两个词中每个字母出现的次数，如果26个字母出现的次数都相同的话，这两个字符串就一定是变位词</li>
<li>具体做法：为每个词设置一个 26 位的计数器，先检查每个词，在计数器中设定好每个字母出现的次数</li>
<li>计数完成后，进入比较阶段，看两个字符串的计数器是否相同，如果相同则输出是变位词的结论</li>
</ul>
<h3 id="jie-fa-4-ji-shu-bi-jiao-cheng-xu-dai-ma">解法4：计数比较-程序代码</h3>
<pre data-lang="python" style="background-color:#272822;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span style="font-style:italic;color:#f92672;">def </span><span style="color:#a6e22e;">anagramSolution4</span><span>(</span><span style="font-style:italic;color:#fd971f;">s1</span><span>, </span><span style="font-style:italic;color:#fd971f;">s2</span><span>):
</span><span>  c1 </span><span style="color:#f92672;">= </span><span>[</span><span style="color:#ae81ff;">0</span><span>] </span><span style="color:#f92672;">* </span><span style="color:#ae81ff;">26
</span><span>  c2 </span><span style="color:#f92672;">= </span><span>[</span><span style="color:#ae81ff;">0</span><span>] </span><span style="color:#f92672;">* </span><span style="color:#ae81ff;">26
</span><span>  </span><span style="color:#f92672;">for </span><span>i </span><span style="color:#f92672;">in </span><span style="color:#66d9ef;">range</span><span>(</span><span style="color:#66d9ef;">len</span><span>(s1)):
</span><span>    pos </span><span style="color:#f92672;">= </span><span style="color:#66d9ef;">ord</span><span>(s1[i]) </span><span style="color:#f92672;">- </span><span style="color:#66d9ef;">ord</span><span>(</span><span style="color:#e6db74;">&#39;a&#39;</span><span>)  </span><span style="color:#75715e;"># 分别都计数
</span><span>    c1[pos] </span><span style="color:#f92672;">= </span><span>c1[pos] </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1
</span><span>  </span><span style="color:#f92672;">for </span><span>i </span><span style="color:#f92672;">in </span><span style="color:#66d9ef;">range</span><span>(</span><span style="color:#66d9ef;">len</span><span>(s2)):
</span><span>    pos </span><span style="color:#f92672;">= </span><span style="color:#66d9ef;">ord</span><span>(s2[i]) </span><span style="color:#f92672;">- </span><span style="color:#66d9ef;">ord</span><span>(</span><span style="color:#e6db74;">&#39;a&#39;</span><span>)
</span><span>    c2[pos] </span><span style="color:#f92672;">= </span><span>c2[pos] </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1
</span><span>  j </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">0
</span><span>  stillOK </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">True
</span><span>  </span><span style="color:#f92672;">while </span><span>j </span><span style="color:#f92672;">&lt; </span><span style="color:#ae81ff;">26 </span><span style="color:#f92672;">and </span><span>stillOK:  </span><span style="color:#75715e;"># 计数器比较
</span><span>    </span><span style="color:#f92672;">if </span><span>c1[j] </span><span style="color:#f92672;">== </span><span>c2[j]:
</span><span>      j </span><span style="color:#f92672;">= </span><span>j </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1
</span><span>    </span><span style="color:#f92672;">else</span><span>:
</span><span>      stillOK </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">False
</span><span>  </span><span style="color:#f92672;">return </span><span>stillOK
</span><span>
</span><span style="color:#66d9ef;">print</span><span>(anagramSolution4(</span><span style="color:#e6db74;">&#39;apple&#39;</span><span>, </span><span style="color:#e6db74;">&#39;pleap&#39;</span><span>))
</span></code></pre>
<h3 id="jie-fa-4-ji-shu-bi-jiao-suan-fa-fen-xi">解法4：计数比较-算法分析</h3>
<ul>
<li>计数比较算法中有3个循环迭代，但不像解法1那样存在嵌套循环
<ul>
<li>前两个循环用于对字符串进行计数，操作次数等于字符长度n</li>
<li>第3个循环用于计数器比较，操作次数总是26次</li>
</ul>
</li>
<li>所以总操作次数 T(n) = 2n + 26，其数量级为 O(n)
<ul>
<li>这是一个线性数量级的算法，是4个变位词判断算法中性能最优的</li>
</ul>
</li>
<li>值得注意的是，本算法依赖于两个长度为26的计数器列表，来保存字符计数，这相比前3个算法需要更多的存储空间
<ul>
<li>如果考虑由大字符集构成的词（如中文具有上万不同字符），还会需要更多存储空间。</li>
</ul>
</li>
<li>牺牲存储空间来换取运行时间，或者相反，这种在时间空间之间的取舍和权衡，在选择问题解法的过程中经常会出现。
<ul>
<li>“不可随处小便”，“小处不可随便”</li>
</ul>
</li>
</ul>
<p>思考：把解法4用字典作为计算器修改…</p>
<h2 id="205-pythonshu-ju-lei-xing-de-xing-neng-shang">205 Python数据类型的性能（上）</h2>
<h3 id="pythonshu-ju-lei-xing-de-xing-neng">Python数据类型的性能</h3>
<ul>
<li>Python两种内置数据类型上各种操作的大O数量级
<ul>
<li>列表list 和字典 dict 这是两种重要的Python数据类型</li>
</ul>
</li>
</ul>
<h3 id="dui-bi-listhe-dictde-cao-zuo">对比list和dict的操作</h3>
<p>都是容器类型、可变类型</p>
<table><thead><tr><th>类型</th><th>list</th><th>dict</th></tr></thead><tbody>
<tr><td>索引</td><td>自然数 i</td><td>不可变类型值 Key</td></tr>
<tr><td>添加</td><td>append、extend、insert</td><td>b[k] = v</td></tr>
<tr><td>删除</td><td>pop、remove*</td><td>pop</td></tr>
<tr><td>更新</td><td>a[i] = v</td><td>b[k] = v</td></tr>
<tr><td>正查</td><td>a[i]、a[i:j]</td><td>b[k]、copy</td></tr>
<tr><td>反查</td><td>index(v)、count(v)</td><td>无</td></tr>
<tr><td>其它</td><td>reverse、sort</td><td>has_key、update</td></tr>
</tbody></table>
<h3 id="list-lie-biao-shu-ju-lei-xing">List 列表数据类型</h3>
<ul>
<li>list 类型各种操作（Interface）的实现方法有很多，如何选择具体哪种实现方法？</li>
<li>总的方案就是，让最常用的操作性能最好，牺牲不太常用的操作
<ul>
<li>80/20准则：80%的功能其使用率只有20%</li>
</ul>
</li>
</ul>
<h3 id="list-lie-biao-shu-ju-lei-xing-chang-yong-cao-zuo-xing-neng">list 列表数据类型常用操作性能</h3>
<ul>
<li>最常用的是：按索引取值和赋值（v = a[i]，a[i] = v）
<ul>
<li>由于列表的随机访问特性，这两个操作执行时间与列表大小无关，均为O(1)</li>
</ul>
</li>
<li>另一个是列表增长，可以选择append() 和 _<em>add</em>_() “+”
<ul>
<li>lst.append(v)，执行时间是O(1)</li>
<li>lst = lst + [v]，执行时间是O(n+k)，其中k是被加的列表长度</li>
<li>选择哪个方法来操作列表，决定了程序的性能</li>
</ul>
</li>
</ul>
<h3 id="4chong-sheng-cheng-qian-nge-zheng-shu-lie-biao-de-fang-fa">4种生成前n个整数列表的方法</h3>
<ul>
<li>首先是循环连接列表（+）方式生成</li>
<li>然后是用append方法添加元素生成</li>
<li>接着用列表推导式来做</li>
<li>最后是Range函数调用转成列表</li>
</ul>
<pre data-lang="python" style="background-color:#272822;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span style="font-style:italic;color:#f92672;">def </span><span style="color:#a6e22e;">test1</span><span>():
</span><span>  l </span><span style="color:#f92672;">= </span><span>[]
</span><span>  </span><span style="color:#f92672;">for </span><span>i </span><span style="color:#f92672;">in </span><span style="color:#66d9ef;">range</span><span>(</span><span style="color:#ae81ff;">1000</span><span>):
</span><span>    l </span><span style="color:#f92672;">= </span><span>l </span><span style="color:#f92672;">+ </span><span>[i]
</span><span>    
</span><span style="font-style:italic;color:#f92672;">def </span><span style="color:#a6e22e;">test2</span><span>():
</span><span>  l </span><span style="color:#f92672;">= </span><span>[]
</span><span>  </span><span style="color:#f92672;">for </span><span>i </span><span style="color:#f92672;">in </span><span style="color:#66d9ef;">range</span><span>(</span><span style="color:#ae81ff;">1000</span><span>):
</span><span>    l.append(i)
</span><span>
</span><span style="font-style:italic;color:#f92672;">def </span><span style="color:#a6e22e;">test3</span><span>():
</span><span>  l </span><span style="color:#f92672;">= </span><span>[i </span><span style="color:#f92672;">for </span><span>i </span><span style="color:#f92672;">in </span><span style="color:#66d9ef;">range</span><span>(</span><span style="color:#ae81ff;">1000</span><span>)]
</span><span>  
</span><span style="font-style:italic;color:#f92672;">def </span><span style="color:#a6e22e;">test4</span><span>():
</span><span>  l </span><span style="color:#f92672;">= </span><span style="font-style:italic;color:#66d9ef;">list</span><span>(</span><span style="color:#66d9ef;">range</span><span>(</span><span style="color:#ae81ff;">1000</span><span>))
</span></code></pre>
<h3 id="shi-yong-timeit-mo-kuai-dui-han-shu-ji-shi">使用 timeit 模块对函数计时</h3>
<ul>
<li>创建一个 Timer 对象，指定需要反复运行的语句和只需要运行一次的“安装语句”</li>
<li>然后调用这个对象的 timeit 方法，其中可以指定反复运行多少次</li>
</ul>
<pre data-lang="python" style="background-color:#272822;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#f92672;">from </span><span>timeit </span><span style="color:#f92672;">import </span><span>Timer
</span><span>
</span><span>t1 </span><span style="color:#f92672;">= </span><span>Timer(</span><span style="color:#e6db74;">&quot;test1()&quot;</span><span>, </span><span style="color:#e6db74;">&quot;from __main__ import test1&quot;</span><span>)
</span><span style="color:#66d9ef;">print</span><span>(</span><span style="color:#e6db74;">&quot;concat </span><span style="color:#ae81ff;">%f</span><span style="color:#e6db74;"> seconds</span><span style="color:#ae81ff;">\n</span><span style="color:#e6db74;">&quot; </span><span style="color:#f92672;">% </span><span>t1.timeit(</span><span style="font-style:italic;color:#fd971f;">number</span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">1000</span><span>))
</span><span>
</span><span>t2 </span><span style="color:#f92672;">= </span><span>Timer(</span><span style="color:#e6db74;">&quot;test2()&quot;</span><span>, </span><span style="color:#e6db74;">&quot;from __main__ import test2&quot;</span><span>)
</span><span style="color:#66d9ef;">print</span><span>(</span><span style="color:#e6db74;">&quot;append </span><span style="color:#ae81ff;">%f</span><span style="color:#e6db74;"> seconds</span><span style="color:#ae81ff;">\n</span><span style="color:#e6db74;">&quot; </span><span style="color:#f92672;">% </span><span>t2.timeit(</span><span style="font-style:italic;color:#fd971f;">number</span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">1000</span><span>))
</span><span>
</span><span>t3 </span><span style="color:#f92672;">= </span><span>Timer(</span><span style="color:#e6db74;">&quot;test3()&quot;</span><span>, </span><span style="color:#e6db74;">&quot;from __main__ import test3&quot;</span><span>)
</span><span style="color:#66d9ef;">print</span><span>(</span><span style="color:#e6db74;">&quot;comprehension </span><span style="color:#ae81ff;">%f</span><span style="color:#e6db74;"> seconds</span><span style="color:#ae81ff;">\n</span><span style="color:#e6db74;">&quot; </span><span style="color:#f92672;">% </span><span>t3.timeit(</span><span style="font-style:italic;color:#fd971f;">number</span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">1000</span><span>))
</span><span>
</span><span>t4 </span><span style="color:#f92672;">= </span><span>Timer(</span><span style="color:#e6db74;">&quot;test4()&quot;</span><span>, </span><span style="color:#e6db74;">&quot;from __main__ import test4&quot;</span><span>)
</span><span style="color:#66d9ef;">print</span><span>(</span><span style="color:#e6db74;">&quot;list range </span><span style="color:#ae81ff;">%f</span><span style="color:#e6db74;"> seconds</span><span style="color:#ae81ff;">\n</span><span style="color:#e6db74;">&quot; </span><span style="color:#f92672;">% </span><span>t4.timeit(</span><span style="font-style:italic;color:#fd971f;">number</span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">1000</span><span>))
</span></code></pre>
<h3 id="4chong-sheng-cheng-qian-nge-zheng-shu-lie-biao-de-fang-fa-ji-shi">4种生成前n个整数列表的方法计时</h3>
<ul>
<li>我们看到，4种方法运行时间差别很大
<ul>
<li>列表连接（concat）最慢，List range 最快，速度相差近200倍。</li>
<li>append 也要比 concat 快得多</li>
<li>另外，我们注意到列表推导式速度是 append 两倍的样子</li>
</ul>
</li>
</ul>
<pre data-lang="python" style="background-color:#272822;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span>concat </span><span style="color:#ae81ff;">1.889487 </span><span>seconds
</span><span>append </span><span style="color:#ae81ff;">0.091561 </span><span>seconds
</span><span>comprehension </span><span style="color:#ae81ff;">0.038418 </span><span>seconds
</span><span style="font-style:italic;color:#66d9ef;">list </span><span style="color:#66d9ef;">range </span><span style="color:#ae81ff;">0.009710 </span><span>seconds
</span></code></pre>
<h3 id="list-ji-ben-cao-zuo-de-da-oshu-liang-ji">List 基本操作的大O数量级</h3>
<table><thead><tr><th>Operation</th><th>Big-O Efficiency</th></tr></thead><tbody>
<tr><td>Index []</td><td>O(1)</td></tr>
<tr><td>index assignment</td><td>O(1)</td></tr>
<tr><td>append</td><td>O(1)</td></tr>
<tr><td>pop()</td><td>O(1)</td></tr>
<tr><td>pop(i)</td><td>O(n)</td></tr>
<tr><td>insert(i, item)</td><td>O(n)</td></tr>
<tr><td>del operator</td><td>O(n)</td></tr>
<tr><td>iteration</td><td>O(n)</td></tr>
<tr><td>contains(in)</td><td>O(n)</td></tr>
<tr><td>get slice [x:y]</td><td>O(k)</td></tr>
<tr><td>del slice</td><td>O(n)</td></tr>
<tr><td>set slice</td><td>O(n+k)</td></tr>
<tr><td>reverse</td><td>O(n)</td></tr>
<tr><td>concatenate</td><td>O(k)</td></tr>
<tr><td>sort</td><td>O(n log n)</td></tr>
<tr><td>multiply</td><td>O(nk)</td></tr>
</tbody></table>
<h2 id="206-pythonshu-ju-lei-xing-de-xing-neng-xia">206 Python数据类型的性能（下）</h2>
<h3 id="list-pop-de-ji-shi-shi-yan">list.pop 的计时试验</h3>
<ul>
<li>
<p>我们注意到pop这个操作</p>
<ul>
<li>pop() 从列表末尾移除元素，O(1)</li>
<li>pop(i) 从列表中部移除元素，O(n)</li>
</ul>
</li>
<li>
<p>原因在于Python所选择的实现方法</p>
<ul>
<li>从中部移除元素的话，要把移除元素后面的元素</li>
<li>全部向前挪位复制一遍，这个看起来有点笨拙</li>
<li>但这种实现方法能够保证列表按索引取值和赋值的操作很快，达到O(1)</li>
<li>这也算是一种对常用和不常用操作的折衷方案</li>
</ul>
</li>
<li>
<p>为了验证表中的大O数量级</p>
</li>
</ul>
</section>

  <hr />

  <!-- Post Taxonomies -->
  
<footer class="mt-12 flex flex-col">
  <!---->
  <!---->
  <!---->
  <!---->
  <!---->
  <!---->
  
  <div class="mb-2 flex flex-wrap">
    <span class="block-bg mb-1.5 mr-1.5 rounded-lg px-5 py-1.5">Categories </span>
    
    <a
      class="block-bg block-hover mb-1.5 mr-1.5 rounded-lg px-5 py-1.5 no-underline"
      href="https://qiaopengjun5162.github.io/categories/suan-fa/"
      >算法</a
    >
    
  </div>
  
  <div class="mb-2 flex flex-wrap">
    <span class="block-bg mb-1.5 mr-1.5 rounded-lg px-5 py-1.5">Tags </span>
    
    <a
      class="block-bg block-hover mb-1.5 mr-1.5 rounded-lg px-5 py-1.5 no-underline"
      href="https://qiaopengjun5162.github.io/tags/suan-fa/"
      >算法</a
    >
    
  </div>
  
</footer>



  <!-- Post Nav -->
  
<nav class="block-bg mt-12 flex flex-wrap rounded-lg text-lg">
  
  <a
    class="block-hover-mask ml-auto flex min-w-[50%] grow items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline"
    href="https:&#x2F;&#x2F;qiaopengjun5162.github.io&#x2F;aws-cli-dynamodb&#x2F;"
  >
    <span class="ml-1.5">←</span>
    <span>AWS CLI DynamoDB</span>
  </a>
   
  <a
    class="block-hover-mask flex min-w-[50%] grow items-center rounded-l-md p-6 pr-3 font-semibold no-underline"
    href="https:&#x2F;&#x2F;qiaopengjun5162.github.io&#x2F;algorithm&#x2F;"
  >
    <span>数据结构与算法（Python版）之概述</span>
    <span class="mr-1.5">→</span>
  </a>
  
</nav>



  <!-- Comment -->
   
<div class="giscus mt-12"></div>
<script
  src="https://giscus.app/client.js"
  data-repo="qiaopengjun5162&#x2F;qiaopengjun5162.github.io"
  data-repo-id="R_kgDOI8edYQ"
  data-category="Announcements"
  data-category-id="DIC_kwDOI8edYc4ClMMv"
  data-mapping="pathname"
  data-strict="0"
  data-reactions-enabled="1"
  data-emit-metadata="0"
  data-input-position="bottom"
  data-theme="preferred_color_scheme"
  data-lang="zh-CN"
  data-loading="lazy"
  crossorigin="anonymous"
  async
></script>
<!---->
 

  <!-- Page End inject -->
  
</article>

    </main>

    <!-- Footer -->
    <footer class="mx-auto flex max-w-3xl flex-wrap items-center px-8 py-4 text-sm opacity-60">
  <div class="mr-auto basis-full lg:basis-1/2">
    <!---->
    <!---->
    &copy; 2020 - 2024<!---->
    
    <a class="link" href="https://qiaopengjun5162.github.io">
      Paxon Qiao
    </a>
     |<!---->
    <!---->
    <a class="link" href="https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-sa&#x2F;4.0&#x2F;deed" rel="noopener" target="_blank">
      CC BY-SA 4.0
    </a>
    <!---->
    
  </div>
  <div class="flex basis-full lg:basis-1/2 lg:justify-end">
    <a class="link mr-6 lg:ml-6" href="https://www.getzola.org/" rel="noopener" target="_blank">
      Powered by Zola
    </a>
    <a class="link" href="https://github.com/st1020/kita" rel="noopener" target="_blank">✎ Kita</a>
  </div>
  <!-- Footer inject -->
  
</footer>


    <!-- Body End: Additional scripts or markup -->
    
  </body>
</html>
